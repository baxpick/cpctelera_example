diff -ruN cpctelera-linux-cpc/README_EP_CPC.txt cpctelera-linux-enterprise/README_EP_CPC.txt
--- cpctelera-linux-cpc/README_EP_CPC.txt	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/README_EP_CPC.txt	2025-01-11 16:57:32
@@ -0,0 +1,37 @@
+Change HW setting, by set the required HW to 1 in file: 
+cpctelera/CPCteleraHW.src
+and set the appropriate #define statement in file:
+cpctelera/src/keyboard/keyboard.h 
+
+using different Arkos players in main.c: 
+#include <cpctelera.h>          for Arkos 1 player
+#include <cpcteleraAkg.h>       for Arkos 2 Akg player
+#include <cpcteleraAkm.h>       for Arkos 2 Akm player
+#include <cpcteleraAky.h>       for Arkos 2 Aky player
+#include <cpcteleraLW.h>        for Arkos 2 LW player
+labels are the same, just player name should be inserted after cpct_akp for example music init for 
+- Arkos1: cpct_akp_musicInit(0x6000)
+- Arkos2 Akg: cpct_akpAKG_musicInit(0x6000, 0)
+
+Player settings can be set in the following files:
+cpctelera/src/audio/arkostracker*_var.src
+
+If you use Enterprise hardware then AY emulation parameters can set in file:
+cpctelera/CPCteleraHW.src
+
+if you do not use hw envelopes then set         NO_ENVELOPE_IRQ to 1, saves CPU, and memory
+if you use low frequency hw envelopes then set  NO_ENVELOPE_IRQ to 0, and do not set any    ENABLE_xxxHZ_IRQ (ENABLE_300HZ_IRQ is not implemented yet in the loader)
+if you use high frequency hw envelopes then set NO_ENVELOPE_IRQ to 0, and set               ENABLE_1000HZ_IRQ , the usage of 1KHz envelope emulation is a bit tricky, 
+because you have to set up a counter 20 for your code which should run in video interrupt, and has to be called in every 20th interrupt, but the music player should 
+be called in each interrupt, timing is solved in the music player routine.
+
+the following parameters are for behaviour if there is noise and tone on a AY channel in the same time:
+toneAndNoiseModeAtnns   set 1 if you want to get tone frequency as noise on channel A
+toneAndNoiseModeAtone   set 1 if you want to get noise frequency on channel A
+toneAndNoiseModeAtoise  set 1 if you want to get tone frequency on channel A
+
+EP file loader is start.src it can be translated by sjasm 0.39.
+it is prepared for loading 3 files, 1 screen, 1 binary which is called, and after finish returns to loader, and for the final binary file.
+Screen file and 1st binary can be omitted if any of them does not exist by specifying load address 0 to the file which is going to be omitted.
+Load address, load length, start address, and file name has to be updated in start.src
+EP version of CPCtelera is prepared to use maximum 2 video page in same time, video ram configuration can be set in the loader with appropriate vidpage variable.
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/CPCteleraHW.src cpctelera-linux-enterprise/cpctelera/CPCteleraHW.src
--- cpctelera-linux-cpc/cpctelera/CPCteleraHW.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/CPCteleraHW.src	2025-01-11 16:57:38
@@ -0,0 +1,38 @@
+.equ HARDWARE_CPC         , 0
+.equ HARDWARE_ENTERPRISE  , 1
+
+    .if HARDWARE_ENTERPRISE
+; =============================================================================
+; if non-zero, the envelope emulation routine is disabled
+.equ NO_ENVELOPE_IRQ        ,   1
+; 2-5: use 6 VINT LPBs, with 51-line VINT pulse after line 34, 86, 138, or 190
+.equ ENABLE_300HZ_IRQ       ,   0
+.equ ENABLE_1000HZ_IRQ      ,   0
+; if enabled, channel A is played at the left, channel B at center,
+; and channel C at right
+.equ ENABLE_STEREO          ,   1
+; envelope sample rate = 1000 / ENV_SRATE_DIV Hz (increase this for lower
+; quality and CPU usage)
+.equ ENV_SRATE_DIV          ,   1 ;1
+; minimum envelope frequency value (should be at least 26 * ENV_SRATE_DIV,
+; and less than 256)
+.equ MIN_ENV_FREQVAL        ,   26 * ENV_SRATE_DIV
+; select how tone and noise being enabled on the same channel should be handled
+;   bit 0 = 0: play tone frequency
+;   bit 0 = 1: play noise frequency
+;         >15: use distortion specified in bits 4-7 (defaults to 30h for noise)
+.equ toneAndNoiseModeAtnns  ,   0
+.equ toneAndNoiseModeBtnns  ,   0
+.equ toneAndNoiseModeCtnns  ,   0
+.equ toneAndNoiseModeAtone  ,   0
+.equ toneAndNoiseModeBtone  ,   0
+.equ toneAndNoiseModeCtone  ,   0
+.equ toneAndNoiseModeAnoise ,   1
+.equ toneAndNoiseModeBnoise ,   1
+.equ toneAndNoiseModeCnoise ,   1
+; DAVE channels assigned to each AY channel
+.equ ayDaveChnA             ,   0
+.equ ayDaveChnB             ,   1
+.equ ayDaveChnC             ,   2
+
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostracker.s cpctelera-linux-enterprise/cpctelera/src/audio/arkostracker.s
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostracker.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostracker.s	2025-03-03 16:40:39
@@ -48,6 +48,9 @@
 .equ PLY_SystemFriendly , 0
 .equ PLY_RetrigValue    , #0xFE
 
+.include "../../CPCteleraHW.src"
+.include "arkostracker_var.src"
+
 ;;------------------------------------------------------------------------------------------------------
 ;;--- PLAYER CODE START
 ;;------------------------------------------------------------------------------------------------------
@@ -90,7 +93,7 @@
 ;; sound results.
 ;;
 ;; Destroyed Register values: 
-;;    AF, AF', BC, BC', DE, DE', HL, HL'
+;;    AF, AF', BC, BC', DE, DE', HL, HL', IX, IY
 ;;
 ;; Required memory:
 ;;    1794 bytes 
@@ -113,6 +116,29 @@
 
 _cpct_akp_musicPlay::
 cpct_akp_musicPlay_asm::   ;; Entry point for assembly calls 
+  .if HARDWARE_ENTERPRISE
+   .ifeq NO_ENVELOPE_IRQ
+    .if ENABLE_1000HZ_IRQ
+        in      a,(#0xb4)
+        and     #0x02
+        jp      nz,envelopeInterrupt
+        ld      a,#0x31
+        out     (#0xb4),a
+    .else
+     .if ENABLE_300HZ_IRQ
+cntr    ld      a,#0x06
+        dec     a
+        ld      (cntr+1),a
+        jp      nz,envelopeInterrupt
+        ld      a,#0x06
+        ld      (cntr+1),a
+     .else
+        call    envelopeInterrupt
+     .endif
+    .endif
+   .endif
+  .endif
+
 PLY_Play:
 
 ;***** Player System Friendly has to restore registers *****
@@ -123,8 +149,8 @@
    push af
    push bc
 .endif
-   push ix
-   push iy
+;   push ix
+;   push iy
 
    xor  a
    ld   (_cpct_akp_digidrumStatus), a     ;Reset the Digidrum flag.
@@ -809,6 +835,9 @@
 
 ;Send the registers to PSG. Various codes according to the machine used.
 PLY_SendRegisters:
+
+ .ifeq PLY_UseEnterprise
+
    ;A=Register 7
 
    ld  de, #0xC080
@@ -1038,9 +1067,8 @@
 
    .endif
       PLY_PSGREG13_RecoverSystemRegisters:
-         pop iy
-         pop ix
-
+ ;        pop iy
+ ;        pop ix
    .if PLY_SystemFriendly
          pop bc
          pop af
@@ -1072,8 +1100,728 @@
    out (c), e
    out (c), d
 
-   ret
+   ret 
+ .else
+RecoverSystemRegisters:
+;    pop iy
+;    pop ix
+    push    af
+  .ifeq NO_ENVELOPE_IRQ
+    call    envelopeInterrupt
+  .endif
+	ld      de,#PLY_PSGRegistersArray
+    ld      c,#0x00
+;Register 0
+    call    ayRegisterWriteDE
+;Register 1
+    call    ayRegisterWriteDE
+;Register 2
+    call    ayRegisterWriteDE
+;Register 3
+    call    ayRegisterWriteDE
+;Register 4
+    call    ayRegisterWriteDE
+;Register 5
+    call    ayRegisterWriteDE
+;Register 6
+	call    ayRegisterWriteDE
+;Register 7
+    pop     af
+    call    ayRegisterWrite
+;Register 8
+  .if PLY_UseFades
+	ld      a,(de)
+PLY_Channel1_FadeValue:
+    sub #0x00		    ;Set a value from 0 (full volume) to 16 or more (volume to 0).
+	jr nc,nfade1
+    xor     a
+nfade1:
+	call    ayRegisterWrite
+	inc de
 
+  .else
+	
+	call    ayRegisterWriteDE
+  .endif
+    inc     de                      ;Skip unused byte.
+
+;Register 9
+  .if PLY_UseFades			;If PLY_UseFades is set to 1, we manage the volume fade.
+	ld      a,(de)
+PLY_Channel2_FadeValue: 
+    sub #0x00		    ;Set a value from 0 (full volume) to 16 or more (volume to 0).
+	jr nc,nfade2
+    xor     a
+nfade2:
+	call    ayRegisterWrite
+	inc de
+
+  .else
+	
+	call    ayRegisterWriteDE
+  .endif
+    inc     de                      ;Skip unused byte.
+
+;Register 10
+  .if PLY_UseFades
+	ld      a,(de)
+PLY_Channel3_FadeValue: 
+    sub     #0x00		            ;Set a value from 0 (full volume) to 16 or more (volume to 0).
+	jr nc,nfade3
+    xor     a
+nfade3:
+	call    ayRegisterWrite
+	inc de
+
+  .else
+	
+	call    ayRegisterWriteDE
+  .endif
+
+;Register 11
+	call    ayRegisterWriteDE
+
+;Register 12
+	call    ayRegisterWriteDE
+
+;Register 13
+PLY_PSGReg13_Code:
+	ld      a,(de)
+PLY_PSGReg13_Retrig: 
+    cp      #0xff				;If IsRetrig?, force the R13 to be triggered.
+	ret     z
+	ld      (PLY_PSGReg13_Retrig + 1),a
+	jp      ayRegisterWrite
+
+
+
+; =============================================================================
+
+  .ifeq NO_ENVELOPE_IRQ
+
+envelopeInterrupt:
+
+    .if ENABLE_1000HZ_IRQ 
+        ld    a, #0x13
+        out   (#0xb4), a
+    .endif
+        push  hl
+        push  bc
+envelopeInterrupt.l1:    ld    hl,#0x0000                 ; * envelope counter
+      .if ENABLE_1000HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #500) / #1000)
+      .else
+        .if ENABLE_300HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #150) / #300)
+        .else
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #25) / #50)
+        .endif
+      .endif
+        add   hl, bc
+envelopeInterrupt.l2:    jr    c, envelopeInterrupt.l19                   ; * JR if envelope is stopped
+envelopeInterrupt.l3:    ld    bc, #0xffff               ; * envelope frequency
+envelopeInterrupt.l4:    ld    a,#0x00                   ; * envelope state (0 to 15)
+envelopeInterrupt.l5:    dec   a                         ; * envelope direction (INC A or DEC A)
+        add   hl, bc
+        jr    nc, envelopeInterrupt.l5
+        ld    (envelopeInterrupt.l1 + 1), hl
+        cp    #0x10
+envelopeInterrupt.l6:    jr    nc, envelopeInterrupt.l21                  ; * envelope mode
+envelopeInterrupt.l7:    ld    (envelopeInterrupt.l4 + 1), a
+envelopeInterrupt.l8:    add   a,#<ayVolumeTable
+        ld    l, a
+        adc   a, #>ayVolumeTable
+        sub   l
+        ld    h,a
+        or    a
+envelopeInterrupt.l9:
+        ld    a, (hl)
+        pop   bc
+envelopeInterrupt.l10:   jr    envelopeInterrupt.l12                      ; * envelope enable mode
+envelopeInterrupt.l11:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channel A only
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l12:   pop   hl
+        ret
+envelopeInterrupt.l13:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and B
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l14:
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; envelope on channel B only (Carry=0)
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l15:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l16:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channel C only
+        pop   hl
+        ret
+envelopeInterrupt.l17:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A, B, and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l18:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channels B and C
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l19:   ld    (envelopeInterrupt.l1 + 1), hl
+        pop   bc
+        pop   hl
+        ret
+envelopeInterrupt.l20:   ld    l, #<(ayVolumeTable + 15)       ; envelope modes 11 and 13
+        .db  #0x01                      ; = LD BC, nnnn
+envelopeInterrupt.l21:   ld    l, #<ayVolumeTable      ; envelope modes 0 to 7, 9, and 15
+        ld    h, #>ayVolumeTable
+        ld    a, #0x18                  ; = JR +nn
+        ld    (envelopeInterrupt.l2), a                  ; stop envelope
+        jp    envelopeInterrupt.l9
+envelopeInterrupt.l22:   and   #0x0f                     ; envelope modes 8 and 12
+        jp    envelopeInterrupt.l7
+envelopeInterrupt.l23:   jp    m, envelopeInterrupt.l24                   ; envelope modes 10 and 14
+        xor   #0x1f
+        ld    l, a
+        ld    h,#0x3d                   ; set direction to DEC A
+        ld    (envelopeInterrupt.l4 + 1), hl             ; assume .l5 = .l4 + 2
+        jp    envelopeInterrupt.l8
+envelopeInterrupt.l24:   cpl
+        ld    l, a
+        ld    h,#0x3c                   ; set direction to INC A
+        ld    (envelopeInterrupt.l4 + 1), hl
+        jp    envelopeInterrupt.l8
+
+  .endif
+; -----------------------------------------------------------------------------
+
+ayVolumeTable:
+        .db   0,  1,  2,  3,  4,  5,  6,  9
+        .db  12, 17, 22, 28, 36, 44, 53, 63
+
+ayRegisterMaskTable:
+        .db  #0xff,#0x0f,#0xff,#0x0f,#0xff,#0x0f,#0x1f,#0xff
+        .db  #0x1f,#0x1f,#0x1f,#0xff,#0xff,#0x0f,#0xff,#0xff
+
+ayRegisters:
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+
+ayRegWriteTable:
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l7 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l5 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l9 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l10 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l11 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l15 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+
+
+    .ifeq NO_ENVELOPE_IRQ
+
+envelopeModeTable:
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+
+envelopeEnableTable:
+        .db  <(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l11 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l14 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l13 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l16 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l15 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l18 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l17 - envelopeInterrupt.l11)
+
+    .endif
+
+setChannelAmplitude:
+        cp    #0x10
+        jr    c, setChannelAmplitude.l1
+    .ifeq NO_ENVELOPE_IRQ
+        res   3, b
+        ld    a, (envelopeInterrupt.l4 + 1)
+    .else
+        xor   a
+    .endif
+setChannelAmplitude.l1:                                    ; HL = ayRegWriteTable + (8 + channel)
+        add     a,#<ayVolumeTable
+        ld      l,a
+        adc     a,#>ayVolumeTable
+        sub     l
+        ld      h,a
+    .ifne ENABLE_STEREO
+        bit     0,c                     ; Z = 0: channel B, Z = 1: channel A, C
+    .endif
+        ld    a, (hl)
+    .ifne ENABLE_STEREO 
+        jr    z, setChannelAmplitude.l2
+        or    a
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (c), a
+        set   2, c
+setChannelAmplitude.l2:    out   (c), a
+    .ifeq NO_ENVELOPE_IRQ
+setChannelAmplitude.l3:    ld      a,#0x00                   ; *
+        ld      c,a
+        or      b
+        cp      #0x08
+        jr      c,setChannelAmplitude.l4
+        xor     b
+setChannelAmplitude.l4:    cp      c
+        jr      z, setChannelAmplitude.l5                    ; envelope enable bit has not changed ?
+        ld      (setChannelAmplitude.l3+1), a
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeEnableTable
+        add     hl,bc
+        ld      a,(hl)
+        ld      (envelopeInterrupt.l10+1),a
+    .endif
+setChannelAmplitude.l5:    pop   bc
+;        pop   af
+        ret
+
+setChannelAFreq:
+        ld    c, #0xa0 + (ayDaveChnA * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters)
+    .if toneAndNoiseModeAtone
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+        and   #0x04
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeAnoise
+        bit   3, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeAtnns
+        and   #0x09
+        jr    z, setToneGenAAsNoise     ; tone + noise generator enabled ?
+        cp    #0x08
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnA * 2)), a
+        out   (#0xa1 + (ayDaveChnA * 2)), a
+        ret
+
+setChannelBFreq:
+        ld    c, #0xa0 + (ayDaveChnB * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 2)
+    .if toneAndNoiseModeBtone
+        bit   1, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x10
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeBnoise
+        bit   4, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x02
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeBtnns
+        and   #0x12
+        jr    z, setToneGenBAsNoise     ; tone + noise generator enabled ?
+        cp    #0x10
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnB * 2)), a
+        out   (#0xa1 + (ayDaveChnB * 2)), a
+        ret
+
+setChannelCFreq:
+        ld    c, #0xa0 + (ayDaveChnC * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 4)
+    .if toneAndNoiseModeCtone
+        bit   2, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x20
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeCnoise
+        bit   5, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x04
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeCtnns
+        and   #0x24
+        jr    z, setToneGenCAsNoise     ; tone + noise generator enabled ?
+        cp    #0x20
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnC * 2)), a
+        out   (#0xa1 + (ayDaveChnC * 2)), a
+        ret
+
+    .if toneAndNoiseModeAtnns
+setToneGenAAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeBtnns
+setToneGenBAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeCtnns
+setToneGenCAsNoise:
+        ld    a,#0x30
+        .db   #0xfe                      ; = CP nn
+    .endif
+
+setToneGenFrequency:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        xor   a
+    .endif
+
+setToneGenFrequency_:
+        add   hl, hl
+        dec   hl
+        bit   4, h
+        jr    nz, setToneGenFrequency_.l2                   ; overflow ?
+setToneGenFrequency_.l1:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        or    h                         ; non-zero for tone + noise
+    .endif
+        out   (c), l
+        inc   c
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        out   (c), a
+    .else
+        out   (c), h
+    .endif
+        ret
+setToneGenFrequency_.l2:    ld    l,#0x01
+        inc   h
+        jr    z, setToneGenFrequency_.l1
+        ld    hl,#0x0fff
+        jp    setToneGenFrequency_.l1
+
+    .if (toneAndNoiseModeAtnns * toneAndNoiseModeAnoise)
+setToneGenAAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeBtnns * toneAndNoiseModeBnoise)
+setToneGenBAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeCtnns * toneAndNoiseModeCnoise)
+setToneGenCAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+setNoiseGenFreq:
+        ld    h,#0x30
+
+setNoiseGenFreq_:
+        ld    a, (ayRegisters + 6)
+        add   a, a
+        add   a, a
+        jr    nz, setNoiseGenFreq_.l1
+        ld    a,#0x04
+setNoiseGenFreq_.l1:    dec   a
+        out   (c), a
+        inc   c
+        out   (c), h
+        ret
+; -----------------------------------------------------------------------------
+; reset AY-3-8912 emulation
+
+ayReset:
+;        di
+        ld    hl, #ayRegisters - 1
+        ld    bc, #0x10af
+        xor   a
+ayReset.l1:    inc   hl
+        out   (c), a
+        ld    (hl), a
+        dec   c
+        djnz  ayReset.l1
+        res   3, l                      ; register 7
+        ld    (hl), #0x3f
+    .ifeq NO_ENVELOPE_IRQ
+        ld    (envelopeInterrupt.l4 + 1), a
+        ld    a, #0x18                    ; = JR +nn
+        ld    (envelopeInterrupt.l2), a
+        ld    hl, #MIN_ENV_FREQVAL
+        ld    (envelopeInterrupt.l3 + 1), hl
+        ld    a, #<(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        ld    (envelopeInterrupt.l10 + 1), a
+        xor     a
+        ld    (setChannelAmplitude.l3 + 1), a
+    .endif
+        ld    a, #0x04
+        out   (#0xbf), a
+        ld    c, b
+        call  ayReset.l2
+        ld    l, b
+        call  ayReset.l2                       ; L = 1 kHz interrupts per video frame
+        ld    a, #25
+        cp    l
+        ld    a, #0x03
+        rla
+        rla
+        out   (#0xbf), a                 ; Z80 <= 5 MHz: 04h, > 5 MHz: 06h
+        ld    a, #0x10                    ; use 17-bit noise generator
+        out   (#0xa6), a
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, #0x33
+    .else
+        ld    a, #0x30
+    .endif
+        out   (#0xb4), a                 ; enable 1 kHz and video interrupts
+        ret
+ayReset.l2:    in    a, (#0xb4)
+        and   #0x11
+        or    c
+        rlca
+        and   #0x66
+        ld    c, a                      ; -ON--ON-
+        rlca                            ; ON--ON--
+        xor   c                         ; OXN-OXN-
+        bit   2, a
+        jr    z, ayReset.l3
+        inc   l                         ; 1 kHz interrupt
+ayReset.l3:    cp    #0xc0
+        jr    c, ayReset.l2                    ; not 50 Hz interrupt ?
+        ret
+
+;; read AY-3-8912 register A, returning the value in A
+;
+;ayRegisterRead:
+;        and   0fh
+;        or    <ayRegisters
+;        ld    l, a
+;        ld    h, >ayRegisters
+;        ld    a, (hl)
+;        or    a
+;        ret
+
+; write C to AY-3-8912 register A
+; NOTE: interrupts may be enabled on return
+ayRegisterWriteDE:
+        ld      a,(de)
+        inc     de
+
+ayRegisterWrite:
+        ld      b,#0x00
+        ld      hl,#ayRegisterMaskTable
+        add     hl,bc
+        inc     c
+        and     (hl)
+        push    bc
+        ld      c,#0x10
+        add     hl,bc                   ;ayRegisters
+        cp      (hl)
+        jr      z,ayRegisterWrite.l2                   ; register not changed ?
+        ld      (hl),a
+        add     hl,bc                   ;ayRegWriteTable
+        ld      a,(hl)
+        ld      (ayRegisterWrite.l1+1),a
+ayRegisterWrite.l1:    jr      ayRegisterWrite.l8                     ; *
+ayRegisterWrite.l2:    
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, l
+        xor   #<(ayRegisters + 13)
+        jr    z, ayRegisterWrite.l16                   ; envelope restart ?
+    .endif
+        pop     bc
+;        pop   af
+        ret
+ayRegisterWrite.l3:    call  setChannelAFreq           ; tone generator A frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l4:    call  setChannelBFreq           ; tone generator B frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l5:    call  setChannelAFreq           ; mixer
+        call  setChannelBFreq
+ayRegisterWrite.l6:    call  setChannelCFreq           ; tone generator C frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l7:    ld    a, (ayRegisters + 7)      ; noise generator frequency
+    .if toneAndNoiseModeAnoise
+        ld    b, a
+        and   #0x08
+    .else
+        xor   #0x07
+        ld    b, a
+        and   #0x09
+    .endif
+        call  z, setChannelAFreq
+    .if toneAndNoiseModeBnoise
+        bit   4, b
+    .else
+        ld    a, b
+        and   #0x12
+    .endif
+        call  z, setChannelBFreq
+    .if toneAndNoiseModeCnoise
+        bit   5, b
+    .else
+        ld    a, b
+        and   #0x24
+    .endif
+        call  z, setChannelCFreq
+ayRegisterWrite.l8:    pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l9:    ld    a, (ayRegisters + 8)      ; channel A amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x09a8 + ayDaveChnA
+    .else
+        ld    c,#0xa8 + ayDaveChnA
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l10:   ld    a, (ayRegisters + 9)      ; channel B amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0aa8 + ayDaveChnB
+    .else
+        ld    c,#0xa8 + ayDaveChnB
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l11:   ld    a, (ayRegisters + 10)     ; channel C amplitude / envelope enable
+    .ifeq ENABLE_STEREO
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0ca8 + ayDaveChnC
+      .else
+        ld    c,#0xa8 + ayDaveChnC
+      .endif
+    .else
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0cac + ayDaveChnC
+      .else
+        ld    c,#0xac + ayDaveChnC
+      .endif
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l12:
+    .ifeq NO_ENVELOPE_IRQ
+        ld    hl, (ayRegisters + 11)    ; envelope generator frequency
+        ld    a, h
+        or    a
+        jr    nz, ayRegisterWrite.l13
+        ld    a, #MIN_ENV_FREQVAL
+        cp    l
+        jr    c, ayRegisterWrite.l13
+        ld    l, a                      ; limit envelope frequency
+ayRegisterWrite.l13:   ld    (envelopeInterrupt.l3 + 1), hl
+        pop   bc
+;        pop   af
+        ret
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+ayRegisterWrite.l15:                                   ; envelope generator mode / restart
+    .ifeq NO_ENVELOPE_IRQ
+ayRegisterWrite.l16:   ld      hl,(envelopeInterrupt.l3+1)
+        ld      (envelopeInterrupt.l1+1),hl
+        ld      a,#0x38                     ; = JR C, +nn
+        ld      (envelopeInterrupt.l2),a    ; enable envelope
+        ld      a,(ayRegisters+13)
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeModeTable
+        add     hl,bc
+        and     #0x04
+        ld    a, (hl)
+        ld    (envelopeInterrupt.l6 + 1), a
+        ld    hl,#0x3c00                    ; INC A, state = 0
+        ld    a, l
+        jr    nz, ayRegisterWrite.l17                      ; attack ?
+        ld    hl,#0x3d0f                    ; DEC A, state = 15
+        ld    a,#0x3f
+ayRegisterWrite.l17:   ld    (envelopeInterrupt.l4 + 1), hl    ; assume eInt.l5 = eInt.l4 + 2
+        call  ayRegisterWrite.l18
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l18:   call  envelopeInterrupt.l10     ; NOTE: this will pop return address
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+
+ .endif
+; =============================================================================
+
+
+   ;PLY_UseEnterprise_End
+
 ;There are two holes in the list, because the Volume registers are set relatively to 
 ;the Frequency of the same Channel (+7, always). Also, the Reg7 is passed as a register, so is not kept in the memory.
 PLY_PSGRegistersArray:
@@ -1728,7 +2476,11 @@
    ld  (PLY_Track1_Instrument + 1), hl
    ld  (PLY_Track2_Instrument + 1), hl
    ld  (PLY_Track3_Instrument + 1), hl
-   ret
+   .if HARDWARE_ENTERPRISE
+        jp     ayReset
+   .else
+        ret
+   .endif
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -1786,8 +2538,8 @@
       push af
       push bc
    .endif
-   push ix
-   push iy
+;   push ix
+;   push iy
 
    ld  hl, #PLY_PSGReg8
    ld  bc, #0x0500
@@ -2320,4 +3072,4 @@
    PLY_DisableInterruptions_Set_Opcode:
       ld  (PLY_RestoreInterruption), a
       ret
-.endif
+.endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg.s cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg.s
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg.s	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg.s	2025-01-11 16:57:38
@@ -0,0 +1,5571 @@
+;       Arkos Tracker 2 player "generic" player.
+;       By Targhan/Arkos.
+;       Psg optimization trick on CPC by Madram/Overlanders.
+;
+;       This compiles with RASM. Check the compatibility page on the Arkos Tracker 2 website, it contains a source converter to any Z80 assembler!
+;
+;       The player uses the stack for optimizations. Make sure the interruptions are disabled before it is called.
+;       The stack pointer is saved at the beginning and restored at the end.
+;
+;       Target hardware:
+;       ---------------
+;       This code can target Amstrad CPC, MSX, Spectrum and Pentagon. By default, it targets Amstrad CPC.
+;       Simply use one of the follow line (BEFORE this player):
+;       PLY_AKG_HARDWARE_CPC = 1
+;       PLY_AKG_HARDWARE_MSX = 1
+;       PLY_AKG_HARDWARE_SPECTRUM = 1
+;       PLY_AKG_HARDWARE_PENTAGON = 1
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+;
+;       ROM
+;       ----------------------
+;       To use a ROM player (no automodification, use of a small buffer to put in RAM):
+;       PLY_AKG_ROM = 1
+;       PLY_AKG_ROM_Buffer = #4000 (or wherever).
+;       This makes the player a bit slower and slightly bigger.
+;       The buffer is PLY_AKG_ROM_BufferSize long (=250 max). You can hardcode this value, because it is calculated, so it won't be accessible before this player is assembled.
+;       This value decreases when you use player configuration, but increases if you use sound effects.
+;
+;       Optimizations:
+;       --------------
+;       - Use the Player Configuration of Arkos Tracker 2 to generate a configuration file to be included at the beginning of this player.
+;         It will disable useless features according to your songs, saving for memory and CPU! Check the manual for more details, or more simply the testers.
+;       - Set PLY_AKG_USE_HOOKS to 0 to remove the three hooks just below to save 9 bytes (yay!).
+;       - Set PLY_AKG_STOP_SOUNDS to 0 if you don't intent to stop the music via the PLY_AKG_Stop method.
+;       - If you play your song "one shot" (i.e. without restarting it again), you can set the PLY_AKG_FULL_INIT_CODE to 0, some
+;         initialization code will not be assembled.
+
+;       Sound effects:
+;       --------------
+;       Sound effects are disabled by default. Declare PLY_AKG_MANAGE_SOUND_EFFECTS to enable it:
+;       PLY_AKG_MANAGE_SOUND_EFFECTS = 1
+;       Check the sound effect tester to see how it enables it.
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+
+;       Additional note:
+;       - There can be a slightly difference when using volume in/out effects compared to the PC side, because the volume management is
+;         different. This means there can be a difference of 1 at certain frames. As it shouldn't be a bother, I let it this way.
+;         This allows the Z80 code to be faster and simpler.
+;
+;       -------------------------------------------------------
+
+; _main::
+.module cpct_audio
+        .include "../../CPCteleraHW.src"
+        .include "arkostrackerAkg_var.src"
+
+PLY_AKG_Start:
+ 
+.equ PLY_AKG_Rom ,     0
+;A nice trick to manage the offset using the same instructions, according to the player (ROM or not).
+       .if PLY_AKG_Rom
+.equ PLY_AKG_Offset1b , 0
+.equ PLY_AKG_Offset2b , 0         ;Used for instructions such as ld iyh,xx
+       .else
+.equ PLY_AKG_Offset1b , 1
+.equ PLY_AKG_Offset2b , 2
+       .endif
+
+       .ifeq PLY_AKG_Rom
+.equ PLY_AKG_OPCODE_OR_A , #0xb7                        ;Opcode for "or a".
+.equ PLY_AKG_OPCODE_SCF , #0x37                         ;Opcode for "scf".
+       .else
+        ;Another trick for the ROM player. The original opcodes are converted to number, which will be multiplied by 2, provoking a carry or not.
+.equ PLY_AKG_OPCODE_OR_A , 0                          ;0 * 2 = 0, no carry.
+.equ PLY_AKG_OPCODE_SCF , #0xff                         ;255 * 2 = carry.
+.equ PLY_AKG_OPCODE_JP , #0xc3
+       .endif
+
+.equ PLY_AKG_OPCODE_ADD_HL_BC_LSB , #0x09               ;Opcode for "add hl,bc", LSB.
+.equ PLY_AKG_OPCODE_ADD_HL_BC_MSB , #0x00               ;Opcode for "add hl,bc", MSB (fake, it is only 8 bits).
+.equ PLY_AKG_OPCODE_SBC_HL_BC_LSB , #0x42               ;Opcode for "sbc hl,bc", LSB.
+.equ PLY_AKG_OPCODE_SBC_HL_BC_MSB , #0xed               ;Opcode for "sbc hl,bc", MSB.
+.equ PLY_AKG_OPCODE_INC_HL , #0x23                      ;Opcode for "inc hl".
+.equ PLY_AKG_OPCODE_DEC_HL , #0x2b                      ;Opcode for "dec hl".
+.equ PLY_AKG_OPCODE_ADD_A_IMMEDIATE , #0xc6             ;Opcode for "add a,x".
+.equ PLY_AKG_OPCODE_SUB_IMMEDIATE , #0xd6               ;Opcode for "sub x".
+        
+        ;Hooks for external calls. Can be removed if not needed.
+       .if PLY_AKG_USE_HOOKS
+                jp PLY_AKG_Init                         ;PLY_AKG_Start + 0.
+                jp PLY_AKG_Play                         ;PLY_AKG_Start + 3.
+               .if PLY_AKG_STOP_SOUNDS
+                        jp PLY_AKG_Stop                         ;PLY_AKG_Start + 6.
+               .endif ;PLY_AKG_STOP_SOUNDS
+       .endif ;PLY_AKG_USE_HOOKS
+
+        ;Includes the sound effects player, if wanted. Important to do it as soon as possible, so that
+        ;its code can react to the Player Configuration and possibly alter it.
+       .if PLY_AKG_MANAGE_SOUND_EFFECTS
+               .include "arkostrackerAkg_SoundEffects.src"
+       .endif ;PLY_AKG_MANAGE_SOUND_EFFECTS
+        ;[[INSERT_SOUND_EFFECT_SOURCE]]                 ;A tag for test units. Don't touch or you're dead.
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKG_musicInit
+;;
+;;    Sets up a music into Arkos Tracker Player to be played later on with
+;; <cpct_akpAKG_musicPlay>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKG_musicInit> (void* *songdata*, song number)
+;;
+;; Input Parameters (2 bytes):
+;;    (2B HL) songdata - Pointer to the start of the array containing song's data in AKS binary format
+;;    (1B A) song number
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKG_musicInit_asm
+;;
+;; Parameter Restrictions:
+;;    * *songdata* must be an array containing dong's data in AKS binary format.
+;; Take into account that AKS binary format enforces a concrete start location in
+;; memory. Therefore, song must have been created in Arkos Tracker and exported 
+;; to the same memory location that *songdata* points to. If you fail to 
+;; locate the song at the same memory location it was exported for in Arkos 
+;; Tracker, unexpected results will happen (Typically, noise will be played but,
+;; occasionally your program may hang or crash).
+;;
+;; Known limitations:
+;;    * *songdata* must be the same memory address that the one given to Arkos
+;; Tracker when exporting song's binary. Arkos Tracker songs are created to
+;; be at a concrete memory location, due to optimization constraints. Therefore,
+;; this must be taken into account. If you wanted to change the memory location
+;; of the song, you should first open the song into Arkos Tracker and export
+;; it again with the new desired memory location.
+;;    * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function should be called fist to initialize the song that is to be 
+;; played. The function reads the song header and sets up the player to start 
+;; playing it. Once this process is done, <cpct_akp_musicPlay> should be called
+;; at the required frequency to continuously play the song.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    ? bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpAKG_musicInit::
+   ld   hl, #2    ;; [10] Retrieve parameters from stack
+   add  hl, sp    ;; [11]
+   ld    e, (hl)  ;; [ 7] DE = Pointer to the start of music
+   inc  hl        ;; [ 6]
+   ld    d, (hl)  ;; [ 7]
+   inc  hl
+   ld    a, (hl)
+   ex   de,hl
+cpct_akpAKG_musicInit_asm::   ;; Entry point for assembly calls using registers for parameter passing 
+
+;Initializes the player.
+;IN:    HL = music address.
+;       A = subsong index (>=0).
+PLY_AKG_InitDisarkGenerateExternalLabel:
+PLY_AKG_Init:
+        
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        ;Skips the tag.
+        ld de,#0x0004
+        add hl,de
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld de,#PLY_AKG_ArpeggiosTable + PLY_AKG_Offset1b
+        ldi
+        ldi
+                               .else
+                inc hl
+                inc hl
+                               .endif
+                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld de,#PLY_AKG_PitchesTable + PLY_AKG_Offset1b
+        ldi
+        ldi
+                               .else
+                inc hl
+                inc hl
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+                       .else
+                ;No effects. Skips the tag and the arp/pitch table.
+        ld de,#0x0004 + 2 + 2
+        add hl,de
+                       .endif ;PLY_CFG_UseEffects
+        ld de,#PLY_AKG_InstrumentsTable + PLY_AKG_Offset1b
+        ldi
+        ldi
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        ld c,(hl)
+        inc hl
+        ld b,(hl)
+        inc hl
+        ld (PLY_AKG_Channel_ReadEffects_EffectBlocks1 + PLY_AKG_Offset1b),bc
+                               .ifeq PLY_AKG_Rom
+        ;Not used in ROM, the same value is used.
+        ld (PLY_AKG_Channel_ReadEffects_EffectBlocks2 + PLY_AKG_Offset1b),bc
+                               .endif
+                       .else
+                ;No effects. Skips the effect block table.
+                inc hl
+                inc hl
+                       .endif ;PLY_CFG_UseEffects
+
+        
+        ;We have reached the Subsong addresses. Which one to use?
+        add a,a
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ;HL points on the Subsong metadata.
+        ld de,#0x0005         ;Skips the replay frequency, digichannel, psg count, loop ^art index, end index.
+        add hl,de
+        ld de,#PLY_AKG_CurrentSpeed + PLY_AKG_Offset1b       ;Reads the initial speed (>0).
+        ldi
+        ld de,#PLY_AKG_BaseNoteIndex + PLY_AKG_Offset1b      ;Reads the base note of the note that is considered "optimized", contrary to "escaped".
+        ldi
+        ld (PLY_AKG_ReadLinker_PtLinker + PLY_AKG_Offset1b),hl
+
+        ;Initializes values. You can remove this part if you don't stop/restart your song.
+       .if PLY_AKG_FULL_INIT_CODE
+                ld hl,#PLY_AKG_InitTable0
+                ld bc,#((PLY_AKG_InitTable0_End - PLY_AKG_InitTable0) / 2 + 1) * 256 + 0
+                call PLY_AKG_Init_ReadWordsAndFill
+                inc c
+                ld hl,#PLY_AKG_InitTable1
+                ld b,#(PLY_AKG_InitTable1_End - PLY_AKG_InitTable1) / 2 + 1
+                call PLY_AKG_Init_ReadWordsAndFill
+                ld hl,#PLY_AKG_InitTableOrA
+                ld bc,#((PLY_AKG_InitTableOrA_End - PLY_AKG_InitTableOrA) / 2 + 1) * 256 + PLY_AKG_OPCODE_OR_A
+                call PLY_AKG_Init_ReadWordsAndFill
+                
+               .if PLY_AKG_Rom
+                        ;The ROM version requires a bit more of setup.        
+                        ld hl,#PLY_AKG_InitTableJp
+                        ld bc,#((PLY_AKG_InitTableJp_End - PLY_AKG_InitTableJp) / 2 + 1) * 256 + PLY_AKG_OPCODE_JP
+                        call PLY_AKG_Init_ReadWordsAndFill
+               .endif
+                
+                       .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+                ld a,#0xff
+                ld (PLY_AKG_PSGReg13_OldValue + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseRetrig
+       .endif
+
+        ;Stores the address to the empty instrument *data* (header skipped).
+        ld hl,(PLY_AKG_InstrumentsTable + PLY_AKG_Offset1b)
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        ex de,hl
+        inc hl                  ;Skips the header.
+        ld (PLY_AKG_EmptyInstrumentDataPt + PLY_AKG_Offset1b),hl
+        ;Sets all the instrument to "empty".
+        ld (PLY_AKG_Channel1_PtInstrument + PLY_AKG_Offset1b),hl
+        ld (PLY_AKG_Channel2_PtInstrument + PLY_AKG_Offset1b),hl
+        ld (PLY_AKG_Channel3_PtInstrument + PLY_AKG_Offset1b),hl
+        
+        ;The ROM version requires a bit more of setup.        
+       .if PLY_AKG_Rom
+               .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide            ;CONFIG SPECIFIC
+                        xor a
+                                ;In the non-ROM code, the MSB is always 0, the LSB is updated. The MSB must be reset for ROM version.
+                                ld (PLY_AKG_Channel1_PitchTrack + 1),a
+                        
+                                ld hl,#PLY_AKG_Channel1_PitchTrackIntegerAddOrSubReturn
+                                ld (PLY_AKG_Channel1_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress + 1),hl
+                                ld hl,#PLY_AKG_Channel1_PitchTrackAddOrSbc_16bitsReturn
+                                ld (PLY_AKG_Channel1_PitchTrackAfterAddOrSbcJumpInstrAndAddress + 1),hl
+                                
+                                ld hl,#PLY_AKG_Channel1_PitchTrackDecimalInstrAndValueReturnAfterJp
+                                ld (PLY_AKG_Channel1_PitchTrackDecimalInstrAndValueReturnJp + 1),hl
+                                ;In the non-ROM code, the MSB is always 0, the LSB is updated. The MSB must be reset for ROM version.
+                                ld (PLY_AKG_Channel2_PitchTrack + 1),a
+                        
+                                ld hl,#PLY_AKG_Channel2_PitchTrackIntegerAddOrSubReturn
+                                ld (PLY_AKG_Channel2_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress + 1),hl
+                                ld hl,#PLY_AKG_Channel2_PitchTrackAddOrSbc_16bitsReturn
+                                ld (PLY_AKG_Channel2_PitchTrackAfterAddOrSbcJumpInstrAndAddress + 1),hl
+                                
+                                ld hl,#PLY_AKG_Channel2_PitchTrackDecimalInstrAndValueReturnAfterJp
+                                ld (PLY_AKG_Channel2_PitchTrackDecimalInstrAndValueReturnJp + 1),hl
+                                ;In the non-ROM code, the MSB is always 0, the LSB is updated. The MSB must be reset for ROM version.
+                                ld (PLY_AKG_Channel3_PitchTrack + 1),a
+                        
+                                ld hl,#PLY_AKG_Channel3_PitchTrackIntegerAddOrSubReturn
+                                ld (PLY_AKG_Channel3_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress + 1),hl
+                                ld hl,#PLY_AKG_Channel3_PitchTrackAddOrSbc_16bitsReturn
+                                ld (PLY_AKG_Channel3_PitchTrackAfterAddOrSbcJumpInstrAndAddress + 1),hl
+                                
+                                ld hl,#PLY_AKG_Channel3_PitchTrackDecimalInstrAndValueReturnAfterJp
+                                ld (PLY_AKG_Channel3_PitchTrackDecimalInstrAndValueReturnJp + 1),hl
+               .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+       .endif
+        
+        ;If sound effects, clears the SFX state.
+       .if PLY_AKG_MANAGE_SOUND_EFFECTS
+                ld hl,#0x0000
+                ld (PLY_AKG_Channel1_SoundEffectData),hl
+                ld (PLY_AKG_Channel2_SoundEffectData),hl
+                ld (PLY_AKG_Channel3_SoundEffectData),hl
+       .endif ;PLY_AKG_MANAGE_SOUND_EFFECTS
+        
+   .if HARDWARE_ENTERPRISE
+        jp     ayReset
+   .else
+        ret
+   .endif
+
+
+       .if PLY_AKG_FULL_INIT_CODE
+;Fills all the read addresses with a byte.
+;IN:    HL = table where the addresses are.
+;       B = how many items in the table + 1.
+;       C = byte to fill.
+PLY_AKG_Init_ReadWordsAndFill_Loop:
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        inc hl
+        ld a,c
+        ld (de),a
+PLY_AKG_Init_ReadWordsAndFill:
+        djnz PLY_AKG_Init_ReadWordsAndFill_Loop
+        ret
+
+;Table initializing some data with 0.
+PLY_AKG_InitTable0:
+       .dw PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1  ;PLY_AKG_Offset2b must NOT be used here.
+       .dw PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1
+       .dw PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+       .dw PLY_AKG_Channel1_Pitch + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel1_Pitch + PLY_AKG_Offset1b + 1
+       .dw PLY_AKG_Channel2_Pitch + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel2_Pitch + PLY_AKG_Offset1b + 1
+       .dw PLY_AKG_Channel3_Pitch + PLY_AKG_Offset1b
+       .dw PLY_AKG_Channel3_Pitch + PLY_AKG_Offset1b + 1
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+                       .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+       .dw PLY_AKG_Retrig + 1
+                       .endif ;PLY_CFG_UseRetrig
+PLY_AKG_InitTable0_End:
+
+PLY_AKG_InitTable1:
+       .dw PLY_AKG_PatternDecreasingHeight + PLY_AKG_Offset1b
+       .dw PLY_AKG_TickDecreasingCounter + PLY_AKG_Offset1b
+PLY_AKG_InitTable1_End:
+
+PLY_AKG_InitTableOrA:
+                       .if PLY_AKG_UseEffect_VolumeSlide             ;CONFIG SPECIFIC
+       .dw PLY_AKG_Channel1_IsVolumeSlide
+       .dw PLY_AKG_Channel2_IsVolumeSlide
+       .dw PLY_AKG_Channel3_IsVolumeSlide
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .dw PLY_AKG_Channel1_IsArpeggioTable
+       .dw PLY_AKG_Channel2_IsArpeggioTable
+       .dw PLY_AKG_Channel3_IsArpeggioTable
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+       .dw PLY_AKG_Channel1_IsPitchTable
+       .dw PLY_AKG_Channel2_IsPitchTable
+       .dw PLY_AKG_Channel3_IsPitchTable
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+       .dw PLY_AKG_Channel1_IsPitch
+       .dw PLY_AKG_Channel2_IsPitch
+       .dw PLY_AKG_Channel3_IsPitch
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+PLY_AKG_InitTableOrA_End:
+       .endif           ;PLY_AKG_FULL_INIT_CODE
+
+       .if PLY_AKG_Rom
+PLY_AKG_InitTableJp:
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+       .dw PLY_AKG_Channel1_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress
+       .dw PLY_AKG_Channel2_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress
+       .dw PLY_AKG_Channel3_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress
+       .dw PLY_AKG_Channel1_PitchTrackAfterAddOrSbcJumpInstrAndAddress
+       .dw PLY_AKG_Channel2_PitchTrackAfterAddOrSbcJumpInstrAndAddress
+       .dw PLY_AKG_Channel3_PitchTrackAfterAddOrSbcJumpInstrAndAddress
+       .dw PLY_AKG_Channel1_PitchTrackDecimalInstrAndValueReturnJp
+       .dw PLY_AKG_Channel2_PitchTrackDecimalInstrAndValueReturnJp
+       .dw PLY_AKG_Channel3_PitchTrackDecimalInstrAndValueReturnJp
+       .endif
+        
+       .if PLY_CFG_UseEffects
+       .dw PLY_AKG_Channel_ReadEffects_EndJumpInstrAndAddress
+       .endif
+       .dw PLY_AKG_TempPlayInstrumentJumpInstrAndAddress
+PLY_AKG_InitTableJp_End:
+       .endif
+
+       .if PLY_AKG_STOP_SOUNDS
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKG_stop
+;;
+;;    Stops playing musing and sound effects on all 3 channels.
+;;
+;; C Definition:
+;;    void <cpct_akpAKG_stop> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKG_stop_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function stops the music and sound effects playing in the 3 channels. 
+;; It can be later continued again calling <cpct_akp_musicPlay>. Please, take
+;; into account that sound effects cannot be played while music is stopped, as
+;; code for sound effects and music play is integrated.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;Stop the music, cut the channels.
+_cpct_akpAKG_stop::
+cpct_akpAKG_stop_asm::  ;; Entry point for assembly calls   
+;Stops the music. This code can be removed if you don't intend to stop it!
+PLY_AKG_StopDisarkGenerateExternalLabel:
+PLY_AKG_Stop:
+        ld (PLY_AKG_SaveSP + PLY_AKG_Offset1b),sp              ;Only useful because the PLY_AKG_SendPSGRegisters restores it at the end.
+        
+        ;All the volumes to 0, all sound/noise channels stopped.
+        xor a
+        ld l,a
+        ld h,a
+        ld (PLY_AKG_PSGReg8),a
+        ld (PLY_AKG_PSGReg9_10_Instr + PLY_AKG_Offset1b),hl
+       .if PLY_AKG_HARDWARE_MSX
+                ld a,#0b10111111          ;On MSX, bit 7 must be 1, bit 6 0.
+       .else
+                ld a,#0b00111111          ;On CPC, bit 6 must be 0. Other platforms don't care.
+       .endif
+        jp PLY_AKG_SendPSGRegisters
+       .endif ;PLY_AKG_STOP_SOUNDS
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKG_musicPlay
+;;
+;;    Plays next music cycle of the present song with Arkos Tracker Player. Song 
+;; has had to be previously established with <cpct_akp_musicInit>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKG_musicPlay> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKG_musicPlay_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function is to be called to start and continue playing the presently 
+;; selected song with Arkos Tracker Player. Depending on the frequency at which 
+;; the song were created, this function should be called 12, 25, 50, 100, 200 
+;; or 300 times per second. 
+;;
+;;    Each time you call the function, it plays 1/frequency seconds. This means
+;; that you have to manually synchronize your calls to this function to have
+;; a stable music playing. If you call too fast or too slow you will either 
+;; interrupt sound or have sound valleys. Therefore, you are responsible for
+;; calling this function with the most accurate timing possible, to get best 
+;; sound results.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xxxx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpAKG_musicPlay::
+cpct_akpAKG_musicPlay_asm::   ;; Entry point for assembly calls   
+  .if HARDWARE_ENTERPRISE
+   .ifeq NO_ENVELOPE_IRQ
+    .if ENABLE_1000HZ_IRQ
+        in      a,(#0xb4)
+        and     #0x02
+        jp      nz,envelopeInterrupt
+        ld      a,#0x31
+        out     (#0xb4),a
+    .else
+     .if ENABLE_300HZ_IRQ
+cntr    ld      a,#0x06
+        dec     a
+        ld      (cntr+1),a
+        jp      nz,envelopeInterrupt
+        ld      a,#0x06
+        ld      (cntr+1),a
+     .else
+        call    envelopeInterrupt
+     .endif
+    .endif
+   .endif
+  .endif
+
+;Plays one frame of the subsong.
+PLY_AKG_PlayDisarkGenerateExternalLabel:
+PLY_AKG_Play:
+        ld (PLY_AKG_SaveSP + PLY_AKG_Offset1b),sp
+
+                       .if PLY_CFG_UseEventTracks            ;CONFIG SPECIFIC
+        xor a
+        ld (PLY_AKG_Event),a
+                       .endif ;PLY_CFG_UseEventTracks
+
+        ;Decreases the tick counter. If 0 is reached, a new line must be read.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_TickDecreasingCounter: ld a,#0x01
+       .else
+        ld a,(PLY_AKG_TickDecreasingCounter)
+       .endif
+        dec a
+        jp nz,PLY_AKG_SetSpeedBeforePlayStreams                 ;Jumps if there is no new line: continues playing the sound stream.
+
+        ;New line! Is the Pattern ended? Not as long as there are lines to read.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PatternDecreasingHeight: ld a,#0x01
+       .else
+        ld a,(PLY_AKG_PatternDecreasingHeight)
+       .endif
+        dec a
+        jr nz,PLY_AKG_SetCurrentLineBeforeReadLine  ;Jumps if the pattern isn't ended.
+
+        ;New pattern!
+        ;Reads the Linker. This is called at the start of the song, or at the end of every position.
+PLY_AKG_ReadLinker:
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_ReadLinker_PtLinker: ld sp,#0x0000
+       .else
+        ld sp,(PLY_AKG_ReadLinker_PtLinker)
+       .endif
+        ;Reads the address of each Track.
+        pop hl
+        ld a,l
+        or h
+        jr nz,PLY_AKG_ReadLinker_NoLoop         ;Reached the end of the song?
+        ;End of the song.
+        pop hl          ;HL is the loop address.
+        ld sp,hl
+        pop hl          ;Reads once again the address of Track 1, in the pattern looped to.
+PLY_AKG_ReadLinker_NoLoop:
+        ld (PLY_AKG_Channel1_PtTrack + PLY_AKG_Offset1b),hl
+        pop hl
+        ld (PLY_AKG_Channel2_PtTrack + PLY_AKG_Offset1b),hl
+        pop hl
+        ld (PLY_AKG_Channel3_PtTrack + PLY_AKG_Offset1b),hl
+        ;Reads the address of the LinkerBlock.
+        pop hl
+        ld (PLY_AKG_ReadLinker_PtLinker + PLY_AKG_Offset1b),sp
+        ld sp,hl
+
+        ;Reads the LinkerBlock. SP = LinkerBlock.
+        ;Reads the height and transposition1.
+        pop hl
+        ld c,l                                ;Stores the pattern height, used below.
+                       .if PLY_CFG_UseTranspositions            ;CONFIG SPECIFIC
+        ld a,h
+        ld (PLY_AKG_Channel1_Transposition + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseTranspositions
+        ;Reads the transposition2 and 3.
+                       .if PLY_AKG_UseSpecialTracks                  ;CONFIG SPECIFIC
+                               .ifeq PLY_CFG_UseTranspositions            ;CONFIG SPECIFIC
+                                ;Transpositions not used? We could stop here. BUT the SpecialTracks, if present, must access their data after.
+                                ;So in this case, the transpositions must be skipped.
+                                pop hl
+                               .endif ;PLY_CFG_UseTranspositions
+                       .endif ;PLY_AKG_UseSpecialTracks
+                       .if PLY_CFG_UseTranspositions            ;CONFIG SPECIFIC
+        pop hl
+        ld a,l
+        ld (PLY_AKG_Channel2_Transposition + PLY_AKG_Offset1b),a
+        ld a,h
+        ld (PLY_AKG_Channel3_Transposition + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseTranspositions
+                       .if PLY_AKG_UseSpecialTracks                  ;CONFIG SPECIFIC
+        ;Reads the special Tracks addresses.
+        pop hl          ;Must be performed even SpeedTracks not used, because EventTracks might be present, the word must be skipped.
+                               .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC
+        ld (PLY_AKG_SpeedTrack_PtTrack + PLY_AKG_Offset1b),hl
+                               .endif ;PLY_CFG_UseSpeedTracks
+        
+                               .if PLY_CFG_UseEventTracks            ;CONFIG SPECIFIC
+        pop hl
+        ld (PLY_AKG_EventTrack_PtTrack + PLY_AKG_Offset1b),hl
+                               .endif ;PLY_CFG_UseEventTracks
+                       .endif ;PLY_AKG_UseSpecialTracks
+
+        xor a
+        ;Forces the reading of every Track and Special Track.
+                       .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC
+        ld (PLY_AKG_SpeedTrack_WaitCounter + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseSpeedTracks
+                       .if PLY_CFG_UseEventTracks            ;CONFIG SPECIFIC
+        ld (PLY_AKG_EventTrack_WaitCounter + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEventTracks
+        ld (PLY_AKG_Channel1_WaitCounter + PLY_AKG_Offset1b),a
+        ld (PLY_AKG_Channel2_WaitCounter + PLY_AKG_Offset1b),a
+        ld (PLY_AKG_Channel3_WaitCounter + PLY_AKG_Offset1b),a
+        ld a,c
+PLY_AKG_SetCurrentLineBeforeReadLine:
+        ld (PLY_AKG_PatternDecreasingHeight + PLY_AKG_Offset1b),a
+
+
+        ;Reads the new line (notes, effects, Special Tracks, etc.).
+PLY_AKG_ReadLine:
+        ;Reads the Speed Track.
+                       .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC
+        ;-------------------------------------------------------------------
+       .ifeq PLY_AKG_Rom
+PLY_AKG_SpeedTrack_WaitCounter: ld a,#0x00      ;Lines to wait?
+       .else
+        ld a,(PLY_AKG_SpeedTrack_WaitCounter)
+       .endif
+        sub #0x01
+        jr nc,PLY_AKG_SpeedTrack_MustWait       ;Jump if there are still lines to wait.
+        ;No more lines to wait. Reads a new data. It may be an event value or a wait value.
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_SpeedTrack_PtTrack: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_SpeedTrack_PtTrack)
+       .endif
+        ld a,(hl)
+        inc hl
+        srl a           ;Bit 0: wait?
+        jr c,PLY_AKG_SpeedTrack_StorePointerAndWaitCounter      ;Jump if wait: A is the wait value.
+        ;Value found. If 0, escape value (rare).
+        jr nz,PLY_AKG_SpeedTrack_NormalValue
+        ;Escape code. Reads the right value.
+        ld a,(hl)
+        inc hl
+PLY_AKG_SpeedTrack_NormalValue:
+        ld (PLY_AKG_CurrentSpeed + PLY_AKG_Offset1b),a
+
+        xor a                   ;Next time, a new value is read.
+PLY_AKG_SpeedTrack_StorePointerAndWaitCounter:
+        ld (PLY_AKG_SpeedTrack_PtTrack + PLY_AKG_Offset1b),hl
+PLY_AKG_SpeedTrack_MustWait:
+        ld (PLY_AKG_SpeedTrack_WaitCounter + PLY_AKG_Offset1b),a
+PLY_AKG_SpeedTrack_End:
+                       .endif ;PLY_CFG_UseSpeedTracks
+
+        
+   
+
+
+        ;Reads the Event Track.
+        ;-------------------------------------------------------------------
+                       .if PLY_CFG_UseEventTracks            ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_EventTrack_WaitCounter: ld a,#0x00          ;Lines to wait?
+       .else
+        ld a,(PLY_AKG_EventTrack_WaitCounter)
+       .endif
+        sub #0x01
+        jr nc,PLY_AKG_EventTrack_MustWait       ;Jump if there are still lines to wait.
+        ;No more lines to wait. Reads a new data. It may be an event value or a wait value.
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_EventTrack_PtTrack: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_EventTrack_PtTrack)
+       .endif
+        ld a,(hl)
+        inc hl
+        srl a           ;Bit 0: wait?
+        jr c,PLY_AKG_EventTrack_StorePointerAndWaitCounter      ;Jump if wait: A is the wait value.
+        ;Value found. If 0, escape value (rare).
+        jr nz,PLY_AKG_EventTrack_NormalValue
+        ;Escape code. Reads the right value.
+        ld a,(hl)
+        inc hl
+PLY_AKG_EventTrack_NormalValue:
+        ld (PLY_AKG_Event),a
+
+        xor a                   ;Next time, a new value is read.
+PLY_AKG_EventTrack_StorePointerAndWaitCounter:
+        ld (PLY_AKG_EventTrack_PtTrack + PLY_AKG_Offset1b),hl
+PLY_AKG_EventTrack_MustWait:
+        ld (PLY_AKG_EventTrack_WaitCounter + PLY_AKG_Offset1b),a
+PLY_AKG_EventTrack_End:
+                       .endif ;PLY_CFG_UseEventTracks
+
+
+
+
+        ;Generates the code for each channel, from the macro above.
+        ;-------------------------------------------------------------------------
+        ;Reads the possible Cell of the Channel 1, 2 and 3. Use a Macro for each channel, but the code is duplicated.
+        ;-------------------------------------------------------------------------
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_WaitCounter: ld a,#0x00      ;Lines to wait?
+       .else
+        ld a,(PLY_AKG_Channel1_WaitCounter)
+       .endif
+        sub #0x01
+        jr c,PLY_AKG_Channel1_ReadTrack
+        ;Still some lines to wait.
+        ld (PLY_AKG_Channel1_WaitCounter + PLY_AKG_Offset1b),a
+        jp PLY_AKG_Channel1_ReadCellEnd
+        
+PLY_AKG_Channel1_ReadTrack:
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_Channel1_PtTrack: ld hl,#0x0000      ;Points on the Cell to read.
+       .else
+        ld hl,(PLY_AKG_Channel1_PtTrack)
+       .endif
+        ;Reads note data. It can be a note, a wait...
+
+        ld c,(hl)       ;C = data (b5-0) + effect? (b6) + new Instrument? (b7).
+        inc hl
+        ld a,c
+        and #0b111111     ;A = data.
+        cp #0x3c           ;0-59: note. "cp" is preferred to "sub" so that the "note" branch (the slowest) is note-ready.
+        jr c,PLY_AKG_Channel1_Note
+        sub #0x3c
+        jp z,PLY_AKG_Channel1_MaybeEffects        ;60 = no note, but maybe effects.
+        dec a
+        jr z,PLY_AKG_Channel1_Wait                ;61 = wait, no effect.
+        dec a
+        jr z,PLY_AKG_Channel1_SmallWait           ;62 = small wait, no effect.
+        ;63 = escape code for note, maybe effects.
+        ;Reads the note in the next byte (HL has already been incremented).
+        ld a,(hl)
+        inc hl
+        jr PLY_AKG_Channel1_AfterNoteKnown
+
+        ;Small wait, no effect.
+PLY_AKG_Channel1_SmallWait:
+        ld a,c          ;Uses bit 6/7 to indicate how many lines to wait.
+        rlca
+        rlca
+        and #0b11
+        inc a         ;This wait start at 2 lines, to 5.
+        ld (PLY_AKG_Channel1_WaitCounter + PLY_AKG_Offset1b),a
+        jr PLY_AKG_Channel1_BeforeEnd_StoreCellPointer
+
+        ;Wait, no effect.
+PLY_AKG_Channel1_Wait:
+        ld a,(hl)   ;Reads the wait value on the next byte (HL has already been incremented).
+        ld (PLY_AKG_Channel1_WaitCounter + PLY_AKG_Offset1b),a
+        inc hl
+        jr PLY_AKG_Channel1_BeforeEnd_StoreCellPointer
+
+        ;Little subcode put here, called just below. A bit dirty, but avoids long jump.
+PLY_AKG_Channel1_SameInstrument:
+        ;No new instrument. The instrument pointer must be reset.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PtBaseInstrument: ld de,#0x0000
+       .else
+        ld de,(PLY_AKG_Channel1_PtBaseInstrument)
+       .endif 
+        ld (PLY_AKG_Channel1_PtInstrument + PLY_AKG_Offset1b),de
+        jr PLY_AKG_Channel1_AfterInstrument
+
+        ;A note has been found, plus maybe an Instrument and effects. A = note. C = still has the New Instrument/Effects flags.
+PLY_AKG_Channel1_Note:
+               .ifeq PLY_AKG_Rom
+PLY_AKG_BaseNoteIndex: add a,#0x00                  ;The encoded note is only from a 4 octave range, but the first note depends on he best window, determined by the song generator.
+               .else
+                ld b,a
+                ld a,(PLY_AKG_BaseNoteIndex + PLY_AKG_Offset1b)
+                add a,b
+               .endif
+PLY_AKG_Channel1_AfterNoteKnown:
+                       .if PLY_CFG_UseTranspositions                  ;CONFIG SPECIFIC
+                               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_Transposition: add a,#0x00           ;Adds the Track transposition.
+                               .else
+                                ld b,a
+                                ld a,(PLY_AKG_Channel1_Transposition + PLY_AKG_Offset1b)
+                                add a,b
+                               .endif
+                       .endif ;PLY_CFG_UseTranspositions
+        ld (PLY_AKG_Channel1_TrackNote + PLY_AKG_Offset1b),a
+ 
+        ;HL = next data. C = data byte.
+        rl c                ;New Instrument?
+        jr nc,PLY_AKG_Channel1_SameInstrument
+        ;Gets the new Instrument.
+        ld a,(hl)
+        inc hl
+        exx
+                ld l,a
+                ld h,#0x00
+                add hl,hl
+               .ifeq PLY_AKG_Rom
+PLY_AKG_InstrumentsTable: ld de,#0x0000           ;Points on the Instruments table of the music (set on song initialization).
+               .else
+                        ld de,(PLY_AKG_InstrumentsTable + PLY_AKG_Offset1b)
+               .endif
+                add hl,de
+                ld sp,hl
+                pop hl
+          
+                ld a,(hl)       ;Gets the speed.
+                inc hl
+                        ;No need to store an "original speed" if "force instrument speed" effect is not used.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+                                ld (PLY_AKG_Channel1_InstrumentOriginalSpeed + PLY_AKG_Offset1b),a
+                       .else
+                                ld (PLY_AKG_Channel1_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+                ld (PLY_AKG_Channel1_PtInstrument + PLY_AKG_Offset1b),hl
+                ld (PLY_AKG_Channel1_PtBaseInstrument + PLY_AKG_Offset1b),hl   ;Useful when playing another note with the same instrument.
+        exx
+PLY_AKG_Channel1_AfterInstrument:
+
+        ;There is a new note. The instrument pointer has already been reset.
+        ;-------------------------------------------------------------------
+        ;Instrument number is set.
+        ;Arpeggio and Pitch Table are reset.
+        
+        ;HL must be preserved! But it is faster to use HL than DE when storing 16 bits value.
+        ;So it is stored in DE for now.
+        ex de,hl
+
+        ;The track pitch and glide, instrument step are reset.
+        xor a
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+        ld l,a
+        ld h,a
+        ld (PLY_AKG_Channel1_Pitch + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel1_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel1_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+        ld (PLY_AKG_Channel1_InstrumentStep + PLY_AKG_Offset2b),a
+        
+                        ;If the "force instrument speed" effect is used, the instrument speed must be reset to its original value.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_InstrumentOriginalSpeed: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel1_InstrumentOriginalSpeed)
+       .endif
+        ld (PLY_AKG_Channel1_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+        
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel1_IsPitch),a
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+        
+        ;Resets the speed of the Arpeggio and the Pitch.
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel1_ArpeggioBaseSpeed)
+        ld (PLY_AKG_Channel1_ArpeggioTableSpeed),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel1_PitchBaseSpeed)
+        ld (PLY_AKG_Channel1_PitchTableSpeed),a        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel1_ArpeggioTableBase)              ;Points to the first value of the Arpeggio.
+        ld (PLY_AKG_Channel1_ArpeggioTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel1_PitchTableBase)                 ;Points to the first value of the Pitch.
+        ld (PLY_AKG_Channel1_PitchTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+        ex de,hl
+        
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        ;Effects?
+        rl c
+        jp c,PLY_AKG_Channel1_ReadEffects
+                       .endif ;PLY_CFG_UseEffects
+
+        ;No effects. Nothing more to read for this cell.
+PLY_AKG_Channel1_BeforeEnd_StoreCellPointer:
+        ld (PLY_AKG_Channel1_PtTrack + PLY_AKG_Offset1b),hl
+PLY_AKG_Channel1_ReadCellEnd:
+
+        ;-------------------------------------------------------------------------
+        ;Reads the possible Cell of the Channel 1, 2 and 3. Use a Macro for each channel, but the code is duplicated.
+        ;-------------------------------------------------------------------------
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_WaitCounter: ld a,#0x00      ;Lines to wait?
+       .else
+        ld a,(PLY_AKG_Channel2_WaitCounter)
+       .endif
+        sub #0x01
+        jr c,PLY_AKG_Channel2_ReadTrack
+        ;Still some lines to wait.
+        ld (PLY_AKG_Channel2_WaitCounter + PLY_AKG_Offset1b),a
+        jp PLY_AKG_Channel2_ReadCellEnd
+        
+PLY_AKG_Channel2_ReadTrack:
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_Channel2_PtTrack: ld hl,#0x0000      ;Points on the Cell to read.
+       .else
+        ld hl,(PLY_AKG_Channel2_PtTrack)
+       .endif
+        ;Reads note data. It can be a note, a wait...
+
+        ld c,(hl)       ;C = data (b5-0) + effect? (b6) + new Instrument? (b7).
+        inc hl
+        ld a,c
+        and #0b111111     ;A = data.
+        cp #0x3c           ;0-59: note. "cp" is preferred to "sub" so that the "note" branch (the slowest) is note-ready.
+        jr c,PLY_AKG_Channel2_Note
+        sub #0x3c
+        jp z,PLY_AKG_Channel2_MaybeEffects        ;60 = no note, but maybe effects.
+        dec a
+        jr z,PLY_AKG_Channel2_Wait                ;61 = wait, no effect.
+        dec a
+        jr z,PLY_AKG_Channel2_SmallWait           ;62 = small wait, no effect.
+        ;63 = escape code for note, maybe effects.
+        ;Reads the note in the next byte (HL has already been incremented).
+        ld a,(hl)
+        inc hl
+        jr PLY_AKG_Channel2_AfterNoteKnown
+
+        ;Small wait, no effect.
+PLY_AKG_Channel2_SmallWait:
+        ld a,c          ;Uses bit 6/7 to indicate how many lines to wait.
+        rlca
+        rlca
+        and #0b11
+        inc a         ;This wait start at 2 lines, to 5.
+        ld (PLY_AKG_Channel2_WaitCounter + PLY_AKG_Offset1b),a
+        jr PLY_AKG_Channel2_BeforeEnd_StoreCellPointer
+
+        ;Wait, no effect.
+PLY_AKG_Channel2_Wait:
+        ld a,(hl)   ;Reads the wait value on the next byte (HL has already been incremented).
+        ld (PLY_AKG_Channel2_WaitCounter + PLY_AKG_Offset1b),a
+        inc hl
+        jr PLY_AKG_Channel2_BeforeEnd_StoreCellPointer
+
+        ;Little subcode put here, called just below. A bit dirty, but avoids long jump.
+PLY_AKG_Channel2_SameInstrument:
+        ;No new instrument. The instrument pointer must be reset.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PtBaseInstrument: ld de,#0x0000
+       .else
+        ld de,(PLY_AKG_Channel2_PtBaseInstrument)
+       .endif 
+        ld (PLY_AKG_Channel2_PtInstrument + PLY_AKG_Offset1b),de
+        jr PLY_AKG_Channel2_AfterInstrument
+
+        ;A note has been found, plus maybe an Instrument and effects. A = note. C = still has the New Instrument/Effects flags.
+PLY_AKG_Channel2_Note:
+                ld b,a
+                ld a,(PLY_AKG_BaseNoteIndex + PLY_AKG_Offset1b)
+                add a,b
+PLY_AKG_Channel2_AfterNoteKnown:
+                       .if PLY_CFG_UseTranspositions                  ;CONFIG SPECIFIC
+                               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_Transposition: add a,#0x00           ;Adds the Track transposition.
+                               .else
+                                ld b,a
+                                ld a,(PLY_AKG_Channel2_Transposition + PLY_AKG_Offset1b)
+                                add a,b
+                               .endif
+                       .endif ;PLY_CFG_UseTranspositions
+        ld (PLY_AKG_Channel2_TrackNote + PLY_AKG_Offset1b),a
+ 
+        ;HL = next data. C = data byte.
+        rl c                ;New Instrument?
+        jr nc,PLY_AKG_Channel2_SameInstrument
+        ;Gets the new Instrument.
+        ld a,(hl)
+        inc hl
+        exx
+                ld e,a
+                ld d,#0x00
+                ld hl,(PLY_AKG_InstrumentsTable + PLY_AKG_Offset1b)           ;Points on the Instruments table of the music (set on song initialization).
+                add hl,de
+                add hl,de
+                ld sp,hl
+                pop hl
+          
+                ld a,(hl)       ;Gets the speed.
+                inc hl
+                        ;No need to store an "original speed" if "force instrument speed" effect is not used.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+                                ld (PLY_AKG_Channel2_InstrumentOriginalSpeed + PLY_AKG_Offset1b),a
+                       .else
+                                ld (PLY_AKG_Channel2_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+                ld (PLY_AKG_Channel2_PtInstrument + PLY_AKG_Offset1b),hl
+                ld (PLY_AKG_Channel2_PtBaseInstrument + PLY_AKG_Offset1b),hl   ;Useful when playing another note with the same instrument.
+        exx
+PLY_AKG_Channel2_AfterInstrument:
+
+        ;There is a new note. The instrument pointer has already been reset.
+        ;-------------------------------------------------------------------
+        ;Instrument number is set.
+        ;Arpeggio and Pitch Table are reset.
+        
+        ;HL must be preserved! But it is faster to use HL than DE when storing 16 bits value.
+        ;So it is stored in DE for now.
+        ex de,hl
+
+        ;The track pitch and glide, instrument step are reset.
+        xor a
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+        ld l,a
+        ld h,a
+        ld (PLY_AKG_Channel2_Pitch + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel2_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel2_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+        ld (PLY_AKG_Channel2_InstrumentStep + PLY_AKG_Offset2b),a
+        
+                        ;If the "force instrument speed" effect is used, the instrument speed must be reset to its original value.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_InstrumentOriginalSpeed: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel2_InstrumentOriginalSpeed)
+       .endif
+        ld (PLY_AKG_Channel2_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+        
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel2_IsPitch),a
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+        
+        ;Resets the speed of the Arpeggio and the Pitch.
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel2_ArpeggioBaseSpeed)
+        ld (PLY_AKG_Channel2_ArpeggioTableSpeed),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel2_PitchBaseSpeed)
+        ld (PLY_AKG_Channel2_PitchTableSpeed),a        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel2_ArpeggioTableBase)              ;Points to the first value of the Arpeggio.
+        ld (PLY_AKG_Channel2_ArpeggioTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel2_PitchTableBase)                 ;Points to the first value of the Pitch.
+        ld (PLY_AKG_Channel2_PitchTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+        ex de,hl
+        
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        ;Effects?
+        rl c
+        jp c,PLY_AKG_Channel2_ReadEffects
+                       .endif ;PLY_CFG_UseEffects
+
+        ;No effects. Nothing more to read for this cell.
+PLY_AKG_Channel2_BeforeEnd_StoreCellPointer:
+        ld (PLY_AKG_Channel2_PtTrack + PLY_AKG_Offset1b),hl
+PLY_AKG_Channel2_ReadCellEnd:
+
+        ;-------------------------------------------------------------------------
+        ;Reads the possible Cell of the Channel 1, 2 and 3. Use a Macro for each channel, but the code is duplicated.
+        ;-------------------------------------------------------------------------
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_WaitCounter: ld a,#0x00      ;Lines to wait?
+       .else
+        ld a,(PLY_AKG_Channel3_WaitCounter)
+       .endif
+        sub #0x01
+        jr c,PLY_AKG_Channel3_ReadTrack
+        ;Still some lines to wait.
+        ld (PLY_AKG_Channel3_WaitCounter + PLY_AKG_Offset1b),a
+        jp PLY_AKG_Channel3_ReadCellEnd
+        
+PLY_AKG_Channel3_ReadTrack:
+       .ifeq PLY_AKG_Rom
+
+PLY_AKG_Channel3_PtTrack: ld hl,#0x0000      ;Points on the Cell to read.
+       .else
+        ld hl,(PLY_AKG_Channel3_PtTrack)
+       .endif
+        ;Reads note data. It can be a note, a wait...
+
+        ld c,(hl)       ;C = data (b5-0) + effect? (b6) + new Instrument? (b7).
+        inc hl
+        ld a,c
+        and #0b111111     ;A = data.
+        cp #0x3c           ;0-59: note. "cp" is preferred to "sub" so that the "note" branch (the slowest) is note-ready.
+        jr c,PLY_AKG_Channel3_Note
+        sub #0x3c
+        jp z,PLY_AKG_Channel3_MaybeEffects        ;60 = no note, but maybe effects.
+        dec a
+        jr z,PLY_AKG_Channel3_Wait                ;61 = wait, no effect.
+        dec a
+        jr z,PLY_AKG_Channel3_SmallWait           ;62 = small wait, no effect.
+        ;63 = escape code for note, maybe effects.
+        ;Reads the note in the next byte (HL has already been incremented).
+        ld a,(hl)
+        inc hl
+        jr PLY_AKG_Channel3_AfterNoteKnown
+
+        ;Small wait, no effect.
+PLY_AKG_Channel3_SmallWait:
+        ld a,c          ;Uses bit 6/7 to indicate how many lines to wait.
+        rlca
+        rlca
+        and #0b11
+        inc a         ;This wait start at 2 lines, to 5.
+        ld (PLY_AKG_Channel3_WaitCounter + PLY_AKG_Offset1b),a
+        jr PLY_AKG_Channel3_BeforeEnd_StoreCellPointer
+
+        ;Wait, no effect.
+PLY_AKG_Channel3_Wait:
+        ld a,(hl)   ;Reads the wait value on the next byte (HL has already been incremented).
+        ld (PLY_AKG_Channel3_WaitCounter + PLY_AKG_Offset1b),a
+        inc hl
+        jr PLY_AKG_Channel3_BeforeEnd_StoreCellPointer
+
+        ;Little subcode put here, called just below. A bit dirty, but avoids long jump.
+PLY_AKG_Channel3_SameInstrument:
+        ;No new instrument. The instrument pointer must be reset.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PtBaseInstrument: ld de,#0x0000
+       .else
+        ld de,(PLY_AKG_Channel3_PtBaseInstrument)
+       .endif 
+        ld (PLY_AKG_Channel3_PtInstrument + PLY_AKG_Offset1b),de
+        jr PLY_AKG_Channel3_AfterInstrument
+
+        ;A note has been found, plus maybe an Instrument and effects. A = note. C = still has the New Instrument/Effects flags.
+PLY_AKG_Channel3_Note:
+                ld b,a
+                ld a,(PLY_AKG_BaseNoteIndex + PLY_AKG_Offset1b)
+                add a,b
+PLY_AKG_Channel3_AfterNoteKnown:
+                       .if PLY_CFG_UseTranspositions                  ;CONFIG SPECIFIC
+                               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_Transposition: add a,#0x00           ;Adds the Track transposition.
+                               .else
+                                ld b,a
+                                ld a,(PLY_AKG_Channel3_Transposition + PLY_AKG_Offset1b)
+                                add a,b
+                               .endif
+                       .endif ;PLY_CFG_UseTranspositions
+        ld (PLY_AKG_Channel3_TrackNote + PLY_AKG_Offset1b),a
+ 
+        ;HL = next data. C = data byte.
+        rl c                ;New Instrument?
+        jr nc,PLY_AKG_Channel3_SameInstrument
+        ;Gets the new Instrument.
+        ld a,(hl)
+        inc hl
+        exx
+                ld e,a
+                ld d,#0x00
+                ld hl,(PLY_AKG_InstrumentsTable + PLY_AKG_Offset1b)           ;Points on the Instruments table of the music (set on song initialization).
+                add hl,de
+                add hl,de
+                ld sp,hl
+                pop hl
+          
+                ld a,(hl)       ;Gets the speed.
+                inc hl
+                        ;No need to store an "original speed" if "force instrument speed" effect is not used.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+                                ld (PLY_AKG_Channel3_InstrumentOriginalSpeed + PLY_AKG_Offset1b),a
+                       .else
+                                ld (PLY_AKG_Channel3_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+                ld (PLY_AKG_Channel3_PtInstrument + PLY_AKG_Offset1b),hl
+                ld (PLY_AKG_Channel3_PtBaseInstrument + PLY_AKG_Offset1b),hl   ;Useful when playing another note with the same instrument.
+        exx
+PLY_AKG_Channel3_AfterInstrument:
+
+        ;There is a new note. The instrument pointer has already been reset.
+        ;-------------------------------------------------------------------
+        ;Instrument number is set.
+        ;Arpeggio and Pitch Table are reset.
+        
+        ;HL must be preserved! But it is faster to use HL than DE when storing 16 bits value.
+        ;So it is stored in DE for now.
+        ex de,hl
+
+        ;The track pitch and glide, instrument step are reset.
+        xor a
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+        ld l,a
+        ld h,a
+        ld (PLY_AKG_Channel3_Pitch + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel3_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld (PLY_AKG_Channel3_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+        ld (PLY_AKG_Channel3_InstrumentStep + PLY_AKG_Offset2b),a
+        
+                        ;If the "force instrument speed" effect is used, the instrument speed must be reset to its original value.
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_InstrumentOriginalSpeed: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel3_InstrumentOriginalSpeed)
+       .endif
+        ld (PLY_AKG_Channel3_InstrumentSpeed + PLY_AKG_Offset1b),a
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+        
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel3_IsPitch),a
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+        
+        ;Resets the speed of the Arpeggio and the Pitch.
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel3_ArpeggioBaseSpeed)
+        ld (PLY_AKG_Channel3_ArpeggioTableSpeed),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld a,(PLY_AKG_Channel3_PitchBaseSpeed)
+        ld (PLY_AKG_Channel3_PitchTableSpeed),a        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel3_ArpeggioTableBase)              ;Points to the first value of the Arpeggio.
+        ld (PLY_AKG_Channel3_ArpeggioTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld hl,(PLY_AKG_Channel3_PitchTableBase)                 ;Points to the first value of the Pitch.
+        ld (PLY_AKG_Channel3_PitchTable + PLY_AKG_Offset1b),hl
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+        ex de,hl
+        
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        ;Effects?
+        rl c
+        jp c,PLY_AKG_Channel3_ReadEffects
+                       .endif ;PLY_CFG_UseEffects
+
+        ;No effects. Nothing more to read for this cell.
+PLY_AKG_Channel3_BeforeEnd_StoreCellPointer:
+        ld (PLY_AKG_Channel3_PtTrack + PLY_AKG_Offset1b),hl
+PLY_AKG_Channel3_ReadCellEnd:
+
+
+
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_CurrentSpeed: ld a,#0x00      ;>0.
+       .else
+        ld a,(PLY_AKG_CurrentSpeed)
+       .endif
+PLY_AKG_SetSpeedBeforePlayStreams:
+        ld (PLY_AKG_TickDecreasingCounter + PLY_AKG_Offset1b),a
+
+
+
+
+        ;-----------------------------------------------------------------------------------------
+        ;Applies the trailing effects for channel 1, 2, 3. Uses a macro instead of duplicating the code.
+        ;-----------------------------------------------------------------------------------------
+        
+        ;Use Volume slide?
+        ;----------------------------
+               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal)
+       .endif
+.equ PLY_AKG_Channel1_InvertedVolumeInteger , PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1
+                       .if PLY_AKG_UseEffect_VolumeSlide             ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_IsVolumeSlide: or a                   ;Is there a Volume Slide ? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel1_IsVolumeSlide)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel1_VolumeSlide_End
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_VolumeSlideValue: ld de,#0x0000              ;May be negative.
+       .else
+        ld de,(PLY_AKG_Channel1_VolumeSlideValue)
+       .endif
+        add hl,de
+        ;Went below 0?
+        bit 7,h
+        jr z,PLY_AKG_Channel1_VolumeNotOverflow
+        ld h,#0x00                  ;No need to set L to 0... Shouldn't make any hearable difference.
+        jr PLY_AKG_Channel1_VolumeSetAgain
+PLY_AKG_Channel1_VolumeNotOverflow:
+        ;Higher than 15?
+        ld a,h
+        cp #0x10
+        jr c,PLY_AKG_Channel1_VolumeSetAgain
+        ld h,#0x0f
+PLY_AKG_Channel1_VolumeSetAgain:
+        ld (PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b),hl
+        
+PLY_AKG_Channel1_VolumeSlide_End:
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        ld a,h
+        ld (PLY_AKG_Channel1_GeneratedCurrentInvertedVolume + PLY_AKG_Offset1b),a
+        
+        
+        
+        
+        
+        ;Use Arpeggio table? OUT: C = value.
+        ;----------------------------------------
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld c,#0x00  ;Default value of the arpeggio.
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_IsArpeggioTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel1_IsArpeggioTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel1_ArpeggioTable_End
+
+        ;We can read the Arpeggio table for a new value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_ArpeggioTable: ld hl,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld hl,(PLY_AKG_Channel1_ArpeggioTable)
+       .endif
+        ld a,(hl)
+        cp #0x80                  ;Loop?
+        jr nz,PLY_AKG_Channel1_ArpeggioTable_AfterLoopTest
+        ;Loop. Where to?
+        inc hl
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ld a,(hl)               ;Reads the value. Safe, we know there is no loop here.
+        
+        ;HL = pointer on what is follows.
+        ;A = value to use.
+PLY_AKG_Channel1_ArpeggioTable_AfterLoopTest:
+        ld c,a
+        
+        ;Checks the speed. If reached, the pointer can be saved to read a new value next time.
+        ld a,(PLY_AKG_Channel1_ArpeggioTableSpeed)
+        ld d,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_ArpeggioTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel1_ArpeggioTableCurrentStep)
+       .endif
+        inc a
+        cp d               ;From 1 to 256.
+        jr c,PLY_AKG_Channel1_ArpeggioTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Stores the pointer to read a new value next time.
+        inc hl
+        ld (PLY_AKG_Channel1_ArpeggioTable + PLY_AKG_Offset1b),hl
+
+        xor a
+PLY_AKG_Channel1_ArpeggioTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel1_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel1_ArpeggioTable_End:
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+
+
+        ;Use Pitch table? OUT: DE = pitch value.
+        ;C must NOT be modified!
+        ;-----------------------
+        
+        ld de,#0x0000         ;Default value.
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_IsPitchTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel1_IsPitchTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel1_PitchTable_End
+        
+        ;Read the Pitch table for a value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTable: ld sp,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld sp,(PLY_AKG_Channel1_PitchTable)
+       .endif
+        pop de                  ;Reads the value.
+        pop hl                  ;Reads the pointer to the next value. Manages the loop automatically!
+        
+        ;Checks the speed. If reached, the pointer can be saved (advance in the Pitch).
+        ld a,(PLY_AKG_Channel1_PitchTableSpeed)
+        ld b,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel1_PitchTableCurrentStep)
+       .endif
+        inc a
+        cp b                                                 ;From 1 to 256.
+        jr c,PLY_AKG_Channel1_PitchTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Advances in the Pitch.
+        ld (PLY_AKG_Channel1_PitchTable + PLY_AKG_Offset1b),hl
+        
+        xor a
+PLY_AKG_Channel1_PitchTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel1_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel1_PitchTable_End:        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+
+
+        ;Pitch management. The Glide is embedded, but relies on the Pitch (Pitch can exist without Glide, but Glide can not without Pitch).
+        ;Do NOT modify C or DE.
+        ;------------------------------------------------------------------------------------------
+                       .ifeq PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+                        ld hl,#0x0000 ;No pitch.
+                               .ifeq PLY_AKG_Rom              ;Nothing to declare if ROM.
+                                ;Some dirty duplication in case there is no pitch up/down/glide. The "real" vars are a bit below.
+PLY_AKG_Channel1_SoundStream_RelativeModifierAddress:                 ;Put here, no need for better place (see the real label below, with the same name).
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                                        jr PLY_AKG_Channel1_AfterArpeggioPitchVariables
+                                
+                                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel1_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel1_ArpeggioBaseSpeed:  .db 0
+PLY_AKG_Channel1_ArpeggioTableBase:  .dw 0
+                                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel1_PitchTableSpeed:  .db 0
+PLY_AKG_Channel1_PitchBaseSpeed:   .db 0
+PLY_AKG_Channel1_PitchTableBase:   .dw 0
+                                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel1_AfterArpeggioPitchVariables:
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+                               .endif ;PLY_AKG_ROM       
+                       .else ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_Pitch: ld hl,#0x0000
+PLY_AKG_Channel1_IsPitch: or a                          ;Is there a Pitch? Automodified. SCF if yes, OR A if not.
+       .else
+        ld hl,(PLY_AKG_Channel1_Pitch)
+        ld a,(PLY_AKG_Channel1_IsPitch)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel1_Pitch_End
+        ;C must NOT be modified, stores it.
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .db #0xdd,#0x69      ;ld ixl,c
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTrack: ld bc,#0x0000                    ;Value from the user. ALWAYS POSITIVE. Does not evolve. B is always 0.
+       .else
+        ld bc,(PLY_AKG_Channel1_PitchTrack)
+       .endif
+
+        or a                                            ;Required if the code is changed to sbc.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits: nop 
+        add hl,bc                                       ;WILL BE AUTOMODIFIED to add or sbc. But SBC requires 2*8 bits! Damn.
+       .else
+        jp PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits   ;Calls a code that holds the instruction.
+PLY_AKG_Channel1_PitchTrackAddOrSbc_16bitsReturn:
+       .endif
+        
+        ;Makes the decimal part evolves.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTrackDecimalCounter: ld a,#0x00
+PLY_AKG_Channel1_PitchTrackDecimalInstr: add a,#0x00              ;Value from the user. WILL BE AUTOMODIFIED to add or sub.
+.equ PLY_AKG_Channel1_PitchTrackDecimalValue , PLY_AKG_Channel1_PitchTrackDecimalInstr + 1
+       .else
+        ld a,(PLY_AKG_Channel1_PitchTrackDecimalValue)
+        ld b,a
+        ld a,(PLY_AKG_Channel1_PitchTrackDecimalCounter)
+        ;Add a,b or sub b? Lets the subcode decide. It will return just below.
+        jp PLY_AKG_Channel1_PitchTrackDecimalInstrAndValue
+PLY_AKG_Channel1_PitchTrackDecimalInstrAndValueReturnAfterJp:
+       .endif
+        ld (PLY_AKG_Channel1_PitchTrackDecimalCounter + PLY_AKG_Offset1b),a
+
+        jr nc,PLY_AKG_Channel1_PitchNoCarry
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PitchTrackIntegerAddOrSub: inc hl                   ;WILL BE AUTOMODIFIED to inc hl/dec hl
+       .else
+        jp PLY_AKG_Channel1_PitchTrackIntegerAddOrSub   ;Calls a code that holds the instruction.
+PLY_AKG_Channel1_PitchTrackIntegerAddOrSubReturn:
+       .endif
+PLY_AKG_Channel1_PitchNoCarry:
+        ld (PLY_AKG_Channel1_Pitch + PLY_AKG_Offset1b),hl
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_SoundStream_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+        ;Glide?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_GlideDirection: ld a,#0x00         ;0 = no glide. 1 = glide/pitch up. 2 = glide/pitch down.
+       .else
+        ld a,(PLY_AKG_Channel1_GlideDirection)
+       .endif
+        or a                                    ;Is there a Glide?
+        jr z,PLY_AKG_Channel1_Glide_End
+
+        ld (PLY_AKG_Channel1_Glide_SaveHL + PLY_AKG_Offset1b),hl
+        ld c,l
+        ld b,h
+        ;Finds the period of the current note.
+        ex af,af'
+                ld a,(PLY_AKG_Channel1_TrackNote + PLY_AKG_Offset1b)
+                add a,a                                         ;Encoded on 7 bits, so no problem.
+                ld l,a
+        ex af,af'
+        ld h,#0x00
+        ld sp,#PLY_AKG_PeriodTable
+        add hl,sp
+        ld sp,hl
+        pop hl                                          ;HL = current note period.
+        dec sp
+        dec sp                                          ;We will need this value if the glide is over, it is faster to reuse the stack.
+        
+        add hl,bc                                       ;HL is now the current period (note period + track pitch).
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_GlideToReach: ld bc,#0x0000                  ;Period to reach (note given by the user, converted to period).
+       .else
+        ld bc,(PLY_AKG_Channel1_GlideToReach)
+       .endif
+        ;Have we reached the glide destination?
+        ;Depends on the direction.        
+        rra                                             ;If 1, the carry is set. If 2, no.
+        jr nc,PLY_AKG_Channel1_GlideDownCheck
+        ;Glide up. Check.
+        ;The glide period should be lower than the current pitch.
+        or a
+        sbc hl,bc
+        jr nc,PLY_AKG_Channel1_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+        jr PLY_AKG_Channel1_GlideOver
+
+PLY_AKG_Channel1_GlideDownCheck:
+        ;The glide period should be higher than the current pitch.
+        sbc hl,bc                                       ;No carry, no need to remove it.
+        jr c,PLY_AKG_Channel1_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+PLY_AKG_Channel1_GlideOver:
+        ;The glide is over. However, it may be over, so we can't simply use the current pitch period. We have to set the exact needed value.
+        ld l,c
+        ld h,b
+        pop bc
+        or a
+        sbc hl,bc
+        
+        ld (PLY_AKG_Channel1_Pitch + PLY_AKG_Offset1b),hl
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel1_IsPitch),a
+        ;Skips the HL restoration, the one we have is fine and will give us the right pitch to use.
+        jr PLY_AKG_Channel1_Glide_End
+                               .else
+       .ifeq PLY_AKG_Rom
+                ;Skips the variables below, if there are present.
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                jr PLY_AKG_Channel1_AfterArpeggioPitchVariables
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+       .endif ;PLY_AKG_Rom
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+        ;A small place to stash some vars which have to be within relative range. Dirty, but no choice.
+        ;Note that the vars just below are duplicated due to the conditional assembling (they are a bit above).
+       .ifeq PLY_AKG_Rom
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel1_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel1_ArpeggioBaseSpeed: .db 0
+PLY_AKG_Channel1_ArpeggioTableBase: .dw 0
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel1_PitchTableSpeed: .db 0
+PLY_AKG_Channel1_PitchBaseSpeed: .db 0
+PLY_AKG_Channel1_PitchTableBase: .dw 0
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel1_AfterArpeggioPitchVariables:
+       .endif ;PLY_AKG_Rom
+
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+PLY_AKG_Channel1_Glide_BeforeEnd:
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_Glide_SaveHL: ld hl,#0x0000               ;Restores HL.
+       .else
+        ld hl,(PLY_AKG_Channel1_Glide_SaveHL)
+       .endif
+PLY_AKG_Channel1_Glide_End:
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+                        
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .db #0xdd,#0x4d      ;ld c,ixl                                        ;Restores C (arp), saved before.
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+
+PLY_AKG_Channel1_Pitch_End:
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                        
+                        
+        add hl,de                               ;Adds the Pitch Table value.
+        ld (PLY_AKG_Channel1_GeneratedCurrentPitch + PLY_AKG_Offset1b),hl
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,c
+        ld (PLY_AKG_Channel1_GeneratedCurrentArpNote + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+        ;-----------------------------------------------------------------------------------------
+        ;Applies the trailing effects for channel 1, 2, 3. Uses a macro instead of duplicating the code.
+        ;-----------------------------------------------------------------------------------------
+        
+        ;Use Volume slide?
+        ;----------------------------
+               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal)
+       .endif
+.equ PLY_AKG_Channel2_InvertedVolumeInteger , PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1
+                       .if PLY_AKG_UseEffect_VolumeSlide             ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_IsVolumeSlide: or a                   ;Is there a Volume Slide ? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel2_IsVolumeSlide)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel2_VolumeSlide_End
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_VolumeSlideValue: ld de,#0x0000              ;May be negative.
+       .else
+        ld de,(PLY_AKG_Channel2_VolumeSlideValue)
+       .endif
+        add hl,de
+        ;Went below 0?
+        bit 7,h
+        jr z,PLY_AKG_Channel2_VolumeNotOverflow
+        ld h,#0x00                  ;No need to set L to 0... Shouldn't make any hearable difference.
+        jr PLY_AKG_Channel2_VolumeSetAgain
+PLY_AKG_Channel2_VolumeNotOverflow:
+        ;Higher than 15?
+        ld a,h
+        cp #0x10
+        jr c,PLY_AKG_Channel2_VolumeSetAgain
+        ld h,#0x0f        
+PLY_AKG_Channel2_VolumeSetAgain:
+        ld (PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b),hl
+        
+PLY_AKG_Channel2_VolumeSlide_End:
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        ld a,h
+        ld (PLY_AKG_Channel2_GeneratedCurrentInvertedVolume + PLY_AKG_Offset1b),a
+        
+        
+        
+        
+        
+        ;Use Arpeggio table? OUT: C = value.
+        ;----------------------------------------
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld c,#0x00  ;Default value of the arpeggio.
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_IsArpeggioTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel2_IsArpeggioTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel2_ArpeggioTable_End
+
+        ;We can read the Arpeggio table for a new value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_ArpeggioTable: ld hl,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld hl,(PLY_AKG_Channel2_ArpeggioTable)
+       .endif
+        ld a,(hl)
+        cp #0x80                  ;Loop?
+        jr nz,PLY_AKG_Channel2_ArpeggioTable_AfterLoopTest
+        ;Loop. Where to?
+        inc hl
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ld a,(hl)               ;Reads the value. Safe, we know there is no loop here.
+        
+        ;HL = pointer on what is follows.
+        ;A = value to use.
+PLY_AKG_Channel2_ArpeggioTable_AfterLoopTest:
+        ld c,a
+        
+        ;Checks the speed. If reached, the pointer can be saved to read a new value next time.
+        ld a,(PLY_AKG_Channel2_ArpeggioTableSpeed)
+        ld d,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_ArpeggioTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel2_ArpeggioTableCurrentStep)
+       .endif
+        inc a
+        cp d               ;From 1 to 256.
+        jr c,PLY_AKG_Channel2_ArpeggioTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Stores the pointer to read a new value next time.
+        inc hl
+        ld (PLY_AKG_Channel2_ArpeggioTable + PLY_AKG_Offset1b),hl
+
+        xor a
+PLY_AKG_Channel2_ArpeggioTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel2_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel2_ArpeggioTable_End:
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+
+
+        ;Use Pitch table? OUT: DE = pitch value.
+        ;C must NOT be modified!
+        ;-----------------------
+        
+        ld de,#0x0000         ;Default value.
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_IsPitchTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel2_IsPitchTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel2_PitchTable_End
+        
+        ;Read the Pitch table for a value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTable: ld sp,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld sp,(PLY_AKG_Channel2_PitchTable)
+       .endif
+        pop de                  ;Reads the value.
+        pop hl                  ;Reads the pointer to the next value. Manages the loop automatically!
+        
+        ;Checks the speed. If reached, the pointer can be saved (advance in the Pitch).
+        ld a,(PLY_AKG_Channel2_PitchTableSpeed)
+        ld b,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel2_PitchTableCurrentStep)
+       .endif
+        inc a
+        cp b                                                 ;From 1 to 256.
+        jr c,PLY_AKG_Channel2_PitchTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Advances in the Pitch.
+        ld (PLY_AKG_Channel2_PitchTable + PLY_AKG_Offset1b),hl
+        
+        xor a
+PLY_AKG_Channel2_PitchTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel2_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel2_PitchTable_End:        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+
+
+        ;Pitch management. The Glide is embedded, but relies on the Pitch (Pitch can exist without Glide, but Glide can not without Pitch).
+        ;Do NOT modify C or DE.
+        ;------------------------------------------------------------------------------------------
+                       .ifeq PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+                        ld hl,#0x0000 ;No pitch.
+                               .ifeq PLY_AKG_Rom              ;Nothing to declare if ROM.
+                                ;Some dirty duplication in case there is no pitch up/down/glide. The "real" vars are a bit below.
+PLY_AKG_Channel2_SoundStream_RelativeModifierAddress:                 ;Put here, no need for better place (see the real label below, with the same name).
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                                        jr PLY_AKG_Channel2_AfterArpeggioPitchVariables
+                                
+                                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel2_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel2_ArpeggioBaseSpeed: .db 0
+PLY_AKG_Channel2_ArpeggioTableBase: .dw 0
+                                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel2_PitchTableSpeed: .db 0
+PLY_AKG_Channel2_PitchBaseSpeed: .db 0
+PLY_AKG_Channel2_PitchTableBase: .dw 0
+                                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel2_AfterArpeggioPitchVariables:
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+                               .endif ;PLY_AKG_ROM       
+                       .else ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_Pitch: ld hl,#0x0000
+PLY_AKG_Channel2_IsPitch: or a                          ;Is there a Pitch? Automodified. SCF if yes, OR A if not.
+       .else
+        ld hl,(PLY_AKG_Channel2_Pitch)
+        ld a,(PLY_AKG_Channel2_IsPitch)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel2_Pitch_End
+        ;C must NOT be modified, stores it.
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        .db #0xdd,#0x69      ;ld ixl,c
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTrack: ld bc,#0x0000                    ;Value from the user. ALWAYS POSITIVE. Does not evolve. B is always 0.
+       .else
+        ld bc,(PLY_AKG_Channel2_PitchTrack)
+       .endif
+
+        or a                                            ;Required if the code is changed to sbc.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTrackAddOrSbc_16bits: nop 
+        add hl,bc                                       ;WILL BE AUTOMODIFIED to add or sbc. But SBC requires 2*8 bits! Damn.
+       .else
+        jp PLY_AKG_Channel2_PitchTrackAddOrSbc_16bits   ;Calls a code that holds the instruction.
+PLY_AKG_Channel2_PitchTrackAddOrSbc_16bitsReturn:
+       .endif
+        
+        ;Makes the decimal part evolves.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTrackDecimalCounter: ld a,#0x00
+PLY_AKG_Channel2_PitchTrackDecimalInstr: add a,#0x00              ;Value from the user. WILL BE AUTOMODIFIED to add or sub.
+.equ PLY_AKG_Channel2_PitchTrackDecimalValue , PLY_AKG_Channel2_PitchTrackDecimalInstr + 1
+       .else
+        ld a,(PLY_AKG_Channel2_PitchTrackDecimalValue)
+        ld b,a
+        ld a,(PLY_AKG_Channel2_PitchTrackDecimalCounter)
+        ;Add a,b or sub b? Lets the subcode decide. It will return just below.
+        jp PLY_AKG_Channel2_PitchTrackDecimalInstrAndValue
+PLY_AKG_Channel2_PitchTrackDecimalInstrAndValueReturnAfterJp:
+       .endif
+        ld (PLY_AKG_Channel2_PitchTrackDecimalCounter + PLY_AKG_Offset1b),a
+
+        jr nc,PLY_AKG_Channel2_PitchNoCarry
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PitchTrackIntegerAddOrSub: inc hl                   ;WILL BE AUTOMODIFIED to inc hl/dec hl
+       .else
+        jp PLY_AKG_Channel2_PitchTrackIntegerAddOrSub   ;Calls a code that holds the instruction.
+PLY_AKG_Channel2_PitchTrackIntegerAddOrSubReturn:
+       .endif
+PLY_AKG_Channel2_PitchNoCarry:
+        ld (PLY_AKG_Channel2_Pitch + PLY_AKG_Offset1b),hl
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_SoundStream_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+        ;Glide?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_GlideDirection: ld a,#0x00         ;0 = no glide. 1 = glide/pitch up. 2 = glide/pitch down.
+       .else
+        ld a,(PLY_AKG_Channel2_GlideDirection)
+       .endif
+        or a                                    ;Is there a Glide?
+        jr z,PLY_AKG_Channel2_Glide_End
+
+        ld (PLY_AKG_Channel2_Glide_SaveHL + PLY_AKG_Offset1b),hl
+        ld c,l
+        ld b,h
+        ;Finds the period of the current note.
+        ex af,af'
+                ld a,(PLY_AKG_Channel2_TrackNote + PLY_AKG_Offset1b)
+                add a,a                                         ;Encoded on 7 bits, so no problem.
+                ld l,a
+        ex af,af'
+        ld h,#0x00
+        ld sp,#PLY_AKG_PeriodTable
+        add hl,sp
+        ld sp,hl
+        pop hl                                          ;HL = current note period.
+        dec sp
+        dec sp                                          ;We will need this value if the glide is over, it is faster to reuse the stack.
+        
+        add hl,bc                                       ;HL is now the current period (note period + track pitch).
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_GlideToReach: ld bc,#0x0000                  ;Period to reach (note given by the user, converted to period).
+       .else
+        ld bc,(PLY_AKG_Channel2_GlideToReach)
+       .endif
+        ;Have we reached the glide destination?
+        ;Depends on the direction.        
+        rra                                             ;If 1, the carry is set. If 2, no.
+        jr nc,PLY_AKG_Channel2_GlideDownCheck
+        ;Glide up. Check.
+        ;The glide period should be lower than the current pitch.
+        or a
+        sbc hl,bc
+        jr nc,PLY_AKG_Channel2_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+        jr PLY_AKG_Channel2_GlideOver
+
+PLY_AKG_Channel2_GlideDownCheck:
+        ;The glide period should be higher than the current pitch.
+        sbc hl,bc                                       ;No carry, no need to remove it.
+        jr c,PLY_AKG_Channel2_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+PLY_AKG_Channel2_GlideOver:
+        ;The glide is over. However, it may be over, so we can't simply use the current pitch period. We have to set the exact needed value.
+        ld l,c
+        ld h,b
+        pop bc
+        or a
+        sbc hl,bc
+        
+        ld (PLY_AKG_Channel2_Pitch + PLY_AKG_Offset1b),hl
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel2_IsPitch),a
+        ;Skips the HL restoration, the one we have is fine and will give us the right pitch to use.
+        jr PLY_AKG_Channel2_Glide_End
+                               .else
+       .ifeq PLY_AKG_Rom
+                ;Skips the variables below, if there are present.
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                jr PLY_AKG_Channel2_AfterArpeggioPitchVariables
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+       .endif ;PLY_AKG_Rom
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+        ;A small place to stash some vars which have to be within relative range. Dirty, but no choice.
+        ;Note that the vars just below are duplicated due to the conditional assembling (they are a bit above).
+       .ifeq PLY_AKG_Rom
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel2_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel2_ArpeggioBaseSpeed: .db 0
+PLY_AKG_Channel2_ArpeggioTableBase: .dw 0
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel2_PitchTableSpeed: .db 0
+PLY_AKG_Channel2_PitchBaseSpeed: .db 0
+PLY_AKG_Channel2_PitchTableBase: .dw 0
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel2_AfterArpeggioPitchVariables:
+       .endif ;PLY_AKG_Rom
+
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+PLY_AKG_Channel2_Glide_BeforeEnd:
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_Glide_SaveHL: ld hl,#0x0000               ;Restores HL.
+       .else
+        ld hl,(PLY_AKG_Channel2_Glide_SaveHL)
+       .endif
+PLY_AKG_Channel2_Glide_End:
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+                        
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        .db #0xdd,#0x4d      ;ld c,ixl                                        ;Restores C (arp), saved before.
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+
+PLY_AKG_Channel2_Pitch_End:
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                        
+                        
+        add hl,de                               ;Adds the Pitch Table value.
+        ld (PLY_AKG_Channel2_GeneratedCurrentPitch + PLY_AKG_Offset1b),hl
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,c
+        ld (PLY_AKG_Channel2_GeneratedCurrentArpNote + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+        ;-----------------------------------------------------------------------------------------
+        ;Applies the trailing effects for channel 1, 2, 3. Uses a macro instead of duplicating the code.
+        ;-----------------------------------------------------------------------------------------
+        
+        ;Use Volume slide?
+        ;----------------------------
+               .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal)
+       .endif
+.equ PLY_AKG_Channel3_InvertedVolumeInteger , PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b + 1
+                       .if PLY_AKG_UseEffect_VolumeSlide             ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_IsVolumeSlide: or a                   ;Is there a Volume Slide ? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel3_IsVolumeSlide)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel3_VolumeSlide_End
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_VolumeSlideValue: ld de,#0x0000              ;May be negative.
+       .else
+        ld de,(PLY_AKG_Channel3_VolumeSlideValue)
+       .endif
+        add hl,de
+        ;Went below 0?
+        bit 7,h
+        jr z,PLY_AKG_Channel3_VolumeNotOverflow
+        ld h,#0x00                  ;No need to set L to 0... Shouldn't make any hearable difference.
+        jr PLY_AKG_Channel3_VolumeSetAgain
+PLY_AKG_Channel3_VolumeNotOverflow:
+        ;Higher than 15?
+        ld a,h
+        cp #0x10
+        jr c,PLY_AKG_Channel3_VolumeSetAgain
+        ld h,#0x0f        
+PLY_AKG_Channel3_VolumeSetAgain:
+        ld (PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal + PLY_AKG_Offset1b),hl
+        
+PLY_AKG_Channel3_VolumeSlide_End:
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        ld a,h
+        ld (PLY_AKG_Channel3_GeneratedCurrentInvertedVolume + PLY_AKG_Offset1b),a
+        
+        
+        
+        
+        
+        ;Use Arpeggio table? OUT: C = value.
+        ;----------------------------------------
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld c,#0x00  ;Default value of the arpeggio.
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_IsArpeggioTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel3_IsArpeggioTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel3_ArpeggioTable_End
+
+        ;We can read the Arpeggio table for a new value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_ArpeggioTable: ld hl,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld hl,(PLY_AKG_Channel3_ArpeggioTable)
+       .endif
+        ld a,(hl)
+        cp #0x80                  ;Loop?
+        jr nz,PLY_AKG_Channel3_ArpeggioTable_AfterLoopTest
+        ;Loop. Where to?
+        inc hl
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ld a,(hl)               ;Reads the value. Safe, we know there is no loop here.
+        
+        ;HL = pointer on what is follows.
+        ;A = value to use.
+PLY_AKG_Channel3_ArpeggioTable_AfterLoopTest:
+        ld c,a
+        
+        ;Checks the speed. If reached, the pointer can be saved to read a new value next time.
+        ld a,(PLY_AKG_Channel3_ArpeggioTableSpeed)
+        ld d,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_ArpeggioTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel3_ArpeggioTableCurrentStep)
+       .endif
+        inc a
+        cp d               ;From 1 to 256.
+        jr c,PLY_AKG_Channel3_ArpeggioTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Stores the pointer to read a new value next time.
+        inc hl
+        ld (PLY_AKG_Channel3_ArpeggioTable + PLY_AKG_Offset1b),hl
+
+        xor a
+PLY_AKG_Channel3_ArpeggioTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel3_ArpeggioTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel3_ArpeggioTable_End:
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+
+
+        ;Use Pitch table? OUT: DE = pitch value.
+        ;C must NOT be modified!
+        ;-----------------------
+        
+        ld de,#0x0000         ;Default value.
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_IsPitchTable: or a                   ;Is there an arpeggio table? Automodified. SCF if yes, OR A if not.
+       .else
+        ld a,(PLY_AKG_Channel3_IsPitchTable)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel3_PitchTable_End
+        
+        ;Read the Pitch table for a value.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTable: ld sp,#0x0000                 ;Points on the data, after the header.
+       .else
+        ld sp,(PLY_AKG_Channel3_PitchTable)
+       .endif
+        pop de                  ;Reads the value.
+        pop hl                  ;Reads the pointer to the next value. Manages the loop automatically!
+        
+        ;Checks the speed. If reached, the pointer can be saved (advance in the Pitch).
+        ld a,(PLY_AKG_Channel3_PitchTableSpeed)
+        ld b,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTableCurrentStep: ld a,#0x00
+       .else
+        ld a,(PLY_AKG_Channel3_PitchTableCurrentStep)
+       .endif
+        inc a
+        cp b                                                 ;From 1 to 256.
+        jr c,PLY_AKG_Channel3_PitchTable_BeforeEnd_SaveStep  ;C, not NZ, because the current step may be higher than the limit if Force Speed effect is used.
+        ;Advances in the Pitch.
+        ld (PLY_AKG_Channel3_PitchTable + PLY_AKG_Offset1b),hl
+        
+        xor a
+PLY_AKG_Channel3_PitchTable_BeforeEnd_SaveStep:
+        ld (PLY_AKG_Channel3_PitchTableCurrentStep + PLY_AKG_Offset1b),a
+PLY_AKG_Channel3_PitchTable_End:        
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+
+
+        ;Pitch management. The Glide is embedded, but relies on the Pitch (Pitch can exist without Glide, but Glide can not without Pitch).
+        ;Do NOT modify C or DE.
+        ;------------------------------------------------------------------------------------------
+                       .ifeq PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+                        ld hl,#0x0000 ;No pitch.
+                               .ifeq PLY_AKG_Rom              ;Nothing to declare if ROM.
+                                ;Some dirty duplication in case there is no pitch up/down/glide. The "real" vars are a bit below.
+PLY_AKG_Channel3_SoundStream_RelativeModifierAddress:                 ;Put here, no need for better place (see the real label below, with the same name).
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                                        jr PLY_AKG_Channel3_AfterArpeggioPitchVariables
+                                
+                                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel3_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel3_ArpeggioBaseSpeed: .db 0
+PLY_AKG_Channel3_ArpeggioTableBase: .dw 0
+                                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel3_PitchTableSpeed: .db 0
+PLY_AKG_Channel3_PitchBaseSpeed: .db 0
+PLY_AKG_Channel3_PitchTableBase: .dw 0
+                                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel3_AfterArpeggioPitchVariables:
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+                               .endif ;PLY_AKG_ROM       
+                       .else ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_Pitch: ld hl,#0x0000
+PLY_AKG_Channel3_IsPitch: or a                          ;Is there a Pitch? Automodified. SCF if yes, OR A if not.
+       .else
+        ld hl,(PLY_AKG_Channel3_Pitch)
+        ld a,(PLY_AKG_Channel3_IsPitch)
+        add a,a         ;Creates the carry or not.
+       .endif
+        jr nc,PLY_AKG_Channel3_Pitch_End
+        ;C must NOT be modified, stores it.
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        .db #0xdd,#0x69      ;ld ixl,c
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTrack: ld bc,#0x0000                    ;Value from the user. ALWAYS POSITIVE. Does not evolve. B is always 0.
+       .else
+        ld bc,(PLY_AKG_Channel3_PitchTrack)
+       .endif
+
+        or a                                            ;Required if the code is changed to sbc.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTrackAddOrSbc_16bits: nop 
+        add hl,bc                                       ;WILL BE AUTOMODIFIED to add or sbc. But SBC requires 2*8 bits! Damn.
+       .else
+        jp PLY_AKG_Channel3_PitchTrackAddOrSbc_16bits   ;Calls a code that holds the instruction.
+PLY_AKG_Channel3_PitchTrackAddOrSbc_16bitsReturn:
+       .endif
+        
+        ;Makes the decimal part evolves.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTrackDecimalCounter: ld a,#0x00
+PLY_AKG_Channel3_PitchTrackDecimalInstr: add a,#0x00              ;Value from the user. WILL BE AUTOMODIFIED to add or sub.
+.equ PLY_AKG_Channel3_PitchTrackDecimalValue , PLY_AKG_Channel3_PitchTrackDecimalInstr + 1
+       .else
+        ld a,(PLY_AKG_Channel3_PitchTrackDecimalValue)
+        ld b,a
+        ld a,(PLY_AKG_Channel3_PitchTrackDecimalCounter)
+        ;Add a,b or sub b? Lets the subcode decide. It will return just below.
+        jp PLY_AKG_Channel3_PitchTrackDecimalInstrAndValue
+PLY_AKG_Channel3_PitchTrackDecimalInstrAndValueReturnAfterJp:
+       .endif
+        ld (PLY_AKG_Channel3_PitchTrackDecimalCounter + PLY_AKG_Offset1b),a
+
+        jr nc,PLY_AKG_Channel3_PitchNoCarry
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PitchTrackIntegerAddOrSub: inc hl                   ;WILL BE AUTOMODIFIED to inc hl/dec hl
+       .else
+        jp PLY_AKG_Channel3_PitchTrackIntegerAddOrSub   ;Calls a code that holds the instruction.
+PLY_AKG_Channel3_PitchTrackIntegerAddOrSubReturn:
+       .endif
+PLY_AKG_Channel3_PitchNoCarry:
+        ld (PLY_AKG_Channel3_Pitch + PLY_AKG_Offset1b),hl
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_SoundStream_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+        ;Glide?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_GlideDirection: ld a,#0x00         ;0 = no glide. 1 = glide/pitch up. 2 = glide/pitch down.
+       .else
+        ld a,(PLY_AKG_Channel3_GlideDirection)
+       .endif
+        or a                                    ;Is there a Glide?
+        jr z,PLY_AKG_Channel3_Glide_End
+
+        ld (PLY_AKG_Channel3_Glide_SaveHL + PLY_AKG_Offset1b),hl
+        ld c,l
+        ld b,h
+        ;Finds the period of the current note.
+        ex af,af'
+                ld a,(PLY_AKG_Channel3_TrackNote + PLY_AKG_Offset1b)
+                add a,a                                         ;Encoded on 7 bits, so no problem.
+                ld l,a
+        ex af,af'
+        ld h,#0x00
+        ld sp,#PLY_AKG_PeriodTable
+        add hl,sp
+        ld sp,hl
+        pop hl                                          ;HL = current note period.
+        dec sp
+        dec sp                                          ;We will need this value if the glide is over, it is faster to reuse the stack.
+        
+        add hl,bc                                       ;HL is now the current period (note period + track pitch).
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_GlideToReach: ld bc,#0x0000                  ;Period to reach (note given by the user, converted to period).
+       .else
+        ld bc,(PLY_AKG_Channel3_GlideToReach)
+       .endif
+        ;Have we reached the glide destination?
+        ;Depends on the direction.        
+        rra                                             ;If 1, the carry is set. If 2, no.
+        jr nc,PLY_AKG_Channel3_GlideDownCheck
+        ;Glide up. Check.
+        ;The glide period should be lower than the current pitch.
+        or a
+        sbc hl,bc
+        jr nc,PLY_AKG_Channel3_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+        jr PLY_AKG_Channel3_GlideOver
+
+PLY_AKG_Channel3_GlideDownCheck:
+        ;The glide period should be higher than the current pitch.
+        sbc hl,bc                                       ;No carry, no need to remove it.
+        jr c,PLY_AKG_Channel3_Glide_BeforeEnd           ;If not reached yet, continues the pitch.
+PLY_AKG_Channel3_GlideOver:
+        ;The glide is over. However, it may be over, so we can't simply use the current pitch period. We have to set the exact needed value.
+        ld l,c
+        ld h,b
+        pop bc
+        or a
+        sbc hl,bc
+        
+        ld (PLY_AKG_Channel3_Pitch + PLY_AKG_Offset1b),hl
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld (PLY_AKG_Channel3_IsPitch),a
+        ;Skips the HL restoration, the one we have is fine and will give us the right pitch to use.
+        jr PLY_AKG_Channel3_Glide_End
+                               .else
+       .ifeq PLY_AKG_Rom
+                ;Skips the variables below, if there are present.
+                                       .if PLY_AKS_UseEffect_ArpeggioTableOrPitchTable       ;CONFIG SPECIFIC
+                jr PLY_AKG_Channel3_AfterArpeggioPitchVariables
+                                       .endif ;PLY_AKS_UseEffect_ArpeggioTableOrPitchTable
+       .endif ;PLY_AKG_Rom
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+        ;A small place to stash some vars which have to be within relative range. Dirty, but no choice.
+        ;Note that the vars just below are duplicated due to the conditional assembling (they are a bit above).
+       .ifeq PLY_AKG_Rom
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Channel3_ArpeggioTableSpeed: .db 0
+PLY_AKG_Channel3_ArpeggioBaseSpeed: .db 0
+PLY_AKG_Channel3_ArpeggioTableBase: .dw 0
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_AKG_Channel3_PitchTableSpeed: .db 0
+PLY_AKG_Channel3_PitchBaseSpeed: .db 0
+PLY_AKG_Channel3_PitchTableBase: .dw 0
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+PLY_AKG_Channel3_AfterArpeggioPitchVariables:
+       .endif ;PLY_AKG_Rom
+
+                               .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+PLY_AKG_Channel3_Glide_BeforeEnd:
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_Glide_SaveHL: ld hl,#0x0000               ;Restores HL.
+       .else
+        ld hl,(PLY_AKG_Channel3_Glide_SaveHL)
+       .endif
+PLY_AKG_Channel3_Glide_End:
+                               .endif ;PLY_CFG_UseEffect_PitchGlide
+                        
+                               .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        .db #0xdd,#0x4d      ;ld c,ixl                                        ;Restores C (arp), saved before.
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+
+PLY_AKG_Channel3_Pitch_End:
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                        
+                        
+        add hl,de                               ;Adds the Pitch Table value.
+        ld (PLY_AKG_Channel3_GeneratedCurrentPitch + PLY_AKG_Offset1b),hl
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld a,c
+        ld (PLY_AKG_Channel3_GeneratedCurrentArpNote + PLY_AKG_Offset1b),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ;The stack must NOT be diverted during the Play Streams!
+        ld sp,(PLY_AKG_SaveSP + PLY_AKG_Offset1b)
+
+
+;-------------------------------------------------------------------------------------
+;Plays the instrument on channel 1, 2, 3. The PSG registers related to the channels are set.
+;A macro is used instead of duplicating the code.
+;-------------------------------------------------------------------------------------     
+        
+        ;Generates the code for all channels using the macro above.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+        
+        ;What note to play?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_GeneratedCurrentPitch: ld hl,#0x0000 ;The pitch to add to the real note, according to the Pitch Table + Pitch/Glide effect.
+       .else
+        ld hl,(PLY_AKG_Channel1_GeneratedCurrentPitch)
+       .endif
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_TrackNote: ld a,#0x00
+PLY_AKG_Channel1_GeneratedCurrentArpNote: add a,#0x00                           ;Adds the arpeggio value.
+       .else
+        ld a,(PLY_AKG_Channel1_TrackNote)
+        ld e,a
+        ld a,(PLY_AKG_Channel1_GeneratedCurrentArpNote)
+        add a,e
+       .endif
+                ld e,a
+                ld d,#0x00
+                       .else ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_TrackNote: ld de,#0x0000               ;Not automodified, stays this way.
+       .else
+        ld a,(PLY_AKG_Channel1_TrackNote)        ;In ROM, MUST pass by a variable anyway to be analog to if Arpeggio is used (see above).
+        ld e,a
+        ld d,#0x00
+       .endif
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+        exx
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_InstrumentStep: .db #0xfd,#0x2e,#0x00      ;ld iyl,0
+PLY_AKG_Channel1_PtInstrument: ld hl,#0x0000       ;Instrument data to read (past the header).
+PLY_AKG_Channel1_GeneratedCurrentInvertedVolume: ld de,#0b11100000 * 256 + 15             ;R7, shift twice TO THE LEFT. By default, the noise is cut (111), the sound is on (most usual case).
+       .else
+        ld a,(PLY_AKG_Channel1_InstrumentStep)
+        ld iyl,a
+        ld hl,(PLY_AKG_Channel1_PtInstrument)
+        ld a,(PLY_AKG_Channel1_GeneratedCurrentInvertedVolume)
+        ld e,a
+                ;For the first channel, sets the R7 value to no noise, all channel on by default ().
+                ld d,#0b11100000
+       .endif
+        
+;       D = Reg7
+;       E = inverted volume.
+;       D' = 0, E' = note (instrument + Track transposition).
+;       HL' = track pitch.
+
+        call PLY_AKG_ReadInstrumentCell
+
+        ;The new and increased Instrument pointer is stored only if its speed has been reached.
+       .if PLY_AKG_Rom
+        ld a,(PLY_AKG_Channel1_InstrumentSpeed)
+        ld b,a
+       .endif
+       .db #0xfd,#0x7d      ;ld a,iyl
+        inc a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel1_InstrumentSpeed: cp #0x00          ;(>0)
+       .else
+        cp b
+       .endif
+        jr c,PLY_AKG_Channel1_SetInstrumentStep         ;Checks C, not only NZ because since the speed can be changed via an effect, the step can get beyond the limit, this must be taken in account.
+        ;The speed is reached. We can go to the next line on the next frame.
+        ld (PLY_AKG_Channel1_PtInstrument + PLY_AKG_Offset1b),hl
+        xor a
+PLY_AKG_Channel1_SetInstrumentStep:
+        ld (PLY_AKG_Channel1_InstrumentStep + PLY_AKG_Offset2b),a
+
+        
+        ;Saves the software period and volume for the PSG to send later.
+        ld a,e
+        ld (PLY_AKG_PSGReg8),a          ;Reaches register/label 8/9/10.
+        
+               .if PLY_AKG_HARDWARE_CPC
+                        srl d           ;Shift D to the right to let room for the other channels. Use SRL, not RR, to make sure bit 6 is 0 at the end (else, no more keyboard on CPC!).
+               .else
+                       .if PLY_AKG_HARDWARE_MSX
+                                        srl d           ;R7 bit 6 on MSX must be 0.
+                       .else
+                                rr d            ;On other platform, we don't care.
+                       .endif
+               .endif
+        
+        exx
+                        ld (PLY_AKG_PSGReg01_Instr + PLY_AKG_Offset1b),hl
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_PlayInstrument_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+        
+        ;What note to play?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_GeneratedCurrentPitch: ld hl,#0x0000 ;The pitch to add to the real note, according to the Pitch Table + Pitch/Glide effect.
+       .else
+        ld hl,(PLY_AKG_Channel2_GeneratedCurrentPitch)
+       .endif
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_TrackNote: ld a,#0x00
+PLY_AKG_Channel2_GeneratedCurrentArpNote: add a,#0x00                           ;Adds the arpeggio value.
+       .else
+        ld a,(PLY_AKG_Channel2_TrackNote)
+        ld e,a
+        ld a,(PLY_AKG_Channel2_GeneratedCurrentArpNote)
+        add a,e
+       .endif
+                ld e,a
+                ld d,#0x00
+                       .else ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_TrackNote: ld de,#0x0000               ;Not automodified, stays this way.
+       .else
+        ld a,(PLY_AKG_Channel2_TrackNote)        ;In ROM, MUST pass by a variable anyway to be analog to if Arpeggio is used (see above).
+        ld e,a
+        ld d,#0x00
+       .endif
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+        exx
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_InstrumentStep: .db #0xfd,#0x2e,#0x00      ;ld iyl,0
+PLY_AKG_Channel2_PtInstrument: ld hl,#0x0000       ;Instrument data to read (past the header).
+
+PLY_AKG_Channel2_GeneratedCurrentInvertedVolume: ld e,#0x0f
+                nop                     ;Stupid, but required for relative registers to reach addresses independently of the channels.
+       .else
+        ld a,(PLY_AKG_Channel2_InstrumentStep)
+        ld iyl,a
+        ld hl,(PLY_AKG_Channel2_PtInstrument)
+        ld a,(PLY_AKG_Channel2_GeneratedCurrentInvertedVolume)
+        ld e,a
+       .endif
+        
+;       D = Reg7
+;       E = inverted volume.
+;       D' = 0, E' = note (instrument + Track transposition).
+;       HL' = track pitch.
+
+        call PLY_AKG_ReadInstrumentCell
+
+        ;The new and increased Instrument pointer is stored only if its speed has been reached.
+       .if PLY_AKG_Rom
+        ld a,(PLY_AKG_Channel2_InstrumentSpeed)
+        ld b,a
+       .endif
+       .db #0xfd,#0x7d      ;ld a,iyl
+        inc a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel2_InstrumentSpeed: cp #0x00          ;(>0)
+       .else
+        cp b
+       .endif
+        jr c,PLY_AKG_Channel2_SetInstrumentStep         ;Checks C, not only NZ because since the speed can be changed via an effect, the step can get beyond the limit, this must be taken in account.
+        ;The speed is reached. We can go to the next line on the next frame.
+        ld (PLY_AKG_Channel2_PtInstrument + PLY_AKG_Offset1b),hl
+        xor a
+PLY_AKG_Channel2_SetInstrumentStep:
+        ld (PLY_AKG_Channel2_InstrumentStep + PLY_AKG_Offset2b),a
+
+        
+        ;Saves the software period and volume for the PSG to send later.
+        ld a,e
+        ld (PLY_AKG_PSGReg9),a          ;Reaches register/label 8/9/10.
+        
+               .if PLY_AKG_HARDWARE_CPC
+                        srl d           ;Shift D to the right to let room for the other channels. Use SRL, not RR, to make sure bit 6 is 0 at the end (else, no more keyboard on CPC!).
+               .else
+                       .if PLY_AKG_HARDWARE_MSX
+                                        scf             ;R7 bit 7 on MSX must be 1.
+                                        rr d
+                       .else
+                                rr d            ;On other platform, we don't care.
+                       .endif
+               .endif
+        
+        exx
+                        ld (PLY_AKG_PSGReg23_Instr + PLY_AKG_Offset1b),hl
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_PlayInstrument_RelativeModifierAddress:                   ;This must be placed at the any location to allow reaching the variables via IX/IY.
+       .endif
+        
+        ;What note to play?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_GeneratedCurrentPitch: ld hl,#0x0000 ;The pitch to add to the real note, according to the Pitch Table + Pitch/Glide effect.
+       .else
+        ld hl,(PLY_AKG_Channel3_GeneratedCurrentPitch)
+       .endif
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_TrackNote: ld a,#0x00
+PLY_AKG_Channel3_GeneratedCurrentArpNote: add a,#0x00                           ;Adds the arpeggio value.
+       .else
+        ld a,(PLY_AKG_Channel3_TrackNote)
+        ld e,a
+        ld a,(PLY_AKG_Channel3_GeneratedCurrentArpNote)
+        add a,e
+       .endif
+                ld e,a
+                ld d,#0x00
+                       .else ;PLY_AKS_UseEffect_Arpeggio
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_TrackNote: ld de,#0x0000               ;Not automodified, stays this way.
+       .else
+        ld a,(PLY_AKG_Channel3_TrackNote)        ;In ROM, MUST pass by a variable anyway to be analog to if Arpeggio is used (see above).
+        ld e,a
+        ld d,#0x00
+       .endif
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+        exx
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_InstrumentStep: .db #0xfd,#0x2e,#0x00      ;ld iyl,0
+PLY_AKG_Channel3_PtInstrument: ld hl,#0x0000       ;Instrument data to read (past the header).
+
+PLY_AKG_Channel3_GeneratedCurrentInvertedVolume: ld e,#0x0f
+                nop                     ;Stupid, but required for relative registers to reach addresses independently of the channels.
+       .else
+        ld a,(PLY_AKG_Channel3_InstrumentStep)
+        ld iyl,a
+        ld hl,(PLY_AKG_Channel3_PtInstrument)
+        ld a,(PLY_AKG_Channel3_GeneratedCurrentInvertedVolume)
+        ld e,a
+       .endif
+        
+;       D = Reg7
+;       E = inverted volume.
+;       D' = 0, E' = note (instrument + Track transposition).
+;       HL' = track pitch.
+
+        call PLY_AKG_ReadInstrumentCell
+
+        ;The new and increased Instrument pointer is stored only if its speed has been reached.
+       .if PLY_AKG_Rom
+        ld a,(PLY_AKG_Channel3_InstrumentSpeed)
+        ld b,a
+       .endif
+       .db #0xfd,#0x7d      ;ld a,iyl
+        inc a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel3_InstrumentSpeed: cp #0x00          ;(>0)
+       .else
+        cp b
+       .endif
+        jr c,PLY_AKG_Channel3_SetInstrumentStep         ;Checks C, not only NZ because since the speed can be changed via an effect, the step can get beyond the limit, this must be taken in account.
+        ;The speed is reached. We can go to the next line on the next frame.
+        ld (PLY_AKG_Channel3_PtInstrument + PLY_AKG_Offset1b),hl
+        xor a
+PLY_AKG_Channel3_SetInstrumentStep:
+        ld (PLY_AKG_Channel3_InstrumentStep + PLY_AKG_Offset2b),a
+
+        
+        ;Saves the software period and volume for the PSG to send later.
+        ld a,e
+        ld (PLY_AKG_PSGReg10),a          ;Reaches register/label 8/9/10.
+        
+                ;Gets the R7.
+                ld a,d        
+        exx
+                        ld (PLY_AKG_PSGReg45_Instr + PLY_AKG_Offset1b),hl
+        
+        
+        
+ 
+          
+;Plays the sound effects, if desired.
+;-------------------------------------------
+       .if PLY_AKG_MANAGE_SOUND_EFFECTS
+                ;IN : A = R7
+                ;OUT: A = R7, possibly modified.
+                call PLY_AKG_PlaySoundEffectsStream
+       .endif ;PLY_AKG_MANAGE_SOUND_EFFECTS
+     
+
+
+; -----------------------------------------------------------------------------------
+; PSG access.
+; -----------------------------------------------------------------------------------
+
+;Sends the registers to the PSG. Only general registers are sent, the specific ones have already been sent.
+;IN:    A = R7.
+PLY_AKG_SendPSGRegisters:
+       .if PLY_AKG_HARDWARE_ENTERPRISE
+PLY_AKG_SaveSP: ld sp,#0x0000
+        push    af
+        ld      c,#0x00
+        ;Register 0 and 1.
+PLY_AKG_PSGReg01_Instr: ld de,#0x0000
+        call    ayRegisterWriteE
+        ld      e,d
+        call    ayRegisterWriteE
+     
+        ;Register 2 and 3.
+PLY_AKG_PSGReg23_Instr: ld de,#0x0000
+        call    ayRegisterWriteE
+        ld      e,d
+        call    ayRegisterWriteE
+        
+        ;Register 4 and 5.
+PLY_AKG_PSGReg45_Instr: ld de,#0x0000
+        call    ayRegisterWriteE
+        ld      e,d
+        call    ayRegisterWriteE
+        
+        ;Register 6.
+                       .if PLY_AKG_Use_NoiseRegister         ;CONFIG SPECIFIC
+PLY_AKG_PSGReg6_8_Instr: ld de,#0x0000          ;L is R6, H is R8. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg6 , PLY_AKG_PSGReg6_8_Instr + 1
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg6_8_Instr + 2
+        call    ayRegisterWriteE
+                       .else
+                ;No noise. But R8 must still be set.
+PLY_AKG_PSGReg8_Instr: ld d,#0x00
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg8_Instr + 1
+                       .endif ;PLY_AKG_Use_NoiseRegister
+                                
+        ;Register 7. The value is A.
+        pop     af
+        call    ayRegisterWrite
+        
+        ;Register 8. The value is loaded above via HL.
+        ld      e,d
+        call    ayRegisterWriteE
+
+
+PLY_AKG_PSGReg9_10_Instr: ld de,#0x0000          ;L is R9, H is R10. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg9 , PLY_AKG_PSGReg9_10_Instr + 1
+.equ PLY_AKG_PSGReg10 , PLY_AKG_PSGReg9_10_Instr + 2
+        ;Register 9.
+        call    ayRegisterWriteE
+        
+        ;Register 10.
+        ld      e,d
+        call    ayRegisterWriteE
+
+        
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Register 11 and 12.
+PLY_AKG_PSGHardwarePeriod_Instr: ld de,#0x0000
+        call    ayRegisterWriteE
+        ld      e,d
+        call    ayRegisterWriteE
+
+                               .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+PLY_AKG_PSGReg13_OldValue: ld a,#0xff
+PLY_AKG_Retrig: or #0x00                    ;0 = no retrig. Else, should be >0xf to be sure the old value becomes a sentinel (i.e. unreachable) value.
+PLY_AKG_PSGReg13_Instr: ld l,#0x00          ;Register 13.
+        cp l                            ;Is the new value still the same? If yes, the new value must not be set again.
+        ret z
+        ;Different R13.
+        ld a,l
+                               .else ;PLY_CFG_UseRetrig
+PLY_AKG_PSGReg13_Instr: ld a,#0x00          ;Register 13.
+PLY_AKG_PSGReg13_OldValue: cp #0xff
+        ret z
+                               .endif ;PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+        ld (PLY_AKG_PSGReg13_OldValue + PLY_AKG_Offset1b),a
+
+        call    ayRegisterWrite
+                               .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+        xor a
+        ld (PLY_AKG_Retrig + PLY_AKG_Offset1b),a
+                               .endif ;PLY_CFG_UseRetrig
+                       .endif ;PLY_CFG_UseHardwareSounds
+                        ret
+       .endif   
+       
+       .if PLY_AKG_HARDWARE_CPC
+            ld bc,#0xf680
+            ld e,#0xc0
+        	out (c),e	;#f6c0          ;Madram's trick requires to start with this. out (c),b works, but will activate K7's relay! Not clean.
+        exx
+        ld bc,#0xf401                     ;C is the PSG register.
+
+        ;Register 0 and 1.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg01_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg01_Instr)
+       .endif
+        .db #0xed,#0x71     ;out (c),#0x00                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+     
+        ;Register 2 and 3.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg23_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg23_Instr)
+       .endif
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        ;Register 4 and 5.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg45_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg45_Instr)
+       .endif
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        ;Register 6.
+                       .if PLY_AKG_Use_NoiseRegister         ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg6_8_Instr: ld hl,#0x0000          ;L is R6, H is R8. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg6 , PLY_AKG_PSGReg6_8_Instr + 1
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg6_8_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg6_8_Instr)
+       .endif
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+                       .else
+                ;No noise. But R8 must still be set.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg8_Instr: ld h,#0x00
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg8_Instr + 1
+       .else
+        ld hl,(PLY_AKG_PSGReg6_8_Instr) ;L was not useful, but A must not be modified yet.
+       .endif
+                inc c
+                       .endif ;PLY_AKG_Use_NoiseRegister
+                                
+        ;Register 7. The value is A.
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),a                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        ;Register 8. The value is loaded above via HL.
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg9_10_Instr: ld hl,#0x0000          ;L is R9, H is R10. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg9 , PLY_AKG_PSGReg9_10_Instr + 1
+.equ PLY_AKG_PSGReg10 , PLY_AKG_PSGReg9_10_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg9_10_Instr)
+       .endif
+        ;Register 9.
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+        ;Register 10.
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+        
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Register 11 and 12.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGHardwarePeriod_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGHardwarePeriod_Instr)
+       .endif
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),l                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx  
+
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),h                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        exx
+                       .endif ;PLY_CFG_UseHardwareSounds
+       .endif
+       .if PLY_AKG_HARDWARE_SPECTRUM + PLY_AKG_HARDWARE_PENTAGON
+        
+        ex af,af'       ;Saves R7.
+        ld de,#0xbfff
+        ld bc,#0xfffd
+        
+        ld a,#0x01          ;Register.
+        
+        ;Register 0 and 1.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg01_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg01_Instr)
+       .endif
+        .db #0xed,#0x71     ;out (c),#0x00       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+        
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+      
+        ;Register 2 and 3.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg23_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg23_Instr)
+       .endif
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+        
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+        
+        ;Register 4 and 5.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg45_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg45_Instr)
+       .endif
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+        
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+        
+        ;Register 6.
+                       .if PLY_AKG_Use_NoiseRegister         ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg6_8_Instr: ld hl,#0x0000          ;L is R6, H is R8. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg6 , PLY_AKG_PSGReg6_8_Instr + 1
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg6_8_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg6_8_Instr)
+       .endif
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+                       .else
+                ;No noise. But R8 must still be set.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg8_Instr: ld h,#0x00
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg8_Instr + 1
+       .else
+        ld hl,(PLY_AKG_PSGReg6_8_Instr)         ;L not useful, but A needs to be not modified.
+       .endif
+                inc a
+                       .endif ;PLY_AKG_Use_NoiseRegister
+     
+        ;Register 7. The value is A.
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        ex af,af'       ;Retrieves R7.
+        out (c),a       ;#bffd + value
+        ex af,af'
+        ld b,e
+        
+        ;Register 8. The value is loaded above via HL.
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+        
+        ;Register 9 and 10.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg9_10_Instr: ld hl,#0x0000
+.equ PLY_AKG_PSGReg9 , PLY_AKG_PSGReg9_10_Instr + 1
+.equ PLY_AKG_PSGReg10 , PLY_AKG_PSGReg9_10_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg9_10_Instr)
+       .endif
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+        
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+        
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Register 11 and 12.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGHardwarePeriod_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGHardwarePeriod_Instr)
+       .endif
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),l       ;#bffd + value
+        ld b,e
+        
+        inc a
+        out (c),a       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+       .endif
+       .if PLY_AKG_HARDWARE_MSX
+       
+        ld b,a          ;Preserves R7.
+        ld a,7
+        out (#0xa0),a     ;Register.
+        ld a,b
+        out (#0xa1),a     ;Value.
+
+       .ifeq PLY_AKG_Rom
+       
+PLY_AKG_PSGReg01_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg01_Instr)
+       .endif
+        xor a
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+
+        ld a,#0x01
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg23_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg23_Instr)
+       .endif
+        ld a,2
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+
+        ld a,3
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+        
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg45_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGReg45_Instr)
+       .endif
+        ld a,4
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+
+        ld a,5
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+        
+        ;Register 6.
+                       .if PLY_AKG_Use_NoiseRegister         ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg6_8_Instr: ld hl,#0x0000          ;L is R6, H is R8. Faster to set a 16 bits register than 2 8-bit.
+.equ PLY_AKG_PSGReg6 , PLY_AKG_PSGReg6_8_Instr + 1
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg6_8_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg6_8_Instr)
+       .endif
+        ld a,6
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+        
+        ld a,#0x08
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+                       .else
+                ;No noise. Takes care of R8.
+                ld a,#0x08
+                out (#0xa0),a     ;Register.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg8_Instr: ld a,#0x00
+.equ PLY_AKG_PSGReg8 , PLY_AKG_PSGReg8_Instr + 1
+       .else
+        ld a,(PLY_AKG_PSGReg8)
+       .endif
+                out (#0xa1),a     ;Value.
+                       .endif ;PLY_AKG_Use_NoiseRegister
+        
+        ;Register 9 and 10.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg9_10_Instr: ld hl,#0x0000
+.equ PLY_AKG_PSGReg9 , PLY_AKG_PSGReg9_10_Instr + 1
+.equ PLY_AKG_PSGReg10 , PLY_AKG_PSGReg9_10_Instr + 2
+       .else
+        ld hl,(PLY_AKG_PSGReg9_10_Instr)
+       .endif
+        ld a,#0x09
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+        
+        ld a,#0x0a
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+        
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Register 11 and 12.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGHardwarePeriod_Instr: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PSGHardwarePeriod_Instr)
+       .endif
+        ld a,#0x0b
+        out (#0xa0),a     ;Register.
+        ld a,l
+        out (#0xa1),a     ;Value.
+        
+        ld a,#0x0c
+        out (#0xa0),a     ;Register.
+        ld a,h
+        out (#0xa1),a     ;Value.
+                       .endif ;PLY_CFG_UseHardwareSounds
+        
+       .endif
+        
+      .ifeq PLY_AKG_HARDWARE_ENTERPRISE
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;R13.
+       .if PLY_AKG_HARDWARE_MSX
+        ld a,#0x0d        ;Selects R13 now, even if not changed, because A will be modified.
+        out (#0xa0),a     ;Register.
+       .endif
+       .if PLY_AKG_HARDWARE_SPECTRUM + PLY_AKG_HARDWARE_PENTAGON
+        inc a           ;Selects R13 now, even if not changed, because A will be modified.
+        out (c),a       ;#fffd + register.
+       .endif
+       
+                               .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg13_OldValue: ld a,#0xff
+PLY_AKG_Retrig: or #0x00                    ;0 = no retrig. Else, should be >0xf to be sure the old value becomes a sentinel (i.e. unreachable) value.
+PLY_AKG_PSGReg13_Instr: ld l,#0x00          ;Register 13.
+       .else
+        ld a,(PLY_AKG_PSGReg13_Instr)
+        ld l,a
+        ld a,(PLY_AKG_Retrig)
+        ld h,a
+        ld a,(PLY_AKG_PSGReg13_OldValue)
+        or h
+       .endif
+        cp l                            ;Is the new value still the same? If yes, the new value must not be set again.
+        jr z,PLY_AKG_PSGReg13_End
+        ;Different R13.
+        ld a,l
+                               .else ;PLY_CFG_UseRetrig
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PSGReg13_Instr: ld a,#0x00          ;Register 13.
+PLY_AKG_PSGReg13_OldValue: cp #0xff
+       .else
+        ld a,(PLY_AKG_PSGReg13_OldValue)
+        ld l,a
+        ld a,(PLY_AKG_PSGReg13_Instr)
+        cp l
+       .endif
+        jr z,PLY_AKG_PSGReg13_End
+                               .endif ;PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+        ld (PLY_AKG_PSGReg13_OldValue + PLY_AKG_Offset1b),a
+
+       .if PLY_AKG_HARDWARE_CPC
+        inc c
+        out (c),c                       ;#f400 + register.
+        exx
+                .db #0xed,#0x71     ;out (c),#0x00               ;#f600.
+        exx
+        out (c),a                       ;#f400 + value.
+        exx
+                out (c),c               ;#f680.
+                out (c),e               ;#f6c0.
+        ;exx
+        
+       .endif
+       .if PLY_AKG_HARDWARE_MSX
+        out (#0xa1),a     ;Value.
+       .endif
+       .if PLY_AKG_HARDWARE_SPECTRUM + PLY_AKG_HARDWARE_PENTAGON
+        ld b,d
+        out (c),a       ;#bffd + value
+        
+       .endif
+                               .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+        xor a
+        ld (PLY_AKG_Retrig + PLY_AKG_Offset1b),a
+                               .endif ;PLY_CFG_UseRetrig
+PLY_AKG_PSGReg13_End:
+                       .endif ;PLY_CFG_UseHardwareSounds
+       .ifeq PLY_AKG_Rom
+PLY_AKG_SaveSP: ld sp,#0x0000
+       .else
+        ld sp,(PLY_AKG_SaveSp)
+       .endif
+        ret
+      .endif
+        
+
+PLY_AKG_Channel1_MaybeEffects:
+        ;There is one wait in all cases.
+        ;xor a                  ;A is supposed to be 0.
+        ld (PLY_AKG_Channel1_WaitCounter + PLY_AKG_Offset1b),a
+                       .ifeq PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        jp PLY_AKG_Channel1_BeforeEnd_StoreCellPointer
+                       .else
+        bit 6,c         ;Effects?
+        jp z,PLY_AKG_Channel1_BeforeEnd_StoreCellPointer
+        ;Manage effects.
+        
+;Reads the effects.
+;IN:    HL = Points on the effect blocks
+;OUT:   HL = Points after on the effect blocks
+PLY_AKG_Channel1_ReadEffects:
+        ld iy,#PLY_AKG_Channel1_SoundStream_RelativeModifierAddress
+        ld ix,#PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress
+        ld de,#PLY_AKG_Channel1_BeforeEnd_StoreCellPointer
+        ;Only adds a jump if this is not the last channel, as the code only need to jump below.
+                jr PLY_AKG_Channel_ReadEffects
+                       .endif ;PLY_CFG_UseEffects
+PLY_AKG_Channel1_ReadEffectsEnd:
+
+PLY_AKG_Channel2_MaybeEffects:
+        ;There is one wait in all cases.
+        ;xor a                  ;A is supposed to be 0.
+        ld (PLY_AKG_Channel2_WaitCounter + PLY_AKG_Offset1b),a
+                       .ifeq PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        jp PLY_AKG_Channel2_BeforeEnd_StoreCellPointer
+                       .else
+        bit 6,c         ;Effects?
+        jp z,PLY_AKG_Channel2_BeforeEnd_StoreCellPointer
+        ;Manage effects.
+        
+;Reads the effects.
+;IN:    HL = Points on the effect blocks
+;OUT:   HL = Points after on the effect blocks
+PLY_AKG_Channel2_ReadEffects:
+        ld iy,#PLY_AKG_Channel2_SoundStream_RelativeModifierAddress
+        ld ix,#PLY_AKG_Channel2_PlayInstrument_RelativeModifierAddress
+        ld de,#PLY_AKG_Channel2_BeforeEnd_StoreCellPointer
+        ;Only adds a jump if this is not the last channel, as the code only need to jump below.
+                jr PLY_AKG_Channel_ReadEffects
+                       .endif ;PLY_CFG_UseEffects
+PLY_AKG_Channel2_ReadEffectsEnd:
+
+PLY_AKG_Channel3_MaybeEffects:
+        ;There is one wait in all cases.
+        ;xor a                  ;A is supposed to be 0.
+        ld (PLY_AKG_Channel3_WaitCounter + PLY_AKG_Offset1b),a
+                       .ifeq PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+        jp PLY_AKG_Channel3_BeforeEnd_StoreCellPointer
+                       .else
+        bit 6,c         ;Effects?
+        jp z,PLY_AKG_Channel3_BeforeEnd_StoreCellPointer
+        ;Manage effects.
+        
+;Reads the effects.
+;IN:    HL = Points on the effect blocks
+;OUT:   HL = Points after on the effect blocks
+PLY_AKG_Channel3_ReadEffects:
+        ld iy,#PLY_AKG_Channel3_SoundStream_RelativeModifierAddress
+        ld ix,#PLY_AKG_Channel3_PlayInstrument_RelativeModifierAddress
+        ld de,#PLY_AKG_Channel3_BeforeEnd_StoreCellPointer
+        ;Only adds a jump if this is not the last channel, as the code only need to jump below.
+                       .endif ;PLY_CFG_UseEffects
+PLY_AKG_Channel3_ReadEffectsEnd:
+
+
+        ;** NO CODE between the code above and below! **
+                    
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+;IN:    HL = Points on the effect blocks
+;       DE = Where to go to when over.
+;       IX = Address from which the data of the instrument are modified.
+;       IY = Address from which data of the channels (pitch, volume, etc) are modified.
+;OUT:   HL = Points after on the effect blocks
+PLY_AKG_Channel_ReadEffects:
+        
+       .ifeq PLY_AKG_Rom
+                ld (PLY_AKG_Channel_ReadEffects_EndJump + PLY_AKG_Offset1b),de
+       .else
+                ld (PLY_AKG_Channel_ReadEffects_EndJumpInstrAndAddress + 1),de
+       .endif
+        ;HL will be very useful, so we store the pointer in DE.
+        ex de,hl
+
+        ;Reads the effect block. It may be an index or a relative address.        
+        ld a,(de)
+        inc de
+        sla a
+        jr c,PLY_AKG_Channel_ReadEffects_RelativeAddress
+        ;Index.
+        exx
+                ld l,a
+                ld h,#0x00
+
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel_ReadEffects_EffectBlocks1: ld de,#0x0000
+       .else
+        ld de,(PLY_AKG_Channel_ReadEffects_EffectBlocks1)
+       .endif
+                add hl,de               ;The index is already *2.
+                ld e,(hl)               ;Gets the address referred by the table.
+                inc hl
+                ld d,(hl)
+PLY_AKG_Channel_RE_EffectAddressKnown:
+                ;DE points on the current effect block header/data.
+                ld a,(de)               ;Gets the effect number/more effect flag.
+                inc de
+                ld (PLY_AKG_Channel_RE_ReadNextEffectInBlock + PLY_AKG_Offset1b),a     ;Stores the flag indicating whether there are more effects.
+                
+                ;Gets the effect number.
+                and #0b11111110
+                ld l,a
+                ld h,#0x00
+                ld sp,#PLY_AKG_EffectTable
+                add hl,sp                ;Effect is already * 2.
+                ld sp,hl                ;Jumps to the effect code.
+                ret
+                ;All the effects return here.
+PLY_AKG_Channel_RE_EffectReturn:
+                ;Is there another effect?
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel_RE_ReadNextEffectInBlock: ld a,#0x00                ;Bit 0 indicates whether there are more effects.
+       .else
+                ld a,(PLY_AKG_Channel_RE_ReadNextEffectInBlock)
+       .endif
+                rra
+                jr c,PLY_AKG_Channel_RE_EffectAddressKnown
+                ;No more effects.
+        exx
+        
+        ;Put back in HL the point on the Track Cells.
+        ex de,hl
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel_ReadEffects_EndJump: jp 0        ;PLY_AKG_Channel1/2/3_BeforeEnd_StoreCellPointer
+       .else
+        jp PLY_AKG_Channel_ReadEffects_EndJumpInstrAndAddress
+       .endif
+
+PLY_AKG_Channel_ReadEffects_RelativeAddress:
+        srl a           ;A was the relative MSB. Only 7 relevant bits.
+        exx
+                ld h,a
+        exx
+        ld a,(de)       ;Reads the relative LSB.
+        inc de
+        exx
+                ld l,a
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Channel_ReadEffects_EffectBlocks2: ld de,#0x0000
+       .else
+        ld de,(PLY_AKG_Channel_ReadEffects_EffectBlocks1)       ;In ROM, reads the first value, it is the same. Duplicating it is only an optimization for RAM player to avoid reading memory.
+       .endif
+                add hl,de
+                jr PLY_AKG_Channel_RE_EffectAddressKnown
+                       .endif ;PLY_CFG_UseEffects
+
+
+
+
+
+;---------------------------------
+;Codes that read InstrumentCells.
+;IN:    HL = pointer on the Instrument data cell to read.
+;       IX = can be modified.
+;       IYL = Instrument step (>=0). Useful for retrig.
+;       SP = normal use of the stack, do not pervert it!
+;       D = register 7, as if it was the channel 3 (so, bit 2 and 5 filled only).
+;             By default, the noise is OFF, the sound is ON, so no need to do anything if these values match.
+;       E = inverted volume.
+;       A = SET BELOW: first byte of the data, shifted of 3 bits to the right.
+;       B = SET BELOW: first byte of the data, unmodified.
+;       HL' = track pitch.
+;       DE' = 0 / note (instrument + Track transposition).
+;       BC' = temp, use at will.
+
+;OUT:   HL = new pointer on the Instrument (may be on the empty sound). If not relevant, any value can be returned, it doesn't matter.
+;       IYL = Not 0 if retrig for this channel.
+;       D = register 7, updated, as if it was the channel 1 (so, bit 2 and 5 filled only).
+;       E = volume to encode (0-16).
+;       HL' = software period. If not relevant, do not set it.
+;       DE' = output period.
+
+.equ PLY_AKG_BitForSound , 2
+.equ PLY_AKG_BitForNoise , 5
+
+
+PLY_AKG_ReadInstrumentCell:
+        ld a,(hl)               ;Gets the first byte of the cell.
+        inc hl
+        ld b,a                  ;Stores the first byte, handy in many cases.
+        
+        ;What type if the cell?
+        rra
+        jp c,PLY_AKG_S_Or_H_Or_SaH_Or_EndWithLoop
+        ;No Soft No Hard, or Soft To Hard, or Hard To Soft, or End without loop.
+        rra
+       .ifeq PLY_AKG_Rom
+                jr c,PLY_AKG_StH_Or_EndWithoutLoop
+       .else
+                jp c,PLY_AKG_StH_Or_EndWithoutLoop
+       .endif
+        ;No Soft No Hard, or Hard to Soft.
+        rra
+                       .if PLY_CFG_HardToSoft       ;CONFIG SPECIFIC
+        jr c,PLY_AKG_HardToSoft
+                       .endif ;PLY_CFG_HardToSoft
+        
+        
+        
+        
+        
+        
+        ;-------------------------------------------------
+        ;"No soft, no hard".
+        ;-------------------------------------------------
+PLY_AKG_NoSoftNoHard:
+        and #0b1111               ;Necessary, we don't know what crap is in the 4th bit of A.
+        sub e                   ;Decreases the volume, watching for overflow.
+        jr nc,. + 3
+        xor a
+        
+        ld e,a                  ;Sets the volume.
+
+                       .if PLY_CFG_NoSoftNoHard_Noise                ;CONFIG SPECIFIC
+        rl b            ;Noise?
+        jr nc,PLY_AKG_NSNH_NoNoise
+        ;Noise.
+        ld a,(hl)
+        inc hl
+        ld (PLY_AKG_PSGReg6),a
+        set PLY_AKG_BitForSound,d      ;Noise, no sound (both non-default values).
+        res PLY_AKG_BitForNoise,d
+        ret
+PLY_AKG_NSNH_NoNoise:
+                       .endif ;PLY_CFG_NoSoftNoHard_Noise
+        set PLY_AKG_BitForSound,d      ;No noise (default), no sound.
+        ret
+
+
+
+
+
+
+
+        ;-------------------------------------------------
+        ;"Soft only".
+        ;-------------------------------------------------
+                       .if PLY_CFG_SoftOnly          ;CONFIG SPECIFIC
+PLY_AKG_Soft:
+        ;Calculates the volume.
+        and #0b1111               ;Necessary, we don't know what crap is in the 4th bit of A.
+        
+        sub e                   ;Decreases the volume, watching for overflow.
+        jr nc,. + 3             ;Checks for overflow.
+        xor a
+    
+        ld e,a                  ;Sets the volume.
+                       .endif ;PLY_CFG_SoftOnly
+                       .if PLY_AKG_UseSoftOnlyOrHardOnly     ;CONFIG SPECIFIC
+PLY_AKG_SoftOnly_HardOnly_TestSimple_Common:        ;This code is also used by "Hard only".
+        ;Simple sound? Gets the bit, let the subroutine do the job.
+        rl b
+        jr nc,PLY_AKG_S_NotSimple
+        ;Simple.
+        ld c,#0x00                  ;This will force the noise to 0.
+        jr PLY_AKG_S_AfterSimpleTest
+PLY_AKG_S_NotSimple:
+        ;Not simple. Reads and keeps the next byte, containing the noise. WARNING, the following code must NOT modify the Carry!
+        ld b,(hl)
+        ld c,b
+        inc hl
+PLY_AKG_S_AfterSimpleTest:
+
+        call PLY_AKG_S_Or_H_CheckIfSimpleFirst_CalculatePeriod
+        
+                               .if PLY_AKG_UseSoftOnlyOrHardOnly_Noise       ;CONFIG SPECIFIC
+        ;Noise?
+        ld a,c
+        and #0b11111
+        ret z                                   ;if noise not present, sound present, we can stop here, R7 is fine.
+        ;Noise is present.
+        ld (PLY_AKG_PSGReg6),a
+        res PLY_AKG_BitForNoise,d               ;Noise present.
+                               .endif ;PLY_AKG_UseSoftOnlyOrHardOnly_Noise
+        ret
+                       .endif ;PLY_AKG_UseSoftOnlyOrHardOnly
+        
+
+
+
+
+        ;-------------------------------------------------
+        ;"Hard to soft".
+        ;-------------------------------------------------
+                       .if PLY_CFG_HardToSoft       ;CONFIG SPECIFIC
+PLY_AKG_HardToSoft:
+        call PLY_AKG_StoH_HToS_SandH_Common
+        ;We have the ratio jump calculated and the primary period too. It must be divided to get the software frequency.
+        
+       .ifeq PLY_AKG_Rom
+        ld (PLY_AKG_HS_JumpRatio + 1),a
+       .else
+        ;Stores where to jump after the JumpRatio label. Only BC' is free...
+        exx
+                ld bc,#PLY_AKG_HS_JumpRatio
+                add a,c
+                ld c,a
+                ld a,b
+                adc a,#0x00
+                ld b,a
+                ld (PLY_AKG_TempPlayInstrumentJumpInstrAndAddress + 1),bc         ;The first byte has a jump.
+        exx
+       .endif
+        
+        ;Gets B, we need the bit to know if a software pitch shift is added.
+                               .if PLY_CFG_HardToSoft_SoftwarePitch  ;CONFIG SPECIFIC
+        ld a,b
+                               .endif ;PLY_CFG_HardToSoft_SoftwarePitch
+        exx
+                ;The hardware period can be stored.
+                ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b),hl
+       .ifeq PLY_AKG_Rom
+PLY_AKG_HS_JumpRatio: jr . + 2               ;Automodified by the line above to jump on the right code.
+       .else
+                jp PLY_AKG_TempPlayInstrumentJumpInstrAndAddress        ;If ROM, jumps to the buffer, it will jump back just after according to the ratio.
+PLY_AKG_HS_JumpRatio:
+       .endif
+                sla l
+                rl h
+                sla l
+                rl h
+                sla l
+                rl h
+                sla l
+                rl h
+                sla l
+                rl h
+                sla l
+                rl h
+                sla l
+                rl h
+                ;Any Software pitch shift?
+                               .if PLY_CFG_HardToSoft_SoftwarePitch  ;CONFIG SPECIFIC
+                rla
+                jr nc,PLY_AKG_SH_NoSoftwarePitchShift
+;Pitch shift. Reads it.
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                add a,l
+                ld l,a
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                adc a,h
+                ld h,a        
+PLY_AKG_SH_NoSoftwarePitchShift:
+                               .endif ;PLY_CFG_HardToSoft_SoftwarePitch
+        exx
+        
+        ret
+                       .endif ;PLY_CFG_HardToSoft
+        
+
+
+        ;-------------------------------------------------
+        ;End without loop. Put here to satisfy the JR range below.
+        ;-------------------------------------------------
+PLY_AKG_EndWithoutLoop:
+        ;Loops to the "empty" instrument, and makes another iteration.
+       .ifeq PLY_AKG_Rom
+PLY_AKG_EmptyInstrumentDataPt: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_EmptyInstrumentDataPt)
+       .endif
+        ;No need to read the data, consider a void value.
+        inc hl
+        xor a
+        ld b,a
+       .ifeq PLY_AKG_Rom
+                jr PLY_AKG_NoSoftNoHard
+       .else
+                jp PLY_AKG_NoSoftNoHard
+       .endif
+        
+        
+        
+        ;-----------------------------------------
+PLY_AKG_StH_Or_EndWithoutLoop:
+        rra
+                       .ifeq PLY_CFG_SoftToHard                ;CONFIG SPECIFIC
+        jr PLY_AKG_EndWithoutLoop
+                       .else
+        jr c,PLY_AKG_EndWithoutLoop
+        
+        ;-------------------------------------------------
+        ;"Soft to Hard".
+        ;-------------------------------------------------
+                        
+        call PLY_AKG_StoH_HToS_SandH_Common
+        ;We have the ratio jump calculated and the primary period too. It must be divided to get the hardware frequency.
+
+       .ifeq PLY_AKG_Rom
+        ld (PLY_AKG_SH_JumpRatio + 1),a
+       .else
+        ;Stores where to jump after the JumpRatio label. Only BC' is free...
+        exx
+                ld bc,#PLY_AKG_SH_JumpRatio
+                add a,c
+                ld c,a
+                ld a,b
+                adc a,#0x00
+                ld b,a
+                ld (PLY_AKG_TempPlayInstrumentJumpInstrAndAddress + 1),bc         ;The first byte has a jump.
+        exx
+       .endif
+        
+        ;Gets B, we need the bit to know if a hardware pitch shift is added.
+                               .if PLY_CFG_SoftToHard_HardwarePitch          ;CONFIG SPECIFIC
+        ld a,b
+                               .endif ;PLY_CFG_SoftToHard_HardwarePitch
+        exx
+                ;Saves the original frequency in DE.
+                ld e,l
+                ld d,h
+       .ifeq PLY_AKG_Rom
+PLY_AKG_SH_JumpRatio: jr . + 2               ;Automodified by the line above to jump on the right code.
+       .else
+                jp PLY_AKG_TempPlayInstrumentJumpInstrAndAddress        ;If ROM, jumps to the buffer, it will jump back just after according to the ratio.
+PLY_AKG_SH_JumpRatio:
+       .endif
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                jr nc,PLY_AKG_SH_JumpRatioEnd
+                inc hl
+PLY_AKG_SH_JumpRatioEnd:
+                               .if PLY_CFG_SoftToHard_HardwarePitch          ;CONFIG SPECIFIC
+                ;Any Hardware pitch shift?
+                rla
+                jr nc,PLY_AKG_SH_NoHardwarePitchShift
+                ;Pitch shift. Reads it.
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                add a,l
+                ld l,a
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                adc a,h
+                ld h,a        
+PLY_AKG_SH_NoHardwarePitchShift:
+                               .endif ;PLY_CFG_SoftToHard_HardwarePitch
+                ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b),hl
+                
+                ;Put back the frequency in HL.
+                ex de,hl
+        exx
+        
+        ret
+                       .endif ;PLY_CFG_SoftToHard
+        
+        
+        
+       
+PLY_AKG_S_Or_H_Or_SaH_Or_EndWithLoop:
+        ;Second bit of the type.
+        rra
+        jr c,PLY_AKG_H_Or_EndWithLoop
+        ;Third bit of the type.
+        rra
+                       .if PLY_CFG_SoftOnly          ;CONFIG SPECIFIC
+        jp nc,PLY_AKG_Soft
+                       .endif ;PLY_CFG_SoftOnly
+        
+                       .if PLY_CFG_SoftAndHard       ;CONFIG SPECIFIC
+        ;-------------------------------------------------
+        ;"Soft and Hard".
+        ;-------------------------------------------------
+        exx
+                push hl         ;Saves the note and track pitch, because the first pass below will modify it, we need it for the second pass.
+                push de
+        exx
+        
+        call PLY_AKG_StoH_HToS_SandH_Common
+        ;We have now calculated the hardware frequency. Stores it.
+        exx
+                ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b),hl
+                
+                pop de          ;Get back the note and track pitch for the second pass.
+                pop hl
+        exx
+        
+        
+        ;Now calculate the software frequency.
+        rl b            ;Simple sound? Used by the sub-code.
+        jp PLY_AKG_S_Or_H_CheckIfSimpleFirst_CalculatePeriod    ;That's all!
+                       .endif ;PLY_CFG_SoftAndHard
+                
+        
+        
+
+        
+PLY_AKG_H_Or_EndWithLoop:
+                       .if PLY_CFG_HardOnly          ;CONFIG SPECIFIC
+        ;Third bit of the type. Only used for HardOnly, not in case of EndWithLoop.
+        rra
+                               .if PLY_CFG_UseInstrumentLoopTo       ;CONFIG SPECIFIC
+        ;Ok to remove this jump if PLY_CFG_HardOnly variable absent, it will directly go to the code below.
+        jr c,PLY_AKG_EndWithLoop
+                               .endif
+
+        ;-------------------------------------------------
+        ;"Hard only".
+        ;-------------------------------------------------
+        
+        ld e,#0x10                 ;Sets the hardware volume.
+
+        ;Retrig?
+        rra
+                               .if PLY_CFG_HardOnly_Retrig           ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_H_AfterRetrig
+        ld c,a
+        ;Retrig is only set if we are on the first step of the instrument!
+       .db #0xfd,#0x7d      ;ld a,iyl
+        or a
+        jr nz,PLY_AKG_H_RetrigEnd
+        ld a,e
+        ld (PLY_AKG_Retrig + PLY_AKG_Offset1b),a
+PLY_AKG_H_RetrigEnd:
+        ld a,c
+PLY_AKG_H_AfterRetrig:
+                               .endif ;PLY_CFG_HardOnly_Retrig
+
+        ;Calculates the hardware envelope. The value given is from 8-15, but encoded as 0-7.
+        and #0b111
+        add a,#0x08
+        ld (PLY_AKG_PSGReg13_Instr + PLY_AKG_Offset1b),a
+
+        ;Use the code of Soft Only to calculate the period and the noise.
+        call PLY_AKG_SoftOnly_HardOnly_TestSimple_Common
+
+        ;The period is actually an hardware period. We don't care about the software period, the sound channel is cut.
+        exx
+                ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b),hl
+        exx
+        
+        ;Stops the sound.
+        set PLY_AKG_BitForSound,d
+
+        ret
+                       .endif ;PLY_CFG_HardOnly
+        
+        ;** WARNING! ** Do not put instructions here between HardOnly and EndWithLoop, else conditional assembling will fail.
+        
+        ;-------------------------------------------------
+        ;End with loop.
+        ;-------------------------------------------------
+                       .if PLY_CFG_UseInstrumentLoopTo       ;CONFIG SPECIFIC
+PLY_AKG_EndWithLoop:
+        ;Loops to the encoded pointer, and makes another iteration.
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jp PLY_AKG_ReadInstrumentCell
+                       .endif ;PLY_CFG_UseInstrumentLoopTo
+                        
+
+
+
+     
+;Common code for calculating the period, regardless of Soft or Hard. The same register constraints as the methods above apply.
+;IN:    HL = the next bytes to read.
+;       HL' = note + transposition.
+;       B = contains three bits:
+;               b7: forced period? (if yes, the two other bits are irrelevant)
+;               b6: arpeggio?
+;               b5: pitch?
+;       C = do not modify.
+;       Carry: Simple sound?
+;OUT:   B = shift three times to the left.
+;       C = unmodified.
+;       HL = advanced.
+;       HL' = calculated period.
+PLY_AKG_S_Or_H_CheckIfSimpleFirst_CalculatePeriod:
+
+        ;Simple sound? Checks the carry.
+                       .if PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs     ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_S_Or_H_NextByte
+                       .endif ;PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs
+        ;No more bytes to read, the sound is "simple". The software period must still be calculated.
+        ;Calculates the note period from the note of the track. This is the same code as below.
+        exx
+                ex de,hl                        ;Now HL = track note + transp, DE is track pitch.
+                add hl,hl
+                ld bc,#PLY_AKG_PeriodTable
+                add hl,bc
+           
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a
+                add hl,de                       ;Adds the track pitch.
+        exx
+        ;Important: the bits must be shifted so that B is in the same state as if it were not a "simple" sound.
+        rl b
+        rl b
+        rl b
+        ;No need to modify R7.
+        ret
+        
+                       .if PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs     ;CONFIG SPECIFIC
+PLY_AKG_S_Or_H_NextByte:
+        ;Not simple. Reads the next bits to know if there is pitch/arp/forced software period.        
+        ;Forced period?
+        rl b
+                       .if PLY_AKG_UseInstrumentForcedPeriods          ;CONFIG SPECIFIC
+        jr c,PLY_AKG_S_Or_H_ForcedPeriod
+                       .endif ;PLY_AKG_UseInstrumentForcedPeriods
+        ;No forced period. Arpeggio?
+        rl b
+                       .if PLY_AKG_UseInstrumentArpeggios              ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_S_Or_H_AfterArpeggio
+        ld a,(hl)
+        inc hl
+        exx
+                add a,e                         ;We don't care about overflow, no time for that.
+                ld e,a
+        exx
+PLY_AKG_S_Or_H_AfterArpeggio:
+                       .endif ;PLY_AKG_UseInstrumentArpeggios
+        ;Pitch?
+        rl b
+                       .if PLY_AKG_UseInstrumentPitchs                 ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_S_Or_H_AfterPitch
+        ;Reads the pitch. Slow, but shouldn't happen so often.
+        ld a,(hl)
+        inc hl
+        exx
+                add a,l
+                ld l,a                          ;Adds the cell pitch to the track pitch, in two passes.
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                adc a,h
+                ld h,a
+        exx
+PLY_AKG_S_Or_H_AfterPitch:
+                       .endif ;PLY_AKG_UseInstrumentPitchs
+        
+        ;Calculates the note period from the note of the track.
+        exx
+                ex de,hl                        ;Now HL = track note + transp, DE is track pitch.
+                add hl,hl
+                ld bc,#PLY_AKG_PeriodTable
+                add hl,bc
+                
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a
+                add hl,de                       ;Adds the track pitch.
+        exx
+
+        ret
+                       .endif ;PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs
+
+
+                       .if PLY_AKG_UseInstrumentForcedPeriods          ;CONFIG SPECIFIC
+PLY_AKG_S_Or_H_ForcedPeriod:
+        ;Reads the period. A bit slow, but doesn't happen often.
+        ld a,(hl)
+        inc hl
+        exx
+                ld l,a
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                ld h,a
+        exx
+
+        ;The pitch and arpeggios have been skipped, since the period is forced, the bits must be compensated.
+        rl b
+        rl b
+        ret
+                       .endif ;PLY_AKG_UseInstrumentForcedPeriods
+        
+        ;------------------------------------------------------------------
+;Common code for SoftToHard and HardToSoft, and even Soft And Hard. The same register constraints as the methods above apply.
+;OUT:   HL' = frequency.
+;       A = shifted inverted ratio (xxx000), ready to be used in a JR to multiply/divide the frequency.
+;       B = bit states, shifted four times to the left (for StoH/HtoS, the msb will be "pitch shift?") (hardware for SoftTohard, software for HardToSoft).
+                       .if PLY_CFG_UseHardwareSounds                 ;CONFIG SPECIFIC
+PLY_AKG_StoH_HToS_SandH_Common:
+        ld e,#0x10                ;Sets the hardware volume.
+
+        ;Retrig?
+        rra
+                               .if PLY_AKG_UseRetrig_StoH_HtoS_SandH         ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_SHoHS_AfterRetrig
+        ld c,a
+        ;Retrig is only set if we are on the first step of the instrument!
+       .db #0xfd,#0x7d      ;ld a,iyl
+        or a
+        jr nz,PLY_AKG_SHoHS_RetrigEnd
+        dec a
+        ld (PLY_AKG_Retrig + PLY_AKG_Offset1b),a
+PLY_AKG_SHoHS_RetrigEnd:
+        ld a,c
+PLY_AKG_SHoHS_AfterRetrig:
+                               .endif ;PLY_AKG_UseRetrig_StoH_HtoS_SandH
+
+        ;Calculates the hardware envelope. The value given is from 8-15, but encoded as 0-7.
+        and #0b111
+        add a,#0x08
+        ld (PLY_AKG_PSGReg13_Instr + PLY_AKG_Offset1b),a
+        
+        ;Noise? If yes, reads the next byte.
+        rl b
+                               .if PLY_AKG_UseNoise_StoH_HtoS_SandH          ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_SHoHS_AfterNoise
+        ;Noise is present.
+        ld a,(hl)
+        inc hl
+        ld (PLY_AKG_PSGReg6),a
+        res PLY_AKG_BitForNoise, d              ;Noise present.
+PLY_AKG_SHoHS_AfterNoise:
+                               .endif ;PLY_AKG_UseNoise_StoH_HtoS_SandH
+
+        ;Read the next data byte.
+        ld c,(hl)               ;C = ratio, kept for later.
+        ld b,c
+        inc hl
+        
+        rl b                    ;Simple (no need to test the other bits)? The carry is transmitted to the called code below.
+        ;Call another common subcode.
+        call PLY_AKG_S_Or_H_CheckIfSimpleFirst_CalculatePeriod
+        ;Let's calculate the hardware frequency from it.
+        ld a,c                  ;Gets the ratio.
+        rla
+        rla
+        and #0b11100
+        
+        ret
+                       .endif ;PLY_CFG_UseHardwareSounds
+        
+
+        
+
+
+
+
+        
+; -----------------------------------------------------------------------------------
+; Effects management.
+; -----------------------------------------------------------------------------------
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+;All the effects code.
+PLY_AKG_EffectTable:
+                       .if PLY_CFG_UseEffect_Reset           ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_ResetFullVolume                               ;0
+       .dw PLY_AKG_Effect_Reset                                         ;1
+                       .else
+               .dw 0
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_Reset
+        
+                       .if PLY_CFG_UseEffect_SetVolume       ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_Volume                                        ;2
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+                        
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_ArpeggioTable                                 ;3
+       .dw PLY_AKG_Effect_ArpeggioTableStop                             ;4
+                       .else
+               .dw 0
+               .dw 0
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_PitchTable                                    ;5
+       .dw PLY_AKG_Effect_PitchTableStop                                ;6
+                       .else
+               .dw 0
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+                       .if PLY_AKG_UseEffect_VolumeSlide     ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_VolumeSlide                                   ;7
+       .dw PLY_AKG_Effect_VolumeSlideStop                               ;8
+                       .else
+               .dw 0
+               .dw 0
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        
+                       .if PLY_CFG_UseEffect_PitchUp         ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_PitchUp                                       ;9
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_PitchUp
+                       .if PLY_CFG_UseEffect_PitchDown        ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_PitchDown                                     ;10
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_PitchDown
+                        
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide    ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_PitchStop                                     ;11
+                       .else
+               .dw 0
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                        
+                       .if PLY_CFG_UseEffect_PitchGlide              ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_GlideWithNote                                 ;12
+       .dw PLY_AKG_Effect_GlideSpeed                                    ;13
+                       .else
+               .dw 0
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_PitchGlide
+        
+        
+                       .if PLY_CFG_UseEffect_Legato          ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_Legato                                        ;14
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_Legato
+
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed            ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_ForceInstrumentSpeed                          ;15
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+                        
+                       .if PLY_CFG_UseEffect_ForceArpeggioSpeed              ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_ForceArpeggioSpeed                            ;16
+                       .else
+               .dw 0
+                       .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+                        
+                       .if PLY_CFG_UseEffect_ForcePitchTableSpeed    ;CONFIG SPECIFIC
+       .dw PLY_AKG_Effect_ForcePitchSpeed                               ;17
+                       .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+                        ;Last effect: no need to use padding with dw.
+        
+;Effects.
+;----------------------------------------------------------------
+;For all effects:
+;IN:    DE' = Points on the data of this effect.
+;       IX = Address from which the data of the instrument are modified.
+;       IY = Address from which the data of the channels (pitch, volume, etc) are modified.
+;       HL = Must NOT be modified.
+;       WARNING, we are on auxiliary registers!
+
+;       SP = Can be modified at will.
+
+;OUT:   DE' = Points after on the data of this effect.
+;       WARNING, remains on auxiliary registers!
+;----------------------------------------------------------------
+
+                       .if PLY_CFG_UseEffect_Reset           ;CONFIG SPECIFIC
+PLY_AKG_Effect_ResetFullVolume:
+        xor a           ;The inverted volume is 0 (full volume).
+        jr PLY_AKG_Effect_ResetVolume_AfterReading
+        
+PLY_AKG_Effect_Reset:
+        ld a,(de)       ;Reads the inverted volume.
+        inc de
+PLY_AKG_Effect_ResetVolume_AfterReading:
+        ld PLY_AKG_Channel1_InvertedVolumeInteger - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        
+        ;The current pitch is reset.
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+        xor a
+        ld PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        ld PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),a
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+
+        ld a,#PLY_AKG_OPCODE_OR_A
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide        ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_IsPitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_IsPitchTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_IsArpeggioTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+                       .if PLY_AKG_UseEffect_VolumeSlide             ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_IsVolumeSlide - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_Reset
+                        
+                        
+
+                       .if PLY_CFG_UseEffect_SetVolume       ;CONFIG SPECIFIC
+PLY_AKG_Effect_Volume:
+        ld a,(de)       ;Reads the inverted volume.
+        inc de
+        
+        ld PLY_AKG_Channel1_InvertedVolumeInteger - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        
+                       .if PLY_AKG_UseEffect_VolumeSlide     ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_IsVolumeSlide - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_OR_A
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+        
+        
+                       .if PLY_AKS_UseEffect_Arpeggio        ;CONFIG SPECIFIC
+PLY_AKG_Effect_ArpeggioTable:
+        ld a,(de)       ;Reads the arpeggio table index.
+        inc de
+        
+        ;Finds the address of the Arpeggio.
+        ld l,a
+        ld h,#0x00
+        add hl,hl
+       .ifeq PLY_AKG_Rom
+PLY_AKG_ArpeggiosTable: ld bc,#0x0000
+       .else
+        ld bc,(PLY_AKG_ArpeggiosTable)
+       .endif
+        add hl,bc
+        ld c,(hl)
+        inc hl
+        ld b,(hl)
+        inc hl
+        
+        ;Reads the speed.
+        ld a,(bc)
+        inc bc
+        ld PLY_AKG_Channel1_ArpeggioTableSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy),a
+        ld PLY_AKG_Channel1_ArpeggioBaseSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy),a
+        
+        ld PLY_AKG_Channel1_ArpeggioTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),c
+        ld PLY_AKG_Channel1_ArpeggioTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),b
+        ld PLY_AKG_Channel1_ArpeggioTableBase - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy),c
+        ld PLY_AKG_Channel1_ArpeggioTableBase - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy),b
+        
+        ld PLY_AKG_Channel1_IsArpeggioTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_SCF
+        xor a
+        ld PLY_AKG_Channel1_ArpeggioTableCurrentStep - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        
+        jp PLY_AKG_Channel_RE_EffectReturn
+
+PLY_AKG_Effect_ArpeggioTableStop:
+        ld PLY_AKG_Channel1_IsArpeggioTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_OR_A
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_AKS_UseEffect_Arpeggio
+
+
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+;Pitch table. Followed by the Pitch Table index.
+PLY_AKG_Effect_PitchTable:
+        ld a,(de)       ;Reads the Pitch table index.
+        inc de
+        
+        ;Finds the address of the Pitch.
+        ld l,a
+        ld h,#0x00
+        add hl,hl
+       .ifeq PLY_AKG_Rom
+PLY_AKG_PitchesTable: ld bc,#0x0000
+       .else
+        ld bc,(PLY_AKG_PitchesTable)
+       .endif
+        add hl,bc
+        ld c,(hl)
+        inc hl
+        ld b,(hl)
+        inc hl
+        
+        ;Reads the speed.
+        ld a,(bc)
+        inc bc
+        ld PLY_AKG_Channel1_PitchTableSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        ld PLY_AKG_Channel1_PitchBaseSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        
+        ld PLY_AKG_Channel1_PitchTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),c
+        ld PLY_AKG_Channel1_PitchTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),b
+        ld PLY_AKG_Channel1_PitchTableBase - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy),c
+        ld PLY_AKG_Channel1_PitchTableBase - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy),b
+        
+        ld PLY_AKG_Channel1_IsPitchTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_SCF
+        
+        xor a
+        ld PLY_AKG_Channel1_PitchTableCurrentStep - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+        
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+;Stops the pitch table.        
+PLY_AKG_Effect_PitchTableStop:
+        ;Only the pitch is stopped, but the value remains.
+        ld PLY_AKG_Channel1_IsPitchTable - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_OR_A
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+                       .if PLY_AKG_UseEffect_VolumeSlide     ;CONFIG SPECIFIC
+;Volume slide effect. Followed by the volume, as a word.
+PLY_AKG_Effect_VolumeSlide:
+        ld a,(de)               ;Reads the slide.
+        inc de
+        ld PLY_AKG_Channel1_VolumeSlideValue - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_VolumeSlideValue - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),a
+        
+        ld PLY_AKG_Channel1_IsVolumeSlide - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_SCF
+        jp PLY_AKG_Channel_RE_EffectReturn
+        
+;Volume slide stop effect.
+PLY_AKG_Effect_VolumeSlideStop:
+        ;Only stops the slide, don't reset the value.
+        ld PLY_AKG_Channel1_IsVolumeSlide - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_OR_A
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_AKG_UseEffect_VolumeSlide
+  
+;Pitch track effect. Followed by the pitch, as a word.
+                       .if PLY_CFG_UseEffect_PitchDown        ;CONFIG SPECIFIC
+PLY_AKG_Effect_PitchDown:
+        ;Changes the sign of the operations.
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_ADD_HL_BC_MSB
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy), #PLY_AKG_OPCODE_ADD_HL_BC_LSB
+        ld PLY_AKG_Channel1_PitchTrackDecimalInstr - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_ADD_A_IMMEDIATE
+        ld PLY_AKG_Channel1_PitchTrackIntegerAddOrSub - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_INC_HL
+                       .endif ;PLY_CFG_UseEffect_PitchDown
+                       .if PLY_AKS_UseEffect_PitchUpOrDown        ;CONFIG SPECIFIC
+PLY_AKG_Effect_PitchUpDown_Common:              ;The Pitch up will jump here.
+        ;Authorizes the pitch, disabled the glide.        
+        ld PLY_AKG_Channel1_IsPitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_SCF
+                       .if PLY_CFG_UseEffect_PitchGlide           ;CONFIG SPECIFIC
+        ld PLY_AKG_Channel1_GlideDirection - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),#0x00
+                       .endif ;PLY_CFG_UseEffect_PitchGlide
+
+        ld a,(de)       ;Reads the Pitch.
+        inc de
+        ld PLY_AKG_Channel1_PitchTrackDecimalValue - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_PitchTrack - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDown
+        
+                       .if PLY_CFG_UseEffect_PitchUp        ;CONFIG SPECIFIC
+PLY_AKG_Effect_PitchUp:
+        ;Changes the sign of the operations.
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_SBC_HL_BC_MSB
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy), #PLY_AKG_OPCODE_SBC_HL_BC_LSB
+        ld PLY_AKG_Channel1_PitchTrackDecimalInstr - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_SUB_IMMEDIATE
+        ld PLY_AKG_Channel1_PitchTrackIntegerAddOrSub - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_DEC_HL
+        jr PLY_AKG_Effect_PitchUpDown_Common
+                       .endif ;PLY_CFG_UseEffect_PitchUp
+
+                       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide    ;CONFIG SPECIFIC
+;Pitch track stop. Used by Pitch up/down/glide.
+PLY_AKG_Effect_PitchStop:
+        ;Only stops the pitch, don't reset the value. No need to reset the Glide either.
+        ld PLY_AKG_Channel1_IsPitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),#PLY_AKG_OPCODE_OR_A
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+        
+                       .if PLY_CFG_UseEffect_PitchGlide        ;CONFIG SPECIFIC
+;Glide, with a note.
+PLY_AKG_Effect_GlideWithNote:
+        ;Reads the note to reach.
+        ld a,(de)
+        inc de
+        ld (PLY_AKG_Effect_GlideWithNoteSaveDE + PLY_AKG_Offset1b),de                        ;Have to save, no more registers. Damn.
+        ;Finds the period related to the note, stores it.
+        add a,a                 ;The note is 7 bits only, so it fits.
+        ld l,a
+        ld h,#0x00
+        ld bc,#PLY_AKG_PeriodTable
+        add hl,bc
+        
+        ld sp,hl
+        pop de                  ;DE = period to reach.
+        ld PLY_AKG_Channel1_GlideToReach - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),e
+        ld PLY_AKG_Channel1_GlideToReach - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),d
+        
+        ;Calculates the period of the current note to calculate the difference.
+        ld a,PLY_AKG_Channel1_TrackNote - PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress + PLY_AKG_Offset1b (ix)
+        add a,a
+        ld l,a
+        ld h,#0x00
+        add hl,bc
+        
+        ld sp,hl
+        pop hl                  ;HL = current period.
+        ;Adds the current Track Pitch to have the current period, else the direction may be biased.
+        ld c,PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy)
+        ld b,PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy)
+        add hl,bc
+        
+        ;What is the difference?
+        or a
+        sbc hl,de
+       .ifeq PLY_AKG_Rom
+PLY_AKG_Effect_GlideWithNoteSaveDE: ld de,#0x0000                   ;Retrieves DE. This does not modified the Carry.
+       .else
+        ld de,(PLY_AKG_Effect_GlideWithNoteSaveDE)
+       .endif
+        jr c,PLY_AKG_Effect_Glide_PitchDown
+        ;Pitch up.
+        ld PLY_AKG_Channel1_GlideDirection - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),#0x01
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_SBC_HL_BC_MSB
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy), #PLY_AKG_OPCODE_SBC_HL_BC_LSB
+        ld PLY_AKG_Channel1_PitchTrackDecimalInstr - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_SUB_IMMEDIATE
+        ld PLY_AKG_Channel1_PitchTrackIntegerAddOrSub - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_DEC_HL
+        
+        ;Reads the Speed, which is actually the "pitch".
+PLY_AKG_Effect_Glide_ReadSpeed:
+PLY_AKG_Effect_GlideSpeed:                      ;This is an effect.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_PitchTrackDecimalValue - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a      ;No offset, the value is directly targeted.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_PitchTrack - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        
+        ;Enables the pitch, as the Glide relies on it. The Glide is enabled below, via its direction.
+        ld a,#PLY_AKG_OPCODE_SCF
+        ld PLY_AKG_Channel1_IsPitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+
+        jp PLY_AKG_Channel_RE_EffectReturn
+PLY_AKG_Effect_Glide_PitchDown:
+        ;Pitch down.
+        ld PLY_AKG_Channel1_GlideDirection - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),#0x02
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_ADD_HL_BC_MSB
+        ld PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 1 (iy), #PLY_AKG_OPCODE_ADD_HL_BC_LSB
+        ld PLY_AKG_Channel1_PitchTrackDecimalInstr - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_ADD_A_IMMEDIATE
+        ld PLY_AKG_Channel1_PitchTrackIntegerAddOrSub - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + 0 (iy), #PLY_AKG_OPCODE_INC_HL
+        jr PLY_AKG_Effect_Glide_ReadSpeed
+                       .endif ;PLY_CFG_UseEffect_PitchGlide
+        
+        
+                       .if PLY_CFG_UseEffect_Legato          ;CONFIG SPECIFIC
+;Legato. Followed by the note to play.        
+PLY_AKG_Effect_Legato:
+        ;Reads and sets the new note to play.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_TrackNote - PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress + PLY_AKG_Offset1b (ix),a
+        
+        ;Stops the Pitch effect, resets the Pitch.
+                               .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide    ;CONFIG SPECIFIC
+        ld a,#PLY_AKG_OPCODE_OR_A
+        ld PLY_AKG_Channel1_IsPitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+        xor a
+        ld PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b (iy),a
+        ld PLY_AKG_Channel1_Pitch - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress + PLY_AKG_Offset1b + 1 (iy),a
+                               .endif ;PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+                                
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_Legato
+
+
+                       .if PLY_CFG_UseEffect_ForceInstrumentSpeed    ;CONFIG SPECIFIC
+;Forces the Instrument Speed. Followed by the speed.
+PLY_AKG_Effect_ForceInstrumentSpeed:
+        ;Reads and sets the new speed.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_InstrumentSpeed - PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress + PLY_AKG_Offset1b (ix),a
+        
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+        
+                        
+                       .if PLY_CFG_UseEffect_ForceArpeggioSpeed      ;CONFIG SPECIFIC
+;Forces the Arpeggio Speed. Followed by the speed.
+PLY_AKG_Effect_ForceArpeggioSpeed:
+                               .if PLY_AKS_UseEffect_Arpeggio                ;CONFIG SPECIFIC
+                                ;Is IT possible to use a Force Arpeggio even if there is no Arpeggio. Unlikely, but...
+        ;Reads and sets the new speed.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_ArpeggioTableSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                               .else
+                inc de
+                               .endif ;PLY_AKS_UseEffect_Arpeggio
+        
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+
+                       .if PLY_CFG_UseEffect_ForcePitchTableSpeed    ;CONFIG SPECIFIC
+;Forces the Pitch Speed. Followed by the speed.
+PLY_AKG_Effect_ForcePitchSpeed:
+                               .if PLY_CFG_UseEffect_PitchTable                ;CONFIG SPECIFIC
+                                ;Is IT possible to use a Force Arpeggio even if there is no Arpeggio. Unlikely, but...
+        ;Reads and sets the new speed.
+        ld a,(de)
+        inc de
+        ld PLY_AKG_Channel1_PitchTableSpeed - PLY_AKG_Channel1_SoundStream_RelativeModifierAddress (iy),a
+                               .else
+                inc de
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+        
+        jp PLY_AKG_Channel_RE_EffectReturn
+                       .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+        
+                       .endif ;PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+
+        
+
+                       .if PLY_CFG_UseEventTracks            ;CONFIG SPECIFIC
+                       .ifeq PLY_AKG_Rom
+PLY_AKG_Event: .db 0         ;Possible event sent from the music for the caller to interpret.
+                       .endif
+                       .endif ;PLY_CFG_UseEventTracks
+
+
+
+
+;The period table for each note (from 0 to 127 included).
+PLY_AKG_PeriodTable:
+       .if PLY_AKG_HARDWARE_CPC + PLY_AKG_HARDWARE_ENTERPRISE
+        ;PSG running to 1000000 Hz.
+       .dw 3822,3608,3405,3214,3034,2863,2703,2551,2408,2273,2145,2025          ;0
+       .dw 1911,1804,1703,1607,1517,1432,1351,1276,1204,1136,1073,1012          ;12
+       .dw 956,902,851,804,758,716,676,638,602,568,536,506                      ;24
+       .dw 478,451,426,402,379,358,338,319,301,284,268,253                      ;36
+       .dw 239,225,213,201,190,179,169,159,150,142,134,127                      ;48
+       .dw 119,113,106,100,95,89,84,80,75,71,67,63                              ;60
+       .dw 60,56,53,50,47,45,42,40,38,36,34,32                                  ;72
+       .dw 30,28,27,25,24,22,21,20,19,18,17,16                                  ;84
+       .dw 15,14,13,13,12,11,11,10,9,9,8,8                                      ;96
+       .dw 7,7,7,6,6,6,5,5,5,4,4,4                                              ;108
+       .dw 4,4,3,3,3,3,3,2 ;,2,2,2,2                                            ;120 -> 127
+       .endif
+       .if PLY_AKG_HARDWARE_SPECTRUM + PLY_AKG_HARDWARE_MSX
+        ;PSG running to 1773400 Hz.
+	dw 6778, 6398, 6039, 5700, 5380, 5078, 4793, 4524, 4270, 4030, 3804, 3591	; Octave 0
+	dw 3389, 3199, 3019, 2850, 2690, 2539, 2397, 2262, 2135, 2015, 1902, 1795	; Octave 1
+	dw 1695, 1599, 1510, 1425, 1345, 1270, 1198, 1131, 1068, 1008, 951, 898	; Octave 2
+	dw 847, 800, 755, 712, 673, 635, 599, 566, 534, 504, 476, 449	; Octave 3
+	dw 424, 400, 377, 356, 336, 317, 300, 283, 267, 252, 238, 224	; Octave 4
+	dw 212, 200, 189, 178, 168, 159, 150, 141, 133, 126, 119, 112	; Octave 5
+	dw 106, 100, 94, 89, 84, 79, 75, 71, 67, 63, 59, 56	; Octave 6
+	dw 53, 50, 47, 45, 42, 40, 37, 35, 33, 31, 30, 28	; Octave 7
+	dw 26, 25, 24, 22, 21, 20, 19, 18, 17, 16, 15, 14	; Octave 8
+	dw 13, 12, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7	; Octave 9
+	dw 7, 6, 6, 6, 5, 5, 5, 4	; Octave 10
+       .endif
+       .if PLY_AKG_HARDWARE_PENTAGON
+        ;PSG running to 1750000 Hz.
+       .dw 6689, 6314, 5959, 5625, 5309, 5011, 4730, 4464, 4214, 3977, 3754, 3543	; Octave 0
+	dw 3344, 3157, 2980, 2812, 2655, 2506, 2365, 2232, 2107, 1989, 1877, 1772	; Octave 1
+	dw 1672, 1578, 1490, 1406, 1327, 1253, 1182, 1116, 1053, 994, 939, 886	; Octave 2
+	dw 836, 789, 745, 703, 664, 626, 591, 558, 527, 497, 469, 443	; Octave 3
+	dw 418, 395, 372, 352, 332, 313, 296, 279, 263, 249, 235, 221	; Octave 4
+	dw 209, 197, 186, 176, 166, 157, 148, 140, 132, 124, 117, 111	; Octave 5
+	dw 105, 99, 93, 88, 83, 78, 74, 70, 66, 62, 59, 55	; Octave 6
+	dw 52, 49, 47, 44, 41, 39, 37, 35, 33, 31, 29, 28	; Octave 7
+	dw 26, 25, 23, 22, 21, 20, 18, 17, 16, 16, 15, 14	; Octave 8
+	dw 13, 12, 12, 11, 10, 10, 9, 9, 8, 8, 7, 7	; Octave 9
+	dw 7, 6, 6, 5, 5, 5, 5, 4	; Octave 10
+       .endif
+
+
+
+;Buffer used for the ROM player. This part needs to be set to RAM. PLY_AKG_ROM_Buffer must be set.
+       .if PLY_AKG_Rom
+        
+        PLY_AKG_BufferOffset = 0
+
+;Generic data.
+       .if PLY_CFG_UseRetrig
+.equ PLY_AKG_Event                                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_CurrentSpeed                           , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_BaseNoteIndex                          , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_PatternDecreasingHeight                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_TickDecreasingCounter                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_CFG_UseSpeedTracks
+.equ PLY_AKG_SpeedTrack_WaitCounter                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEventTracks
+.equ PLY_AKG_EventTrack_WaitCounter                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseHardwareSounds
+.equ PLY_AKG_PSGReg13_OldValue                      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_PSGReg13_Instr                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+               .if PLY_CFG_UseRetrig
+.equ PLY_AKG_Retrig                                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+               .endif
+       .endif
+.equ PLY_AKG_Channel_RE_ReadNextEffectInBlock       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+        ;Words
+.equ PLY_AKG_ReadLinker_PtLinker                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_CFG_UseSpeedTracks
+.equ PLY_AKG_SpeedTrack_PtTrack                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_CFG_UseEventTracks
+.equ PLY_AKG_EventTrack_PtTrack                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_ArpeggiosTable                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_PitchesTable                           , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_InstrumentsTable                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_CFG_UseEffects
+        ;For ROM, only one is used, the second is the same, but it makes it faster on non-ROM as it avoid reading the memory.
+.equ PLY_AKG_Channel_ReadEffects_EffectBlocks1      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_EmptyInstrumentDataPt                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_SaveSp                                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg01_Instr                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg23_Instr                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg45_Instr                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg6_8_Instr                        , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg6                                , PLY_AKG_PSGReg6_8_Instr + 0
+.equ PLY_AKG_PSGReg8                                , PLY_AKG_PSGReg6_8_Instr + 1
+.equ PLY_AKG_PSGReg9_10_Instr                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_PSGReg9                                , PLY_AKG_PSGReg9_10_Instr + 0
+.equ PLY_AKG_PSGReg10                               , PLY_AKG_PSGReg9_10_Instr + 1
+       .if PLY_CFG_UseHardwareSounds
+.equ PLY_AKG_PSGHardwarePeriod_Instr                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_Channel_ReadEffects_EndJumpInstrAndAddress , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3      ;3 bytes. JP xxxx
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Effect_GlideWithNoteSaveDE             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_TempPlayInstrumentJumpInstrAndAddress  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3      ;3 bytes. JP xxxx
+
+        ;Section specific to each channel.
+.equ PLY_AKG_Channel1_SoundStream_RelativeModifierAddress       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+.equ PLY_AKG_Channel1_PlayInstrument_RelativeModifierAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+
+        ;Bytes
+       .if PLY_CFG_UseTranspositions
+.equ PLY_AKG_Channel1_Transposition                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel1_WaitCounter                   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKG_UseEffect_VolumeSlide
+.equ PLY_AKG_Channel1_IsVolumeSlide                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel1_IsArpeggioTable               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel1_IsPitchTable                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel1_IsPitch                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_ForceInstrumentSpeed
+.equ PLY_AKG_Channel1_InstrumentOriginalSpeed       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel1_InstrumentSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_InstrumentStep                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel1_ArpeggioTableCurrentStep      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_GeneratedCurrentArpNote       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_ArpeggioBaseSpeed             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_ArpeggioTableSpeed            , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel1_PitchTableCurrentStep         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_PitchBaseSpeed                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_PitchTableSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel1_PitchTrackDecimal             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_PitchTrackDecimalCounter      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel1_TrackNote                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel1_GlideDirection                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel1_GeneratedCurrentInvertedVolume    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+        ;Words
+.equ PLY_AKG_Channel1_PtTrack                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel1_ArpeggioTable                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_ArpeggioTableBase             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel1_PitchTrack                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel1_PitchTable                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_PitchTableBase                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_Channel1_EffectBlocks1                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_EffectBlocks2                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_InvertedVolumeIntegerAndDecimal   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_Pitch                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_PtInstrument                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_PtBaseInstrument              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_VolumeSlideValue              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel1_GlideToReach                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_Glide_SaveHL                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel1_PitchTrackDecimalInstrAndValue    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2     ;Add/sub b, xx.
+.equ PLY_AKG_Channel1_PitchTrackDecimalInstr        , PLY_AKG_Channel1_PitchTrackDecimalInstrAndValue + 0
+.equ PLY_AKG_Channel1_PitchTrackDecimalValue        , PLY_AKG_Channel1_PitchTrackDecimalInstrAndValue + 1
+        ;The add/sub must be followed by the return JP.
+.equ PLY_AKG_Channel1_PitchTrackDecimalInstrAndValueReturnJp    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3  ;JP xxxx.
+       .endif
+        
+.equ PLY_AKG_Channel1_GeneratedCurrentPitch         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel1_PitchTrackAddOrSbc_16bits     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+        ;3 bytes.
+.equ PLY_AKG_Channel1_PitchTrackAfterAddOrSbcJumpInstrAndAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+.equ PLY_AKG_Channel1_PitchTrackIntegerAddOrSub     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+       .endif
+
+.equ PLY_AKG_Channel1_SoundStream_RelativeModifierAddress       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+.equ PLY_AKG_Channel2_PlayInstrument_RelativeModifierAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+
+        ;Bytes
+       .if PLY_CFG_UseTranspositions
+.equ PLY_AKG_Channel2_Transposition                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel2_WaitCounter                   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKG_UseEffect_VolumeSlide
+.equ PLY_AKG_Channel2_IsVolumeSlide                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel2_IsArpeggioTable               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel2_IsPitchTable                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel2_IsPitch                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_ForceInstrumentSpeed
+.equ PLY_AKG_Channel2_InstrumentOriginalSpeed       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel2_InstrumentSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_InstrumentStep                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel2_ArpeggioTableCurrentStep      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_GeneratedCurrentArpNote       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_ArpeggioBaseSpeed             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_ArpeggioTableSpeed            , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel2_PitchTableCurrentStep         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_PitchBaseSpeed                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_PitchTableSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel2_PitchTrackDecimal             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_PitchTrackDecimalCounter      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel2_TrackNote                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel2_GlideDirection                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel2_GeneratedCurrentInvertedVolume    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+        ;Words
+.equ PLY_AKG_Channel2_PtTrack                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel2_ArpeggioTable                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_ArpeggioTableBase             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel2_PitchTrack                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel2_PitchTable                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_PitchTableBase                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_Channel2_EffectBlocks1                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_EffectBlocks2                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_InvertedVolumeIntegerAndDecimal   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_Pitch                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_PtInstrument                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_PtBaseInstrument              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_VolumeSlideValue              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel2_GlideToReach                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_Glide_SaveHL                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel2_PitchTrackDecimalInstrAndValue    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2     ;Add/sub b, xx.
+.equ PLY_AKG_Channel2_PitchTrackDecimalInstr        , PLY_AKG_Channel2_PitchTrackDecimalInstrAndValue + 0
+.equ PLY_AKG_Channel2_PitchTrackDecimalValue        , PLY_AKG_Channel2_PitchTrackDecimalInstrAndValue + 1
+        ;The add/sub must be followed by the return JP.
+.equ PLY_AKG_Channel2_PitchTrackDecimalInstrAndValueReturnJp    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3  ;JP xxxx.
+       .endif
+        
+.equ PLY_AKG_Channel2_GeneratedCurrentPitch         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel2_PitchTrackAddOrSbc_16bits     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+        ;3 bytes.
+.equ PLY_AKG_Channel2_PitchTrackAfterAddOrSbcJumpInstrAndAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+.equ PLY_AKG_Channel2_PitchTrackIntegerAddOrSub     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+       .endif
+
+.equ PLY_AKG_Channel1_SoundStream_RelativeModifierAddress       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+.equ PLY_AKG_Channel3_PlayInstrument_RelativeModifierAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset
+
+        ;Bytes
+       .if PLY_CFG_UseTranspositions
+.equ PLY_AKG_Channel3_Transposition                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel3_WaitCounter                   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKG_UseEffect_VolumeSlide
+.equ PLY_AKG_Channel3_IsVolumeSlide                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel3_IsArpeggioTable               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel3_IsPitchTable                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel3_IsPitch                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_ForceInstrumentSpeed
+.equ PLY_AKG_Channel3_InstrumentOriginalSpeed       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel3_InstrumentSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_InstrumentStep                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel3_ArpeggioTableCurrentStep      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_GeneratedCurrentArpNote       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_ArpeggioBaseSpeed             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_ArpeggioTableSpeed            , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel3_PitchTableCurrentStep         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_PitchBaseSpeed                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_PitchTableSpeed               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel3_PitchTrackDecimal             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_PitchTrackDecimalCounter      , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel3_TrackNote                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel3_GlideDirection                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+.equ PLY_AKG_Channel3_GeneratedCurrentInvertedVolume    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+        ;Words
+.equ PLY_AKG_Channel3_PtTrack                       , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_Arpeggio
+.equ PLY_AKG_Channel3_ArpeggioTable                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_ArpeggioTableBase             , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel3_PitchTrack                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKG_Channel3_PitchTable                    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_PitchTableBase                , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+.equ PLY_AKG_Channel3_EffectBlocks1                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_EffectBlocks2                 , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_InvertedVolumeIntegerAndDecimal   , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_Pitch                         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_PtInstrument                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_PtBaseInstrument              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_VolumeSlideValue              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKG_Channel3_GlideToReach                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_Glide_SaveHL                  , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .endif
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel3_PitchTrackDecimalInstrAndValue    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2     ;Add/sub b, xx.
+.equ PLY_AKG_Channel3_PitchTrackDecimalInstr        , PLY_AKG_Channel3_PitchTrackDecimalInstrAndValue + 0
+.equ PLY_AKG_Channel3_PitchTrackDecimalValue        , PLY_AKG_Channel3_PitchTrackDecimalInstrAndValue + 1
+        ;The add/sub must be followed by the return JP.
+.equ PLY_AKG_Channel3_PitchTrackDecimalInstrAndValueReturnJp    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3  ;JP xxxx.
+       .endif
+        
+.equ PLY_AKG_Channel3_GeneratedCurrentPitch         , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+       .if PLY_AKS_UseEffect_PitchUpOrDownOrGlide
+.equ PLY_AKG_Channel3_PitchTrackAddOrSbc_16bits     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+        ;3 bytes.
+.equ PLY_AKG_Channel3_PitchTrackAfterAddOrSbcJumpInstrAndAddress    , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+.equ PLY_AKG_Channel3_PitchTrackIntegerAddOrSub     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_PitchTrackIntegerAfterAddOrSubJumpInstrAndAddress , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3     ;3 bytes. JP xxxx.
+       .endif
+
+        ;The buffers for sound effects (if any), for each channel. They are treated apart, because they must be consecutive.
+       .if PLY_AKG_MANAGE_SOUND_EFFECTS
+.equ PLY_AKG_PtSoundEffectTable                     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_SoundEffectData               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel1_SoundEffectInvertedVolume     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_SoundEffectCurrentStep        , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel1_SoundEffectSpeed              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+               PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3 ;Padding of 3, but only necessary for channel 1 and 2.
+.equ PLY_AKG_Channel2_SoundEffectData               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel2_SoundEffectInvertedVolume     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_SoundEffectCurrentStep        , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel2_SoundEffectSpeed              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+               PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 3 ;Padding of 3, but only necessary for channel 1 and 2.
+.equ PLY_AKG_Channel3_SoundEffectData               , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 2
+.equ PLY_AKG_Channel3_SoundEffectInvertedVolume     , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_SoundEffectCurrentStep        , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+.equ PLY_AKG_Channel3_SoundEffectSpeed              , PLY_AKG_ROM_Buffer + PLY_AKG_BufferOffset : PLY_AKG_BufferOffset = PLY_AKG_BufferOffset + 1
+       .endif
+
+
+       .endif ;PLY_AKG_Rom
+
+
+PLY_AKG_End:
+
+; =============================================================================
+ .if PLY_AKG_HARDWARE_ENTERPRISE
+  .ifeq NO_ENVELOPE_IRQ
+
+envelopeInterrupt:
+
+    .if ENABLE_1000HZ_IRQ 
+        ld    a, #0x13
+        out   (#0xb4), a
+    .endif
+        push  hl
+        push  bc
+envelopeInterrupt.l1:    ld    hl,#0x0000                 ; * envelope counter
+      .if ENABLE_1000HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #500) / #1000)
+      .else
+        .if ENABLE_300HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #150) / #300)
+        .else
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #25) / #50)
+        .endif
+      .endif
+        add   hl, bc
+envelopeInterrupt.l2:    jr    c, envelopeInterrupt.l19                   ; * JR if envelope is stopped
+envelopeInterrupt.l3:    ld    bc, #0xffff               ; * envelope frequency
+envelopeInterrupt.l4:    ld    a,#0x00                   ; * envelope state (0 to 15)
+envelopeInterrupt.l5:    dec   a                         ; * envelope direction (INC A or DEC A)
+        add   hl, bc
+        jr    nc, envelopeInterrupt.l5
+        ld    (envelopeInterrupt.l1 + 1), hl
+        cp    #0x10
+envelopeInterrupt.l6:    jr    nc, envelopeInterrupt.l21                  ; * envelope mode
+envelopeInterrupt.l7:    ld    (envelopeInterrupt.l4 + 1), a
+envelopeInterrupt.l8:    add   a,#<ayVolumeTable
+        ld    l, a
+        adc   a, #>ayVolumeTable
+        sub   l
+        ld    h,a
+        or    a
+envelopeInterrupt.l9:
+        ld    a, (hl)
+        pop   bc
+envelopeInterrupt.l10:   jr    envelopeInterrupt.l12                      ; * envelope enable mode
+envelopeInterrupt.l11:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channel A only
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l12:   pop   hl
+        ret
+envelopeInterrupt.l13:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and B
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l14:
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; envelope on channel B only (Carry=0)
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l15:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l16:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channel C only
+        pop   hl
+        ret
+envelopeInterrupt.l17:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A, B, and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l18:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channels B and C
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l19:   ld    (envelopeInterrupt.l1 + 1), hl
+        pop   bc
+        pop   hl
+        ret
+envelopeInterrupt.l20:   ld    l, #<(ayVolumeTable + 15)       ; envelope modes 11 and 13
+        .db  #0x01                      ; = LD BC, nnnn
+envelopeInterrupt.l21:   ld    l, #<ayVolumeTable      ; envelope modes 0 to 7, 9, and 15
+        ld    h, #>ayVolumeTable
+        ld    a, #0x18                  ; = JR +nn
+        ld    (envelopeInterrupt.l2), a                  ; stop envelope
+        jp    envelopeInterrupt.l9
+envelopeInterrupt.l22:   and   #0x0f                     ; envelope modes 8 and 12
+        jp    envelopeInterrupt.l7
+envelopeInterrupt.l23:   jp    m, envelopeInterrupt.l24                   ; envelope modes 10 and 14
+        xor   #0x1f
+        ld    l, a
+        ld    h,#0x3d                   ; set direction to DEC A
+        ld    (envelopeInterrupt.l4 + 1), hl             ; assume .l5 = .l4 + 2
+        jp    envelopeInterrupt.l8
+envelopeInterrupt.l24:   cpl
+        ld    l, a
+        ld    h,#0x3c                   ; set direction to INC A
+        ld    (envelopeInterrupt.l4 + 1), hl
+        jp    envelopeInterrupt.l8
+
+  .endif
+; -----------------------------------------------------------------------------
+
+ayVolumeTable:
+        .db   0,  1,  2,  3,  4,  5,  6,  9
+        .db  12, 17, 22, 28, 36, 44, 53, 63
+
+ayRegisterMaskTable:
+        .db  #0xff,#0x0f,#0xff,#0x0f,#0xff,#0x0f,#0x1f,#0xff
+        .db  #0x1f,#0x1f,#0x1f,#0xff,#0xff,#0x0f,#0xff,#0xff
+
+ayRegisters:
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+
+ayRegWriteTable:
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l7 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l5 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l9 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l10 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l11 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l15 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+
+
+    .ifeq NO_ENVELOPE_IRQ
+
+envelopeModeTable:
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+
+envelopeEnableTable:
+        .db  <(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l11 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l14 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l13 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l16 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l15 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l18 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l17 - envelopeInterrupt.l11)
+
+    .endif
+
+setChannelAmplitude:
+        cp    #0x10
+        jr    c, setChannelAmplitude.l1
+    .ifeq NO_ENVELOPE_IRQ
+        res   3, b
+        ld    a, (envelopeInterrupt.l4 + 1)
+    .else
+        xor   a
+    .endif
+setChannelAmplitude.l1:                                    ; HL = ayRegWriteTable + (8 + channel)
+        add     a,#<ayVolumeTable
+        ld      l,a
+        adc     a,#>ayVolumeTable
+        sub     l
+        ld      h,a
+    .ifne ENABLE_STEREO
+        bit     0,c                     ; Z = 0: channel B, Z = 1: channel A, C
+    .endif
+        ld    a, (hl)
+    .ifne ENABLE_STEREO 
+        jr    z, setChannelAmplitude.l2
+        or    a
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (c), a
+        set   2, c
+setChannelAmplitude.l2:    out   (c), a
+    .ifeq NO_ENVELOPE_IRQ
+setChannelAmplitude.l3:    ld      a,#0x00                   ; *
+        ld      c,a
+        or      b
+        cp      #0x08
+        jr      c,setChannelAmplitude.l4
+        xor     b
+setChannelAmplitude.l4:    cp      c
+        jr      z, setChannelAmplitude.l5                    ; envelope enable bit has not changed ?
+        ld      (setChannelAmplitude.l3+1), a
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeEnableTable
+        add     hl,bc
+        ld      a,(hl)
+        ld      (envelopeInterrupt.l10+1),a
+    .endif
+setChannelAmplitude.l5:    pop   bc
+;        pop   af
+        ret
+
+setChannelAFreq:
+        ld    c, #0xa0 + (ayDaveChnA * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters)
+    .if toneAndNoiseModeAtone
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+        and   #0x04
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeAnoise
+        bit   3, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeAtnns
+        and   #0x09
+        jr    z, setToneGenAAsNoise     ; tone + noise generator enabled ?
+        cp    #0x08
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnA * 2)), a
+        out   (#0xa1 + (ayDaveChnA * 2)), a
+        ret
+
+setChannelBFreq:
+        ld    c, #0xa0 + (ayDaveChnB * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 2)
+    .if toneAndNoiseModeBtone
+        bit   1, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x10
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeBnoise
+        bit   4, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x02
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeBtnns
+        and   #0x12
+        jr    z, setToneGenBAsNoise     ; tone + noise generator enabled ?
+        cp    #0x10
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnB * 2)), a
+        out   (#0xa1 + (ayDaveChnB * 2)), a
+        ret
+
+setChannelCFreq:
+        ld    c, #0xa0 + (ayDaveChnC * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 4)
+    .if toneAndNoiseModeCtone
+        bit   2, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x20
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeCnoise
+        bit   5, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x04
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeCtnns
+        and   #0x24
+        jr    z, setToneGenCAsNoise     ; tone + noise generator enabled ?
+        cp    #0x20
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnC * 2)), a
+        out   (#0xa1 + (ayDaveChnC * 2)), a
+        ret
+
+    .if toneAndNoiseModeAtnns
+setToneGenAAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeBtnns
+setToneGenBAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeCtnns
+setToneGenCAsNoise:
+        ld    a,#0x30
+        .db   #0xfe                      ; = CP nn
+    .endif
+
+setToneGenFrequency:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        xor   a
+    .endif
+
+setToneGenFrequency_:
+        add   hl, hl
+        dec   hl
+        bit   4, h
+        jr    nz, setToneGenFrequency_.l2                   ; overflow ?
+setToneGenFrequency_.l1:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        or    h                         ; non-zero for tone + noise
+    .endif
+        out   (c), l
+        inc   c
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        out   (c), a
+    .else
+        out   (c), h
+    .endif
+        ret
+setToneGenFrequency_.l2:    ld    l,#0x01
+        inc   h
+        jr    z, setToneGenFrequency_.l1
+        ld    hl,#0x0fff
+        jp    setToneGenFrequency_.l1
+
+    .if (toneAndNoiseModeAtnns * toneAndNoiseModeAnoise)
+setToneGenAAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeBtnns * toneAndNoiseModeBnoise)
+setToneGenBAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeCtnns * toneAndNoiseModeCnoise)
+setToneGenCAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+setNoiseGenFreq:
+        ld    h,#0x30
+
+setNoiseGenFreq_:
+        ld    a, (ayRegisters + 6)
+        add   a, a
+        add   a, a
+        jr    nz, setNoiseGenFreq_.l1
+        ld    a,#0x04
+setNoiseGenFreq_.l1:    dec   a
+        out   (c), a
+        inc   c
+        out   (c), h
+        ret
+; -----------------------------------------------------------------------------
+; reset AY-3-8912 emulation
+
+ayReset:
+;        di
+        ld    hl, #ayRegisters - 1
+        ld    bc, #0x10af
+        xor   a
+ayReset.l1:    inc   hl
+        out   (c), a
+        ld    (hl), a
+        dec   c
+        djnz  ayReset.l1
+        res   3, l                      ; register 7
+        ld    (hl), #0x3f
+    .ifeq NO_ENVELOPE_IRQ
+        ld    (envelopeInterrupt.l4 + 1), a
+        ld    a, #0x18                    ; = JR +nn
+        ld    (envelopeInterrupt.l2), a
+        ld    hl, #MIN_ENV_FREQVAL
+        ld    (envelopeInterrupt.l3 + 1), hl
+        ld    a, #<(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        ld    (envelopeInterrupt.l10 + 1), a
+        xor     a
+        ld    (setChannelAmplitude.l3 + 1), a
+    .endif
+        ld    a, #0x04
+        out   (#0xbf), a
+        ld    c, b
+        call  ayReset.l2
+        ld    l, b
+        call  ayReset.l2                       ; L = 1 kHz interrupts per video frame
+        ld    a, #25
+        cp    l
+        ld    a, #0x03
+        rla
+        rla
+        out   (#0xbf), a                 ; Z80 <= 5 MHz: 04h, > 5 MHz: 06h
+        ld    a, #0x10                    ; use 17-bit noise generator
+        out   (#0xa6), a
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, #0x33
+    .else
+        ld    a, #0x30
+    .endif
+        out   (#0xb4), a                 ; enable 1 kHz and video interrupts
+        ret
+ayReset.l2:    in    a, (#0xb4)
+        and   #0x11
+        or    c
+        rlca
+        and   #0x66
+        ld    c, a                      ; -ON--ON-
+        rlca                            ; ON--ON--
+        xor   c                         ; OXN-OXN-
+        bit   2, a
+        jr    z, ayReset.l3
+        inc   l                         ; 1 kHz interrupt
+ayReset.l3:    cp    #0xc0
+        jr    c, ayReset.l2                    ; not 50 Hz interrupt ?
+        ret
+
+;; read AY-3-8912 register A, returning the value in A
+;
+;ayRegisterRead:
+;        and   0fh
+;        or    <ayRegisters
+;        ld    l, a
+;        ld    h, >ayRegisters
+;        ld    a, (hl)
+;        or    a
+;        ret
+
+; write C to AY-3-8912 register A
+; NOTE: interrupts may be enabled on return
+ayRegisterWriteE:
+        ld      a,e
+
+ayRegisterWrite:
+        ld      b,#0x00
+        ld      hl,#ayRegisterMaskTable
+        add     hl,bc
+        inc     c
+        and     (hl)
+        push    bc
+        ld      c,#0x10
+        add     hl,bc                   ;ayRegisters
+        cp      (hl)
+        jr      z,ayRegisterWrite.l2                   ; register not changed ?
+        ld      (hl),a
+        add     hl,bc                   ;ayRegWriteTable
+        ld      a,(hl)
+        ld      (ayRegisterWrite.l1+1),a
+ayRegisterWrite.l1:    jr      ayRegisterWrite.l8                     ; *
+ayRegisterWrite.l2:    
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, l
+        xor   #<(ayRegisters + 13)
+        jr    z, ayRegisterWrite.l16                   ; envelope restart ?
+    .endif
+        pop     bc
+;        pop   af
+        ret
+ayRegisterWrite.l3:    call  setChannelAFreq           ; tone generator A frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l4:    call  setChannelBFreq           ; tone generator B frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l5:    call  setChannelAFreq           ; mixer
+        call  setChannelBFreq
+ayRegisterWrite.l6:    call  setChannelCFreq           ; tone generator C frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l7:    ld    a, (ayRegisters + 7)      ; noise generator frequency
+    .if toneAndNoiseModeAnoise
+        ld    b, a
+        and   #0x08
+    .else
+        xor   #0x07
+        ld    b, a
+        and   #0x09
+    .endif
+        call  z, setChannelAFreq
+    .if toneAndNoiseModeBnoise
+        bit   4, b
+    .else
+        ld    a, b
+        and   #0x12
+    .endif
+        call  z, setChannelBFreq
+    .if toneAndNoiseModeCnoise
+        bit   5, b
+    .else
+        ld    a, b
+        and   #0x24
+    .endif
+        call  z, setChannelCFreq
+ayRegisterWrite.l8:    pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l9:    ld    a, (ayRegisters + 8)      ; channel A amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x09a8 + ayDaveChnA
+    .else
+        ld    c,#0xa8 + ayDaveChnA
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l10:   ld    a, (ayRegisters + 9)      ; channel B amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0aa8 + ayDaveChnB
+    .else
+        ld    c,#0xa8 + ayDaveChnB
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l11:   ld    a, (ayRegisters + 10)     ; channel C amplitude / envelope enable
+    .ifeq ENABLE_STEREO
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0ca8 + ayDaveChnC
+      .else
+        ld    c,#0xa8 + ayDaveChnC
+      .endif
+    .else
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0cac + ayDaveChnC
+      .else
+        ld    c,#0xac + ayDaveChnC
+      .endif
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l12:
+    .ifeq NO_ENVELOPE_IRQ
+        ld    hl, (ayRegisters + 11)    ; envelope generator frequency
+        ld    a, h
+        or    a
+        jr    nz, ayRegisterWrite.l13
+        ld    a, #MIN_ENV_FREQVAL
+        cp    l
+        jr    c, ayRegisterWrite.l13
+        ld    l, a                      ; limit envelope frequency
+ayRegisterWrite.l13:   ld    (envelopeInterrupt.l3 + 1), hl
+        pop   bc
+;        pop   af
+        ret
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+ayRegisterWrite.l15:                                   ; envelope generator mode / restart
+    .ifeq NO_ENVELOPE_IRQ
+ayRegisterWrite.l16:   ld      hl,(envelopeInterrupt.l3+1)
+        ld      (envelopeInterrupt.l1+1),hl
+        ld      a,#0x38                     ; = JR C, +nn
+        ld      (envelopeInterrupt.l2),a    ; enable envelope
+        ld      a,(ayRegisters+13)
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeModeTable
+        add     hl,bc
+        and     #0x04
+        ld    a, (hl)
+        ld    (envelopeInterrupt.l6 + 1), a
+        ld    hl,#0x3c00                    ; INC A, state = 0
+        ld    a, l
+        jr    nz, ayRegisterWrite.l17                      ; attack ?
+        ld    hl,#0x3d0f                    ; DEC A, state = 15
+        ld    a,#0x3f
+ayRegisterWrite.l17:   ld    (envelopeInterrupt.l4 + 1), hl    ; assume eInt.l5 = eInt.l4 + 2
+        call  ayRegisterWrite.l18
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l18:   call  envelopeInterrupt.l10     ; NOTE: this will pop return address
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+
+ .endif
+; =============================================================================
+
+
+   ;PLY_UseEnterprise_End 
+ 
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg_SoundEffects.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg_SoundEffects.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg_SoundEffects.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg_SoundEffects.src	2025-01-11 16:57:38
@@ -0,0 +1,636 @@
+;       Player of sound effects, for AKG (Generic) the player, format V2 (including speed).
+;       This file is meant to be included to the AKG player, do not use it stand-alone.
+;      if you want sound effects without music, there is a specific player for that.
+
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKG_SFXInit
+   ;;
+   ;;    Initializes sound effect instruments to be able to play sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKG_SFXInit> (void* *sfx_song_data*)
+   ;;
+   ;; Input Parameters (2 bytes):
+   ;;  (2B DE) sfx_song_data - Pointer to the start of a song file containing instrument data for SFX
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKG_SFXInit_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *sfx_song_data* must be a song in binary AKS format. However, this song 
+   ;; only needs to have instruments defined (there is not need for an actual "song"
+   ;; as a list of notes, patterns and others). Instruments will be set up for 
+   ;; playing SFX later on with functions like <cpct_akp_SFXPlay>.
+   ;;
+   ;; Details:
+   ;;    This function initializes instruments that will be used later on to play 
+   ;; FX sounds at will using <cpct_akp_SFXPlay>. In order for the instruments to
+   ;; be initialized, *sfx_song_data* must point to a song defined in AKS format.
+   ;; For the purpose of this function, the song only requires to have instruments
+   ;; defined in it, as patterns, notes and other information is not used for FX
+   ;; sounds. 
+   ;;
+   ;;    You may use instruments from another song or a specific song containing
+   ;; instrument data only. Any song with instruments defined in it is valid to
+   ;; set up SFX with Arkos Tracker Player.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, DE, HL
+   ;;
+   ;; Required memory:
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;;    Any     |  146   |  36.50
+   ;; --------------------------------
+   ;; Asm saving |  -41   | -10.25
+   ;; -------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   PLY_SFX_Init:
+   _cpct_akpAKG_SFXInit::
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  e, (hl)                                  ;; [ 7]
+      inc hl                                       ;; [ 6]
+      ld  d, (hl)                                  ;; [ 7] HL = Pointer to the SFX "Song"
+      ex  de, hl
+
+   cpct_akpAKG_SFXInit_asm::     ;; Entry point for assembly calls using registers for parameter passing
+       
+;Initializes the sound effects. It MUST be called at any times before a first sound effect is triggered.
+;It doesn't matter whether the song is playing or not, or if it has been initialized or not.
+;IN:    HL = Address to the sound effects data.
+PLY_AKG_InitSoundEffectsDisarkGenerateExternalLabel:
+PLY_AKG_InitSoundEffects:
+        ld (PLY_AKG_PtSoundEffectTable + PLY_AKG_Offset1b),hl
+        ret
+
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKG_SFXPlay
+   ;;
+   ;;    Plays a concrete sound effect, using the instruments of the "SFX song" 
+   ;; given to <cpct_akpAKG_SFXInit> when initializing sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKG_SFXPlay> (<u8> *sfx_num*, <u8> *channel_bitmask*, <u8> *volume*,)
+   ;;
+   ;; Input Parameters (3 bytes):
+   ;;  (1B A ) sfx_num         - Number of the instrument in the SFX Song (>0), same as the number given to the 
+   ;; instrument in Arkos Tracker.
+   ;;  (1B C ) channel
+   ;;  (1B B ) inv vol
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKG_SFXPlay_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Details:
+   ;;    Plays a given sound effect, along with the music, in a concrete channel 
+   ;; and with some parameters (Volume, Note, Speed, Inverted Pitch). This lets
+   ;; you create lots of different (and potentially complex) sound effects 
+   ;; from a set of instruments. In fact, you could play a song made of sound
+   ;; effect calls. 
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, BC, DE, HL,
+   ;;
+   ;; Required memory:
+   ;;    95 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles  | microSecs (us)
+   ;; --------------------------------------
+   ;;    Any     |     To be done
+   ;; --------------------------------------
+   ;; Asm saving |  -141   |  -45.25
+   ;; --------------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpAKG_SFXPlay::
+   PLY_SFX_Play:
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  a, (hl)                                  ;; [ 7] sfx
+      inc hl                                       ;; [ 6]
+      ld  c, (hl)                                  ;; [ 7] channel
+      inc hl                                       ;; [ 6]
+      ld  b, (hl)                                  ;; [ 7] vol
+
+      cpct_akpAKG_SFXPlay_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Plays a sound effect. If a previous one was already playing on the same channel, it is replaced.
+;This does not actually plays the sound effect, but programs its playing.
+;The music player, when called, will call the PLY_AKG_PlaySoundEffectsStream method below.
+;IN:    A = Sound effect number (>0!).
+;       C = The channel where to play the sound effect (0, 1, 2).
+;       B = Inverted volume (0 = full volume, 16 = no sound). Hardware sounds are also lowered.
+PLY_AKG_PlaySoundEffectDisarkGenerateExternalLabel:
+PLY_AKG_PlaySoundEffect:
+
+        ;Gets the address to the sound effect.
+        dec a                   ;The 0th is not encoded.
+        .ifeq PLY_AKG_Rom
+PLY_AKG_PtSoundEffectTable: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKG_PtSoundEffectTable)
+       .endif
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        add hl,de
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        ;Reads the header of the sound effect to get the speed.
+        ld a,(de)
+        inc de
+        ex af,af'
+
+        ld a,b
+
+        ;Finds the pointer to the sound effect of the desired channel.
+        ld hl,#PLY_AKG_Channel1_SoundEffectData
+        ld b,#0x00
+        sla c
+        sla c
+        sla c
+        add hl,bc
+        ld (hl),e
+        inc hl
+        ld (hl),d
+        inc hl        
+        
+        ;Now stores the inverted volume.
+        ld (hl),a
+        inc hl
+        
+        ;Resets the current speed, stores the instrument speed.
+        ld (hl),#0x00
+        inc hl
+        ex af,af'
+        ld (hl),a
+
+        ret
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKG_SFXStop
+   ;;
+   ;;    Stops the reproduction sound FX on given channels
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKG_SFXStop> (<u8> *stop_bitmask*)
+   ;;
+   ;; Input Parameters (1 byte):
+   ;;  (1B A) stop_bitmask - A value where the 3 Least Significant Bits represent which channels to stop 
+   ;; (bits enabled = channels to stop)
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKG_SFXStop_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *stop_bitmask* must be a value that operates as a set of enabled / 
+   ;; disabled bits (a bitmask). Concretely, the 3 Least Significant bits, 2, 1 
+   ;; and 0 (xxxxx210) refer to Channels C, B and A respectively. Rest of the 
+   ;; bits are ignored. Bits set to 1 mean that those channels will be stopped. 
+   ;; Bits set to 0 mean that those channels are to be left as they are.
+   ;;
+   ;; Details:
+   ;;    This function lets you selectively stop sound FX reproduction on one, two
+   ;; or the 3 available channels. A *stop_bitmask* is given as parameter containing
+   ;; the information about what channels shall be stopped.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, HL
+   ;;
+   ;; Required memory:
+   ;;    30 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2082 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;; Case       | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;; Best (0)   |  101   |  25.25 
+   ;; --------------------------------
+   ;; Best (1)   |  149   |  37.25 
+   ;; --------------------------------
+   ;; Asm saving |  -28   |  -7.00
+   ;; --------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpAKG_SFXStop::
+   PLY_SFX_Stop:
+      ld   hl, #2                             ;; [10] Get Parameter from Stack
+      add  hl, sp                             ;; [11]
+      ld    a, (hl)                           ;; [ 7] A = Channel number to be stopped
+
+   cpct_akpAKG_SFXStop_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Stops a sound effect. Nothing happens if there was no sound effect.
+;IN:    A = The channel where to stop the sound effect (0, 1, 2).
+PLY_AKG_StopSoundEffectFromChannelDisarkGenerateExternalLabel:
+PLY_AKG_StopSoundEffectFromChannel:
+        ;Puts 0 to the pointer of the sound effect.
+        add a,a
+        add a,a
+        add a,a
+        ld e,a
+        ld d,#0x00
+        ld hl,#PLY_AKG_Channel1_SoundEffectData
+        add hl,de
+        ld (hl),d               ;0 means "no sound".
+        inc hl
+        ld (hl),d
+        ret
+
+;Plays the sound effects, if any has been triggered by the user.
+;This does not actually send registers to the PSG, it only overwrite the required values of the registers of the player.
+;The sound effects initialization method must have been called before!
+;As R7 is required, this must be called after the music has been played, but BEFORE the registers are sent to the PSG.
+;IN:    A = R7.
+;OUT:   A = new R7.
+PLY_AKG_PlaySoundEffectsStream:
+        ;Shifts the R7 to the left twice, so that bit 2 and 5 only can be set for each track, below.
+        rla
+        rla
+
+        ;Plays the sound effects on every channel.
+        ld ix,#PLY_AKG_Channel1_SoundEffectData
+        ld iy,#PLY_AKG_PSGReg8
+        ld hl,#PLY_AKG_PSGReg01_Instr + PLY_AKG_Offset1b
+        exx
+        ld c,a
+        ;Channel 1.
+        ;----------
+        call PLY_AKG_PSES_Play
+        ld ix,#PLY_AKG_Channel2_SoundEffectData
+        ld iy,#PLY_AKG_PSGReg9
+        exx
+                ld hl,#PLY_AKG_PSGReg23_Instr + PLY_AKG_Offset1b
+        exx
+        ;Channel 2.
+        ;----------
+       .if PLY_AKG_HARDWARE_CPC
+                srl c                                                   ;Not RR, to make sure bit 6 is 0 (else, no more keyboard on CPC!).
+       .else
+               .if PLY_AKG_HARDWARE_MSX
+                        srl c                                           ;R7 bit 6 on MSX must be 0.
+               .else
+                        rr c                                            ;On other platforms, we don't care.
+               .endif
+       .endif
+
+        call PLY_AKG_PSES_Play
+        ld ix,#PLY_AKG_Channel3_SoundEffectData
+        ld iy,#PLY_AKG_PSGReg10
+        exx
+                ld hl,#PLY_AKG_PSGReg45_Instr + PLY_AKG_Offset1b
+        exx
+        ;Channel 3.
+        ;----------
+       .if PLY_AKG_HARDWARE_MSX
+                scf                                                    ;R7 bit 7 on MSX must be 1.
+       .endif
+        rr c
+        call PLY_AKG_PSES_Play
+
+        ld a,c
+        ret
+
+
+;Plays the sound stream from the given pointer to the sound effect. If 0, no sound is played.
+;The given R7 is given shift twice to the left, so that this code MUST set/reset the bit 2 (sound), and maybe reset bit 5 (noise).
+;This code MUST overwrite these bits because sound effects have priority over the music.
+;IN:    IX = Points on the sound effect pointer. If the sound effect pointer is 0, nothing must be played.
+;       IY = Points on the address where to store the volume for this channel.
+;       HL'= Points on the address where to store the software period for this channel.
+;       C = R7, shifted twice to the left.
+;OUT:   The pointed pointer by IX may be modified as the sound advances.
+;       C = R7, MUST be modified if there is a sound effect.
+PLY_AKG_PSES_Play:
+        ;Reads the pointer pointed by IX.
+        ld l,0 (ix)
+        ld h,1 (ix)
+        ld a,l
+        or h
+        ret z           ;No sound to be played? Returns immediately.
+
+        ;Reads the first byte. What type of sound is it?
+PLY_AKG_PSES_ReadFirstByte:
+        ld a,(hl)
+        inc hl
+        ld b,a
+        rra
+        jr c,PLY_AKG_PSES_SoftwareOrSoftwareAndHardware
+        rra
+                       .if PLY_CFG_SFX_HardOnly              ;CONFIG SPECIFIC
+        jr c,PLY_AKG_PSES_HardwareOnly
+                       .endif ;PLY_CFG_SFX_HardOnly
+
+        ;No software, no hardware, or end/loop.
+        ;-------------------------------------------
+        ;End or loop?
+        rra
+                       .if PLY_CFG_SFX_NoSoftNoHard         ;CONFIG SPECIFIC. If not present, the jump is not needed, the method is just below.
+        jr c,PLY_AKG_PSES_S_EndOrLoop
+
+        ;No software, no hardware.
+        ;-------------------------------------------
+        ;Gets the volume.
+        call PLY_AKG_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+                                       .if PLY_CFG_SFX_NoSoftNoHard_Noise                ;CONFIG SPECIFIC
+        rl b        
+        call c,PLY_AKG_PSES_ReadNoiseAndOpenNoiseChannel
+                                       .endif ;PLY_CFG_SFX_NoSoftNoHard_Noise
+
+        jr PLY_AKG_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_NoSoftNoHard
+
+        ;**Warning!** Do not put any instruction between EndOrLoop and NoSoftNoHard.
+
+PLY_AKG_PSES_S_EndOrLoop:
+                       .if PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC. If no "loop to", the sounds always end, no need to test.
+        ;Is it an end?
+        rra
+        jr c,PLY_AKG_PSES_S_Loop
+                       .endif ;PLY_CFG_SFX_LoopTo
+        ;End of the sound. Marks the sound pointer with 0, meaning "no sound".
+        xor a
+        ld 0 (ix),a
+        ld 1 (ix),a
+        ret
+                       .if PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC.
+PLY_AKG_PSES_S_Loop:
+        ;Loops. Reads the pointer and directly uses it.
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jr PLY_AKG_PSES_ReadFirstByte
+                       .endif ;PLY_CFG_SFX_LoopTo
+                        
+
+;Saves HL into IX, and exits. This must be called at the end of each Cell.
+;If the speed has not been reached, it is not saved.
+PLY_AKG_PSES_SavePointerAndExit:
+        ;Speed reached?
+        ld a,PLY_AKG_SoundEffectData_OffsetCurrentStep (ix)
+        cp PLY_AKG_SoundEffectData_OffsetSpeed (ix)
+        jr c,PLY_AKG_PSES_NotReached
+        ;The speed has been reached, so resets it and saves the pointer to the next cell to read.
+        ld PLY_AKG_SoundEffectData_OffsetCurrentStep (ix),#0x00
+        ld 0 (ix),l
+        ld 1 (ix),h
+        ret
+PLY_AKG_PSES_NotReached:
+        ;Speed not reached. Increases it, that's all. The same cell will be read next time.
+        inc PLY_AKG_SoundEffectData_OffsetCurrentStep (ix)
+        ret
+
+                       .if PLY_CFG_SFX_HardOnly         ;CONFIG SPECIFIC
+        ;Hardware only.
+        ;-------------------------------------------
+PLY_AKG_PSES_HardwareOnly:
+        ;Calls the shared code that manages everything.
+        call PLY_AKG_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+        ;Cuts the sound.
+        set 2,c
+
+        jr PLY_AKG_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_HardOnly
+
+
+
+PLY_AKG_PSES_SoftwareOrSoftwareAndHardware:
+        ;Software only?
+        rra
+                       .if PLY_CFG_SFX_SoftAndHard         ;CONFIG SPECIFIC
+        jr c,PLY_AKG_PSES_SoftwareAndHardware
+                       .endif ;PLY_CFG_SFX_SoftAndHard
+
+        ;Software.
+        ;-------------------------------------------
+                       .if PLY_CFG_SFX_SoftOnly          ;CONFIG SPECIFIC
+        ;Volume.
+        call PLY_AKG_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+        rl b
+                               .if PLY_CFG_SFX_SoftOnly_Noise                ;CONFIG SPECIFIC
+        call c,PLY_AKG_PSES_ReadNoiseAndOpenNoiseChannel
+                               .endif ;PLY_CFG_SFX_SoftOnly_Noise
+                                
+        ;Opens the "sound" channel.
+        res 2,c
+
+        ;Reads the software period.
+        call PLY_AKG_PSES_ReadSoftwarePeriod
+
+        jr PLY_AKG_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_SoftOnly
+                        
+
+        ;Software and Hardware.
+        ;-------------------------------------------
+                       .if PLY_AKG_SE_HardwareSounds         ;CONFIG SPECIFIC
+PLY_AKG_PSES_SoftwareAndHardware:
+        ;Calls the shared code that manages everything.
+        call PLY_AKG_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+
+        ;Reads the software period.
+        call PLY_AKG_PSES_ReadSoftwarePeriod
+
+        ;Opens the sound.
+        res 2,c
+
+        jr PLY_AKG_PSES_SavePointerAndExit
+                       .endif ;PLY_AKG_SE_HardwareSounds
+
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Shared code used by the "hardware only" and "software and hardware" part.
+        ;Reads the Retrig flag, the Hardware Envelope, the possible noise, the hardware period,
+        ;and sets the volume to 16. The R7 sound channel is NOT modified.
+PLY_AKG_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise:
+        ;Retrig?
+        rra
+                               .if PLY_AKG_SE_Retrig                  ;CONFIG SPECIFIC
+        jr nc,PLY_AKG_PSES_H_AfterRetrig
+        ld d,a
+        ld a,#0xff
+        ld (PLY_AKG_PSGReg13_OldValue + PLY_AKG_Offset1b),a
+        ld a,d
+PLY_AKG_PSES_H_AfterRetrig:
+                               .endif ;PLY_AKG_SE_Retrig
+
+        ;The hardware envelope can be set (8-15).
+        and #0b111
+        add a,#0x08
+        ld (PLY_AKG_PSGReg13_Instr + PLY_AKG_Offset1b),a
+
+                               .if PLY_AKG_SE_HardwareNoise           ;CONFIG SPECIFIC. B not needed after, we can put it in the condition too.
+        ;Noise?
+        rl b
+        call c,PLY_AKG_PSES_ReadNoiseAndOpenNoiseChannel
+                               .endif ;PLY_AKG_SE_HardwareNoise
+
+        ;Reads the hardware period.
+        call PLY_AKG_PSES_ReadHardwarePeriod
+
+        ;Sets the volume to "hardware". It still may be decreased.
+        ld a,#0x10
+        jp PLY_AKG_PSES_ManageVolumeFromA_Hard
+                       .endif ;PLY_CFG_UseHardwareSounds
+                        
+
+                       .if PLY_AKG_SE_Noise
+;Reads the noise pointed by HL, increases HL, and opens the noise channel.
+PLY_AKG_PSES_ReadNoiseAndOpenNoiseChannel:
+        ;Reads the noise.
+        ld a,(hl)
+        ld (PLY_AKG_PSGReg6),a
+        inc hl
+
+        ;Opens noise channel.
+        res 5,c
+        ret
+                       .endif ;PLY_AKG_SE_Noise
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+;Reads the hardware period from HL and sets the R11/R12 registers. HL is incremented of 2.
+PLY_AKG_PSES_ReadHardwarePeriod:
+        ld a,(hl)
+        ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b),a
+        inc hl
+        ld a,(hl)
+        ld (PLY_AKG_PSGHardwarePeriod_Instr + PLY_AKG_Offset1b + 1),a
+        inc hl
+        ret
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+;Reads the software period from HL and sets the period registers in HL'. HL is incremented of 2.
+PLY_AKG_PSES_ReadSoftwarePeriod:
+        ld a,(hl)
+        inc hl
+        exx
+                ld (hl),a
+                inc hl
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                ld (hl),a
+        exx
+        ret
+
+                       .if PLY_AKG_SE_VolumeSoft      ;CONFIG SPECIFIC
+;Reads the volume in A, decreases it from the inverted volume of the channel, and sets the volume via IY.
+;IN:    A = volume, from 0 to 15 (no hardware envelope).
+PLY_AKG_PSES_ManageVolumeFromA_Filter4Bits:
+        and #0b1111
+                       .endif ;PLY_AKG_SE_VolumeSoft
+                       .if PLY_AKG_SE_VolumeSoftOrHard        ;CONFIG SPECIFIC
+;After the filtering. Useful for hardware sound (volume has been forced to 16).
+PLY_AKG_PSES_ManageVolumeFromA_Hard:
+        ;Decreases the volume, checks the limit.
+        sub PLY_AKG_SoundEffectData_OffsetInvertedVolume (ix)
+        jr nc,PLY_AKG_PSES_MVFA_NoOverflow
+        xor a
+PLY_AKG_PSES_MVFA_NoOverflow:
+        ld 0 (iy),a
+        ret
+                       .endif ;PLY_AKG_SE_VolumeSoftOrHard
+                        
+
+        ;The data for RAM player. For ROM player, it is declared in the main player.
+        .ifeq PLY_AKG_Rom
+;The data of the Channels MUST be consecutive.
+PLY_AKG_Channel1_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKG_Channel1_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKG_Channel1_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKG_Channel1_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+.equ PLY_AKG_Channel_SoundEffectDataSize , . - PLY_AKG_Channel1_SoundEffectData
+    
+PLY_AKG_Channel2_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKG_Channel2_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKG_Channel2_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKG_Channel2_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+
+PLY_AKG_Channel3_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKG_Channel3_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKG_Channel3_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKG_Channel3_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+
+
+       .endif ;PLY_AKG_Rom
+
+;Offset from the beginning of the data, to reach the inverted volume.
+.equ PLY_AKG_SoundEffectData_OffsetInvertedVolume , PLY_AKG_Channel1_SoundEffectInvertedVolume - PLY_AKG_Channel1_SoundEffectData
+.equ PLY_AKG_SoundEffectData_OffsetCurrentStep , PLY_AKG_Channel1_SoundEffectCurrentStep - PLY_AKG_Channel1_SoundEffectData
+.equ PLY_AKG_SoundEffectData_OffsetSpeed , PLY_AKG_Channel1_SoundEffectSpeed - PLY_AKG_Channel1_SoundEffectData
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg_var.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg_var.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkg_var.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkg_var.src	2025-01-11 16:57:38
@@ -0,0 +1,233 @@
+    .if HARDWARE_ENTERPRISE
+.equ PLY_AKG_HARDWARE_ENTERPRISE  , 1
+    .else
+.equ PLY_AKG_HARDWARE_ENTERPRISE  , 0
+    .endif
+    .if HARDWARE_CPC
+.equ PLY_AKG_HARDWARE_CPC         , 1
+    .else
+.equ PLY_AKG_HARDWARE_CPC         , 0
+    .endif
+
+.equ PLY_AKG_HARDWARE_MSX         , 0
+.equ PLY_AKG_HARDWARE_SPECTRUM    , 0
+.equ PLY_AKG_HARDWARE_PENTAGON    , 0
+
+.equ PLY_AKG_USE_HOOKS            , 1                       ;Use hooks for external calls? 0 if the Init/Play/Stop methods are directly called. Will save a few bytes.
+.equ PLY_AKG_STOP_SOUNDS          , 1                       ;1 to have the "stop sounds" code. Set it to 0 if you never plan on stopping your music.
+.equ PLY_AKG_FULL_INIT_CODE       , 1                       ;0 to skip some init code/values, saving memory. Possible if you don't plan on restarting your song.
+
+
+        ;Is there a loaded Player Configuration source? If no, use a default configuration.
+.equ PLY_CFG_UseSpeedTracks                      ,   1
+.equ PLY_CFG_UseEventTracks                      ,   1
+.equ PLY_CFG_UseTranspositions                   ,   1
+.equ PLY_CFG_UseHardwareSounds                   ,   1
+.equ PLY_CFG_UseEffects                          ,   1
+.equ PLY_CFG_UseRetrig                           ,   1
+;.equ PLY_CFG_UseInstrumentRetrig                ,   1       ;Not tested, the UseRetrig is used instead.
+.equ PLY_CFG_UseInstrumentLoopTo                 ,   1
+;.equ PLY_CFG_NoSoftNoHard                       ,   1       ;Not tested, because always present.
+.equ PLY_CFG_NoSoftNoHard_Noise                  ,   1
+.equ PLY_CFG_SoftOnly                            ,   1
+.equ PLY_CFG_SoftOnly_Noise                      ,   1
+.equ PLY_CFG_SoftOnly_ForcedSoftwarePeriod       ,   1
+.equ PLY_CFG_SoftOnly_SoftwareArpeggio           ,   1
+.equ PLY_CFG_SoftOnly_SoftwarePitch              ,   1
+.equ PLY_CFG_SoftToHard                          ,   1
+.equ PLY_CFG_SoftToHard_Noise                    ,   1
+.equ PLY_CFG_SoftToHard_ForcedSoftwarePeriod     ,   1
+.equ PLY_CFG_SoftToHard_SoftwareArpeggio         ,   1
+.equ PLY_CFG_SoftToHard_SoftwarePitch            ,   1
+.equ PLY_CFG_SoftToHard_HardwarePitch            ,   1
+.equ PLY_CFG_SoftToHard_Retrig                   ,   1
+.equ PLY_CFG_HardOnly                            ,   1
+.equ PLY_CFG_HardOnly_Noise                      ,   1
+.equ PLY_CFG_HardOnly_ForcedHardwarePeriod       ,   1
+.equ PLY_CFG_HardOnly_HardwareArpeggio           ,   1
+.equ PLY_CFG_HardOnly_HardwarePitch              ,   1
+.equ PLY_CFG_HardOnly_Retrig                     ,   1
+.equ PLY_CFG_HardToSoft                          ,   1
+.equ PLY_CFG_HardToSoft_Noise                    ,   1
+.equ PLY_CFG_HardToSoft_ForcedHardwarePeriod     ,   1
+.equ PLY_CFG_HardToSoft_HardwareArpeggio         ,   1
+.equ PLY_CFG_HardToSoft_HardwarePitch            ,   1
+.equ PLY_CFG_HardToSoft_SoftwarePitch            ,   1
+.equ PLY_CFG_HardToSoft_Retrig                   ,   1
+.equ PLY_CFG_SoftAndHard                         ,   1
+.equ PLY_CFG_SoftAndHard_Noise                   ,   1
+.equ PLY_CFG_SoftAndHard_ForcedSoftwarePeriod    ,   1
+.equ PLY_CFG_SoftAndHard_SoftwareArpeggio        ,   1
+.equ PLY_CFG_SoftAndHard_SoftwarePitch           ,   1
+.equ PLY_CFG_SoftAndHard_ForcedHardwarePeriod    ,   1
+.equ PLY_CFG_SoftAndHard_HardwareArpeggio        ,   1
+.equ PLY_CFG_SoftAndHard_HardwarePitch           ,   1
+.equ PLY_CFG_SoftAndHard_Retrig                  ,   1
+.equ PLY_CFG_UseEffect_Legato                    ,   1
+.equ PLY_CFG_UseEffect_Reset                     ,   1
+.equ PLY_CFG_UseEffect_ForcePitchTableSpeed      ,   1
+.equ PLY_CFG_UseEffect_ForceArpeggioSpeed        ,   1
+.equ PLY_CFG_UseEffect_ForceInstrumentSpeed      ,   1
+.equ PLY_CFG_UseEffect_PitchGlide                ,   1
+.equ PLY_CFG_UseEffect_PitchUp                   ,   1
+.equ PLY_CFG_UseEffect_PitchDown                 ,   1
+.equ PLY_CFG_UseEffect_PitchTable                ,   1
+.equ PLY_CFG_UseEffect_Arpeggio3Notes            ,   1
+.equ PLY_CFG_UseEffect_Arpeggio4Notes            ,   1
+.equ PLY_CFG_UseEffect_ArpeggioTable             ,   1
+.equ PLY_CFG_UseEffect_SetVolume                 ,   1
+.equ PLY_CFG_UseEffect_VolumeIn                  ,   1
+.equ PLY_CFG_UseEffect_VolumeOut                 ,   1
+
+.equ PLY_AKG_MANAGE_SOUND_EFFECTS                ,   1
+
+;PLY_CFG_UseHardwareSounds                       ,   1
+.equ PLY_CFG_SFX_LoopTo                          ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard                    ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard_Noise              ,   1
+.equ PLY_CFG_SFX_SoftOnly                        ,   1
+.equ PLY_CFG_SFX_SoftOnly_Noise                  ,   1
+.equ PLY_CFG_SFX_HardOnly                        ,   1
+.equ PLY_CFG_SFX_HardOnly_Noise                  ,   1
+.equ PLY_CFG_SFX_HardOnly_Retrig                 ,   1
+.equ PLY_CFG_SFX_SoftAndHard                     ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Noise               ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Retrig              ,   1
+
+        ;Agglomerates some flags, because they are treated the same way by this player.
+        ;--------------------------------------------------
+        ;Special Track Used?
+       .if PLY_CFG_UseSpeedTracks + PLY_CFG_UseEventTracks
+.equ PLY_AKG_UseSpecialTracks , 1
+       .else
+.equ PLY_AKG_UseSpecialTracks , 0
+       .endif
+        ;SoftwareOnly and HardOnly share some code.
+       .if PLY_CFG_SoftOnly + PLY_CFG_HardOnly
+.equ PLY_AKG_UseSoftOnlyOrHardOnly , 1
+            .else
+.equ PLY_AKG_UseSoftOnlyOrHardOnly , 0
+       .endif
+        ;The same for their noise.
+       .if PLY_CFG_SoftOnly_Noise + PLY_CFG_HardOnly_Noise
+.equ PLY_AKG_UseSoftOnlyOrHardOnly_Noise , 1
+            .else
+.equ PLY_AKG_UseSoftOnlyOrHardOnly_Noise , 0
+       .endif
+
+        ;Agglomerates the Forced periods (soft/hard).
+       .if PLY_CFG_SoftOnly_ForcedSoftwarePeriod + PLY_CFG_HardOnly_ForcedHardwarePeriod + PLY_CFG_SoftToHard_ForcedSoftwarePeriod + PLY_CFG_HardToSoft_ForcedHardwarePeriod + PLY_CFG_SoftAndHard_ForcedSoftwarePeriod
+.equ PLY_AKG_UseInstrumentForcedPeriods , 1
+            .else
+.equ PLY_AKG_UseInstrumentForcedPeriods , 0
+       .endif
+        ;Agglomerates the Instrument Arpeggios (soft/hard).
+       .if PLY_CFG_SoftOnly_SoftwareArpeggio + PLY_CFG_SoftToHard_SoftwareArpeggio + PLY_CFG_HardOnly_HardwareArpeggio + PLY_CFG_HardToSoft_HardwareArpeggio + PLY_CFG_SoftAndHard_SoftwareArpeggio + PLY_CFG_SoftAndHard_HardwareArpeggio
+.equ PLY_AKG_UseInstrumentArpeggios , 1
+            .else
+.equ PLY_AKG_UseInstrumentArpeggios , 0
+       .endif
+        ;Agglomerates the Instrument Pitchs (soft/hard).
+       .if PLY_CFG_SoftOnly_SoftwarePitch + PLY_CFG_SoftToHard_SoftwarePitch + PLY_CFG_HardOnly_HardwarePitch + PLY_CFG_HardToSoft_HardwarePitch + PLY_CFG_SoftAndHard_SoftwarePitch + PLY_CFG_SoftAndHard_HardwarePitch
+.equ PLY_AKG_UseInstrumentPitchs , 1
+            .else
+.equ PLY_AKG_UseInstrumentPitchs , 0
+       .endif
+        ;Agglomerates the Instrument Forced Periods, Arpeggios and Pitchs (soft/hard).
+       .if PLY_AKG_UseInstrumentForcedPeriods + PLY_AKG_UseInstrumentArpeggios + PLY_AKG_UseInstrumentPitchs
+.equ PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs , 1
+            .else
+.equ PLY_AKG_UseInstrumentForcedPeriodsOrArpeggiosOrPitchs , 0
+       .endif
+        
+        ;Agglomerates the Retrig flags for SoftToHard, HardToSoft, SoftAndHard.
+       .if PLY_CFG_SoftToHard_Retrig + PLY_CFG_HardToSoft_Retrig + PLY_CFG_SoftAndHard_Retrig
+.equ PLY_AKG_UseRetrig_StoH_HtoS_SandH , 1
+            .else
+.equ PLY_AKG_UseRetrig_StoH_HtoS_SandH , 0
+       .endif
+        ;Agglomerates the noise flags for SoftToHard, HardToSoft, SoftAndHard.
+       .if PLY_CFG_SoftToHard_Noise + PLY_CFG_HardToSoft_Noise + PLY_CFG_SoftAndHard_Noise
+.equ PLY_AKG_UseNoise_StoH_HtoS_SandH , 1
+            .else
+.equ PLY_AKG_UseNoise_StoH_HtoS_SandH , 0
+       .endif
+;       Mixes the Hardware Noise flags into one.
+       .if PLY_CFG_SFX_HardOnly_Noise + PLY_CFG_SFX_SoftAndHard_Noise
+.equ PLY_AKG_SE_HardwareNoise , 1
+            .else
+.equ PLY_AKG_SE_HardwareNoise , 0
+       .endif
+
+;       Mixes the Noise flags into one.
+       .if PLY_AKG_SE_HardwareNoise + PLY_CFG_SFX_NoSoftNoHard_Noise + PLY_CFG_SFX_SoftOnly
+.equ PLY_AKG_SE_Noise , 1
+            .else
+.equ PLY_AKG_SE_Noise , 0
+       .endif
+        ;Agglomerates the noise flags to know if the code about R6 must be compiled.
+       .if PLY_CFG_NoSoftNoHard_Noise + PLY_CFG_SoftOnly_Noise + PLY_CFG_HardOnly_Noise + PLY_CFG_SoftToHard_Noise + PLY_CFG_HardToSoft_Noise + PLY_CFG_SoftAndHard_Noise + PLY_AKG_SE_Noise
+.equ PLY_AKG_Use_NoiseRegister , 1
+            .else
+.equ PLY_AKG_Use_NoiseRegister , 0
+       .endif
+        
+        ;Agglomerates the effect volume in/out.
+       .if PLY_CFG_UseEffect_VolumeIn + PLY_CFG_UseEffect_VolumeOut
+.equ PLY_AKG_UseEffect_VolumeSlide , 1
+            .else
+.equ PLY_AKG_UseEffect_VolumeSlide , 0
+       .endif
+        
+        ;Agglomerates the Arpeggios Table effects.
+       .if PLY_CFG_UseEffect_Arpeggio3Notes + PLY_CFG_UseEffect_Arpeggio4Notes + PLY_CFG_UseEffect_ArpeggioTable
+.equ PLY_AKS_UseEffect_Arpeggio , 1
+            .else
+.equ PLY_AKS_UseEffect_Arpeggio , 0
+       .endif
+        
+        ;Agglomerates the PitchUp/Down effects.
+       .if PLY_CFG_UseEffect_PitchUp + PLY_CFG_UseEffect_PitchDown
+.equ PLY_AKS_UseEffect_PitchUpOrDown , 1
+            .else
+.equ PLY_AKS_UseEffect_PitchUpOrDown , 0
+       .endif
+        ;Agglomerates the PitchUp/Down/Glide effects.
+        ;IMPORTANT TO NOTE that if there is Glide, there WILL be pitch up/down, because the Glide is
+        ;embedded in the pitch up/down code.
+       .if PLY_AKS_UseEffect_PitchUpOrDown + PLY_CFG_UseEffect_PitchGlide
+.equ PLY_AKS_UseEffect_PitchUpOrDownOrGlide , 1
+            .else
+.equ PLY_AKS_UseEffect_PitchUpOrDownOrGlide , 0
+       .endif
+        
+        ;Agglomerates a special flag combining ArpeggioTable and PitchTable.
+       .if PLY_AKS_UseEffect_Arpeggio + PLY_CFG_UseEffect_PitchTable
+.equ PLY_AKS_UseEffect_ArpeggioTableOrPitchTable , 1
+            .else
+.equ PLY_AKS_UseEffect_ArpeggioTableOrPitchTable , 0
+       .endif
+
+       .if PLY_CFG_SFX_HardOnly + PLY_CFG_SFX_SoftAndHard
+.equ PLY_AKG_SE_HardwareSounds , 1
+            .else
+.equ PLY_AKG_SE_HardwareSounds , 0
+       .endif
+
+;       Mixes the Software Volume flags into one.
+       .if PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly
+.equ PLY_AKG_SE_VolumeSoft , 1
+            .else
+.equ PLY_AKG_SE_VolumeSoft , 0
+       .endif
+       .if PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly + PLY_CFG_UseHardwareSounds
+.equ PLY_AKG_SE_VolumeSoftOrHard , 1
+            .else
+.equ PLY_AKG_SE_VolumeSoftOrHard , 0
+       .endif
+;       Mixes the retrig flags into one.
+       .if PLY_CFG_SFX_HardOnly_Retrig + PLY_CFG_SFX_SoftAndHard_Retrig
+.equ PLY_AKG_SE_Retrig , 1
+            .else
+.equ PLY_AKG_SE_Retrig , 0
+       .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm.s cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm.s
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm.s	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm.s	2025-01-11 16:57:38
@@ -0,0 +1,3065 @@
+;       Arkos Tracker 2 AKM (Minimalist) player (format V0).
+;       By Targhan/Arkos.
+;
+;       Thanks to Hicks/Vanity for two small (but relevant!) optimizations.
+
+;       This compiles with RASM. Check the compatibility page on the Arkos Tracker 2 website, it contains a source converter to any Z80 assembler!;
+
+;       This is a Minimalist player. Only a subset of the generic player is used. Use this player for 4k demo or other productions
+;       with a tight memory limitation. However, this remains a versatile and powerful player, so it may fit any production!
+;
+;       Though the player is optimized in speed, it is much slower than the generic one or the AKY player.
+;       With effects used at the same time, it can reach 45 scanlines on a CPC, plus some few more if you are using sound effects.
+;       So it's about as fast as the Soundtrakker 128 player, but smaller and more powerful (so what are you complaining about?).
+;
+;       The player uses the stack for optimizations. Make sure the interruptions are disabled before it is called.
+;       The stack pointer is saved at the beginning and restored at the end.
+;
+;       Target hardware:
+;       ---------------
+;       This code can target Amstrad CPC, MSX, Spectrum and Pentagon. By default, it targets Amstrad CPC.
+;       Simply use one of the follow line (BEFORE this player):
+;       PLY_AKM_HARDWARE_CPC = 1
+;       PLY_AKM_HARDWARE_MSX = 1
+;       PLY_AKM_HARDWARE_SPECTRUM = 1
+;       PLY_AKM_HARDWARE_PENTAGON = 1
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+
+;       Some severe optimizations of CPU/memory can be performed:
+;       ---------------------------------------------------------
+;       - Use the Player Configuration of Arkos Tracker 2 to generate a configuration file to be included at the beginning of this player.
+;         It will disable useless features according to your songs! Check the manual for more details, or more simply the testers.
+
+;       Sound effects:
+;       --------------
+;       Sound effects are disabled by default. Declare PLY_AKM_MANAGE_SOUND_EFFECTS to enable it:
+;       PLY_AKM_MANAGE_SOUND_EFFECTS = 1
+;       Check the sound effect tester to see how it enables it.
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+;
+;       ROM
+;       ----------------------
+;       To use a ROM player (no automodification, use of a small buffer to put in RAM):
+;       PLY_AKM_Rom = 1
+;       PLY_AKM_ROM_Buffer = #4000 (or wherever).
+;       This makes the player a bit slower and slightly bigger.
+;       The buffer is PLY_AKM_ROM_BufferSize bytes long (199 bytes max).
+;
+;       -------------------------------------------------------
+; _main::
+.module cpct_audio
+        .include "../../CPCteleraHW.src"
+        .include "arkostrackerAkm_var.src"
+PLY_AKM_Start:
+
+.equ PLY_AKM_Rom ,     0
+        
+        ;Hooks for external calls. Can be removed if not needed.
+       .if PLY_AKM_USE_HOOKS
+                jp PLY_AKM_Init          ;Player + 0.
+                jp PLY_AKM_Play          ;Player + 3.
+               .if PLY_AKM_STOP_SOUNDS
+                jp PLY_AKM_Stop          ;Player + 6.
+               .endif
+       .endif
+        
+        ;Includes the sound effects player, if wanted. Important to do it as soon as possible, so that
+        ;its code can react to the Player Configuration and possibly alter it.
+       .if PLY_AKM_MANAGE_SOUND_EFFECTS
+		.include "arkostrackerAkm_SoundEffects.src"
+       .endif
+        ;[[INSERT_SOUND_EFFECT_SOURCE]]                 ;A tag for test units. Don't touch or you're dead.
+
+        ;Is there a loaded Player Configuration source? If no, use a default configuration.
+
+;A nice trick to manage the offset using the same instructions, according to the player (ROM or not).
+       .if PLY_AKM_Rom
+.equ PLY_AKM_Offset1b , 0
+.equ PLY_AKM_Offset2b , 0         ;Used for instructions such as ld iyh,xx
+       .else
+.equ PLY_AKM_Offset1b , 1
+.equ PLY_AKM_Offset2b , 2
+       .endif
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKM_musicInit
+;;
+;;    Sets up a music into Arkos Tracker Player to be played later on with
+;; <cpct_akpAKM_musicPlay>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKM_musicInit> (void* *songdata*, song number)
+;;
+;; Input Parameters (2 bytes):
+;;    (2B HL) songdata - Pointer to the start of the array containing song's data in AKS binary format
+;;    (1B A) song number
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKM_musicInit_asm
+;;
+;; Parameter Restrictions:
+;;    * *songdata* must be an array containing dong's data in AKS binary format.
+;; Take into account that AKS binary format enforces a concrete start location in
+;; memory. Therefore, song must have been created in Arkos Tracker and exported 
+;; to the same memory location that *songdata* points to. If you fail to 
+;; locate the song at the same memory location it was exported for in Arkos 
+;; Tracker, unexpected results will happen (Typically, noise will be played but,
+;; occasionally your program may hang or crash).
+;;
+;; Known limitations:
+;;    * *songdata* must be the same memory address that the one given to Arkos
+;; Tracker when exporting song's binary. Arkos Tracker songs are created to
+;; be at a concrete memory location, due to optimization constraints. Therefore,
+;; this must be taken into account. If you wanted to change the memory location
+;; of the song, you should first open the song into Arkos Tracker and export
+;; it again with the new desired memory location.
+;;    * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function should be called fist to initialize the song that is to be 
+;; played. The function reads the song header and sets up the player to start 
+;; playing it. Once this process is done, <cpct_akp_musicPlay> should be called
+;; at the required frequency to continuously play the song.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    ? bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpAKM_musicInit::
+   ld   hl, #2    ;; [10] Retrieve parameters from stack
+   add  hl, sp    ;; [11]
+   ld    e, (hl)  ;; [ 7] DE = Pointer to the start of music
+   inc  hl        ;; [ 6]
+   ld    d, (hl)  ;; [ 7]
+   inc  hl
+   ld    c, (hl)
+   ex   de,hl
+cpct_akpAKM_musicInit_asm::   ;; Entry point for assembly calls using registers for parameter passing 
+   ;; First, set song loop times to 0 when we start
+   xor   a                          ;; A = 0
+   ld (_cpct_akpAKM_songLoopTimes), a  ;; _cpct_akpAKM_songLoopTimes = 0
+   ld    a,c
+   
+;Initializes the song. MUST be called before actually playing the song.
+;IN:    HL = Address of the song.
+;       A = Index of the subsong to play (>=0).
+PLY_AKM_InitDisarkGenerateExternalLabel:
+PLY_AKM_Init:
+        ;Reads the Song header.
+        ;Reads the pointers to the various index tables.
+        ld de,#PLY_AKM_PtInstruments + PLY_AKM_Offset1b
+        ldi
+        ldi
+                       .if PLY_CFG_UseEffects                           ;CONFIG SPECIFIC
+                               .if PLY_CFG_UseEffect_ArpeggioTable      ;CONFIG SPECIFIC
+        ld de,#PLY_AKM_PtArpeggios + PLY_AKM_Offset1b
+        ldi
+        ldi
+                               .else
+                                inc hl
+                                inc hl
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                               .if PLY_CFG_UseEffect_PitchTable         ;CONFIG SPECIFIC
+        ld de,#PLY_AKM_PtPitches + PLY_AKM_Offset1b
+        ldi
+        ldi
+                               .else
+                                inc hl
+                                inc hl
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+                       .else
+        ld de,#0x0004
+        add hl,de
+                       .endif ;PLY_CFG_UseEffects
+                        
+        ;Finds the address of the Subsong.
+        ;HL points on the table, adds A * 2.
+        ;Possible optimization: possible to set the Subsong directly.
+        add a,a
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+
+        ;Reads the header of the Subsong, copies the values inside the code via a table.
+        ld ix,#PLY_AKM_InitVars_Start
+.equ varcount , (PLY_AKM_InitVars_End - PLY_AKM_InitVars_Start) / 2
+        ld a,#varcount
+PLY_AKM_InitVars_Loop:
+        ld e,0 (ix)
+        ld d,1 (ix)
+        inc ix
+        inc ix
+        ldi
+        dec a
+        jr nz,PLY_AKM_InitVars_Loop
+
+        ;A is zero, no need to reset it.        
+        ld (PLY_AKM_PatternRemainingHeight + PLY_AKM_Offset1b),a       ;Optimization: this line can be removed if there is no need to reset the song (warning, A is used below).
+
+        ;Stores the Linker address, just after.
+        ex de,hl
+        ld hl,#PLY_AKM_PtLinker + PLY_AKM_Offset1b
+        ld (hl),e
+        inc hl
+        ld (hl),d
+
+        ;A big LDIR to erase all the data blocks. Optimization: can be removed if there is no need to reset the song.
+        ;A is considered 0!
+        ld hl,#PLY_AKM_Track1_Data
+        ld de,#PLY_AKM_Track1_Data + 1
+        ld bc,#PLY_AKM_Track3_Data_End - PLY_AKM_Track1_Data - 1
+        ld (hl),a
+        ldir
+        
+        ;Resets this flag. Especially important for ROM.
+       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+                ld (PLY_AKM_RT_ReadEffectsFlag + PLY_AKM_Offset1b),a
+       .endif
+
+        ;Forces a new line.
+        ld a,(PLY_AKM_Speed + PLY_AKM_Offset1b)
+        dec a
+        ld (PLY_AKM_TickCounter + PLY_AKM_Offset1b),a
+
+        ;Reads the first instrument, the empty one, and set-ups the pointers to the instrument to read.
+        ;Optimization: needed if the song doesn't start with an instrument on all the channels..else, it can be removed.
+        ld hl,(PLY_AKM_PtInstruments + PLY_AKM_Offset1b)
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        inc de          ;Skips the header.
+        ld (PLY_AKM_Track1_PtInstrument),de
+        ld (PLY_AKM_Track2_PtInstrument),de
+        ld (PLY_AKM_Track3_PtInstrument),de
+        
+        ;If sound effects, clears the SFX state.
+       .if PLY_AKM_MANAGE_SOUND_EFFECTS
+        ld hl,#0x0000
+        ld (PLY_AKM_Channel1_SoundEffectData),hl
+        ld (PLY_AKM_Channel2_SoundEffectData),hl
+        ld (PLY_AKM_Channel3_SoundEffectData),hl
+       .endif ;PLY_AKM_MANAGE_SOUND_EFFECTS
+        
+        ;For ROM, generates the RET table.
+       .if PLY_AKM_Rom
+        ld ix,#PLY_AKM_RegistersForRom           ;Source.
+        ld iy,#PLY_AKM_Registers_RetTable        ;Destination.
+        ld bc,#PLY_AKM_SendPsgRegister
+        ld de,4
+PLY_AKM_InitRom_Loop:
+                ld a,(ix)                 ;Gets the register.
+                ld h,a
+                inc ix
+                and #0b00111111
+                ld 0 (iy),a             ;Writes the register.
+                ld 1 (iy),0             ;Value is 0 for now.
+                ld a,h
+                and #0b11000000
+                jr nz,PLY_AKM_InitRom_Special
+                ;Encodes the "normal" SendPsgRegister code address.
+                ld 2 (iy),c
+                ld 3 (iy),b
+                add iy,de
+                jr PLY_AKM_InitRom_Loop
+PLY_AKM_InitRom_Special:
+               .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+                rl h
+                jr c,PLY_AKM_InitRom_WriteEndCode
+                ;Bit 6 must be set if we came here.
+                ld bc,#PLY_AKM_SendPsgRegisterR13
+                ld 2 (iy),c
+                ld 3 (iy),b
+                ld bc,#PLY_AKM_SendPsgRegisterAfterPop ;This one is a trick to send the register after R13 is managed.
+                ld 4 (iy),c
+                ld 5 (iy),b
+                add iy,de               ;Only advance of 4, the code belows expects that.
+               .endif ;PLY_CFG_UseHardwareSounds
+                
+PLY_AKM_InitRom_WriteEndCode:
+                ld bc,#PLY_AKM_SendPsgRegisterEnd
+                ld 2 (iy),c
+                ld 3 (iy),b
+       .endif
+   .if HARDWARE_ENTERPRISE
+        jp     ayReset
+   .else
+        ret
+   .endif
+
+        
+        ;If ROM, the registers to send, IN THE ORDER they are declared in the ROM buffer!
+        ;Bit 7 if ends (end DW to encode). Exclusive to bit 6.
+        ;Bit 6 if R13/AfterPop the end DW to encode. Exclusive to bit 7.
+       .if PLY_AKM_Rom
+PLY_AKM_RegistersForRom:
+               .db 8, 0, 1, 9, 2, 3, 10, 4, 5
+               .if PLY_AKM_USE_NoiseRegister          ;CONFIG SPECIFIC
+                       .db 6
+               .endif
+               .ifeq PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+                       .db 7 + 128
+               .else
+                       .db 7, 11, 12 + 64     ;13 is NOT declared, special case.
+               .endif
+       .endif
+
+;Addresses where to put the header data.
+PLY_AKM_InitVars_Start:
+       .dw PLY_AKM_NoteIndexTable + PLY_AKM_Offset1b
+       .dw PLY_AKM_NoteIndexTable + PLY_AKM_Offset1b + 1
+       .dw PLY_AKM_TrackIndex + PLY_AKM_Offset1b
+       .dw PLY_AKM_TrackIndex + PLY_AKM_Offset1b + 1
+       .dw PLY_AKM_Speed + PLY_AKM_Offset1b
+       .dw PLY_AKM_PrimaryInstrument + PLY_AKM_Offset1b
+       .dw PLY_AKM_SecondaryInstrument + PLY_AKM_Offset1b
+       .dw PLY_AKM_PrimaryWait + PLY_AKM_Offset1b
+       .dw PLY_AKM_SecondaryWait + PLY_AKM_Offset1b
+       .dw PLY_AKM_DefaultStartNoteInTracks + PLY_AKM_Offset1b
+       .dw PLY_AKM_DefaultStartInstrumentInTracks + PLY_AKM_Offset1b
+       .dw PLY_AKM_DefaultStartWaitInTracks + PLY_AKM_Offset1b
+       .dw PLY_AKM_FlagNoteAndEffectInCell + PLY_AKM_Offset1b
+PLY_AKM_InitVars_End:
+
+
+;Cuts the channels, stopping all sounds.
+       .if PLY_AKM_STOP_SOUNDS
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKM_stop
+;;
+;;    Stops playing musing and sound effects on all 3 channels.
+;;
+;; C Definition:
+;;    void <cpct_akpAKM_stop> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKM_stop_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function stops the music and sound effects playing in the 3 channels. 
+;; It can be later continued again calling <cpct_akp_musicPlay>. Please, take
+;; into account that sound effects cannot be played while music is stopped, as
+;; code for sound effects and music play is integrated.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;Stop the music, cut the channels.
+_cpct_akpAKM_stop::
+cpct_akpAKM_stop_asm::  ;; Entry point for assembly calls  
+PLY_AKM_StopDisarkGenerateExternalLabel:
+PLY_AKM_Stop:
+       .ifeq PLY_AKM_HARDWARE_ENTERPRISE 
+        ld (PLY_AKM_SaveSP + PLY_AKM_Offset1b),sp
+       .endif
+        xor a
+        ld (PLY_AKM_Track1_Volume),a
+        ld (PLY_AKM_Track2_Volume),a
+        ld (PLY_AKM_Track3_Volume),a
+       .if PLY_AKM_HARDWARE_MSX
+                ld a,#0b10111111          ;On MSX, bit 7 must be 1, bit 6 0.
+       .else
+                ld a,#0b00111111          ;On CPC, bit 6 must be 0. Other platforms don't care.
+       .endif
+        ld (PLY_AKM_MixerRegister),a
+        jp PLY_AKM_SendPsg
+       .endif ;PLY_AKM_STOP_SOUNDS
+
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKM_musicPlay
+;;
+;;    Plays next music cycle of the present song with Arkos Tracker Player. Song 
+;; has had to be previously established with <cpct_akp_musicInit>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKM_musicPlay> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKM_musicPlay_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function is to be called to start and continue playing the presently 
+;; selected song with Arkos Tracker Player. Depending on the frequency at which 
+;; the song were created, this function should be called 12, 25, 50, 100, 200 
+;; or 300 times per second. 
+;;
+;;    Each time you call the function, it plays 1/frequency seconds. This means
+;; that you have to manually synchronize your calls to this function to have
+;; a stable music playing. If you call too fast or too slow you will either 
+;; interrupt sound or have sound valleys. Therefore, you are responsible for
+;; calling this function with the most accurate timing possible, to get best 
+;; sound results.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xxxx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpAKM_musicPlay::
+cpct_akpAKM_musicPlay_asm::   ;; Entry point for assembly calls  
+  .if HARDWARE_ENTERPRISE
+   .ifeq NO_ENVELOPE_IRQ
+    .if ENABLE_1000HZ_IRQ
+        in      a,(#0xb4)
+        and     #0x02
+        jp      nz,envelopeInterrupt
+        ld      a,#0x31
+        out     (#0xb4),a
+    .else
+     .if ENABLE_300HZ_IRQ
+cntr    ld      a,#0x06
+        dec     a
+        ld      (cntr+1),a
+        jp      nz,envelopeInterrupt
+        ld      a,#0x06
+        ld      (cntr+1),a
+     .else
+        call    envelopeInterrupt
+     .endif
+    .endif
+   .endif
+  .endif
+
+;Plays one frame of the song. It MUST have been initialized before.
+;The stack is saved and restored, but is diverted, so watch out for the interruptions.
+PLY_AKM_PlayDisarkGenerateExternalLabel:
+PLY_AKM_Play:
+       .ifeq PLY_AKM_HARDWARE_ENTERPRISE 
+        ld (PLY_AKM_SaveSP + PLY_AKM_Offset1b),sp
+       .endif
+        ;Reads a new line?
+       .ifeq PLY_AKM_Rom
+PLY_AKM_TickCounter: ld a,#0x00
+        inc a
+PLY_AKM_Speed: cp #0x01                       ;Speed (>0).
+       .else
+        ld a,(PLY_AKM_Speed)
+        ld b,a
+        ld a,(PLY_AKM_TickCounter)
+        inc a
+        cp b
+       .endif
+        jp nz,PLY_AKM_TickCounterManaged
+
+        ;A new line must be read. But have we reached the end of the Pattern?
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PatternRemainingHeight: ld a,#0x00              ;Height. If 0, end of the pattern.
+       .else
+        ld a,(PLY_AKM_PatternRemainingHeight)
+       .endif
+        sub #0x1
+        jr c,PLY_AKM_Linker
+        ;Pattern not ended. No need to read the Linker.
+        ld (PLY_AKM_PatternRemainingHeight + PLY_AKM_Offset1b),a
+        jr PLY_AKM_ReadLine
+
+        ;New pattern. Reads the Linker.
+PLY_AKM_Linker:
+       .ifeq PLY_AKM_Rom
+PLY_AKM_TrackIndex: ld de,#0x0000              ;DE' points on the Track Index. Useful when new Tracks are found.
+       .else
+        ld de,(PLY_AKM_TrackIndex)
+       .endif
+        exx
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PtLinker: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKM_PtLinker)
+       .endif
+PLY_AKM_LinkerPostPt:
+        ;Resets the possible empty cell counter of each Track.
+        xor a
+        ld (PLY_AKM_Track1_WaitEmptyCell),a
+        ld (PLY_AKM_Track2_WaitEmptyCell),a
+        ld (PLY_AKM_Track3_WaitEmptyCell),a
+        ;On new pattern, the escape note/instrument/wait values are set for each Tracks.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_DefaultStartNoteInTracks: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_DefaultStartNoteInTracks)
+       .endif
+        ld (PLY_AKM_Track1_EscapeNote),a
+        ld (PLY_AKM_Track2_EscapeNote),a
+        ld (PLY_AKM_Track3_EscapeNote),a
+       .ifeq PLY_AKM_Rom
+PLY_AKM_DefaultStartInstrumentInTracks: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_DefaultStartInstrumentInTracks)
+       .endif
+        ld (PLY_AKM_Track1_EscapeInstrument),a
+        ld (PLY_AKM_Track2_EscapeInstrument),a
+        ld (PLY_AKM_Track3_EscapeInstrument),a
+       .ifeq PLY_AKM_Rom
+PLY_AKM_DefaultStartWaitInTracks: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_DefaultStartWaitInTracks)
+       .endif
+        ld (PLY_AKM_Track1_EscapeWait),a
+        ld (PLY_AKM_Track2_EscapeWait),a
+        ld (PLY_AKM_Track3_EscapeWait),a
+
+        ;Reads the state byte of the pattern.
+        ld b,(hl)
+        inc hl
+        rr b             ;Speed change or end of song?
+        jr nc,PLY_AKM_LinkerAfterSpeedChange
+        ;Next byte is either the speed (>0) or an end of song marker.
+        ld a,(hl)
+        inc hl
+                        ;If no speed used, it means "end of song" every time.
+                       .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC        
+        or a            ;0 if end of song,.else speed.
+        jr nz,PLY_AKM_LinkerSpeedChange
+                       .endif ;PLY_CFG_UseSpeedTracks
+        ;End of song.
+        ld a,(hl)       ;Reads where to loop in the Linker.
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jr PLY_AKM_LinkerPostPt
+                       .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC        
+PLY_AKM_LinkerSpeedChange:
+        ;Speed change.
+        ld (PLY_AKM_Speed + PLY_AKM_Offset1b),a
+                       .endif ;PLY_CFG_UseSpeedTracks
+PLY_AKM_LinkerAfterSpeedChange:
+
+        ;New height?
+        rr b
+        jr nc,PLY_AKM_LinkerUsePreviousHeight
+        ld a,(hl)
+        inc hl
+        ld (PLY_AKM_LinkerPreviousRemainingHeight + PLY_AKM_Offset1b),a
+        jr PLY_AKM_LinkerSetRemainingHeight
+        ;The same height is used. It was stored before.
+PLY_AKM_LinkerUsePreviousHeight:
+       .ifeq PLY_AKM_Rom
+PLY_AKM_LinkerPreviousRemainingHeight: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_LinkerPreviousRemainingHeight)
+       .endif
+PLY_AKM_LinkerSetRemainingHeight:
+        ld (PLY_AKM_PatternRemainingHeight + PLY_AKM_Offset1b),a
+
+        ;New Transposition and Track for channel 1?
+        ld ix,#PLY_AKM_Track1_Data
+        call PLY_AKM_CheckTranspositionAndTrack
+        ;New Transposition and Track for channel 2?
+        ld ix,#PLY_AKM_Track2_Data
+        call PLY_AKM_CheckTranspositionAndTrack
+        ;New Transposition and Track for channel 3?
+        ld ix,#PLY_AKM_Track3_Data
+        call PLY_AKM_CheckTranspositionAndTrack
+        
+        ld (PLY_AKM_PtLinker + PLY_AKM_Offset1b),hl
+
+
+;Reads the Tracks.
+;---------------------------------
+PLY_AKM_ReadLine:
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PtInstruments: ld de,#0x0000
+PLY_AKM_NoteIndexTable: ld bc,#0x0000
+       .else
+        ld de,(PLY_AKM_PtInstruments)
+        ld bc,(PLY_AKM_NoteIndexTable)
+       .endif
+        exx
+                ld ix,#PLY_AKM_Track1_Data
+                call PLY_AKM_ReadTrack
+                ld ix,#PLY_AKM_Track2_Data
+                call PLY_AKM_ReadTrack
+                ld ix,#PLY_AKM_Track3_Data
+                call PLY_AKM_ReadTrack
+
+                xor a
+PLY_AKM_TickCounterManaged:
+                ld (PLY_AKM_TickCounter + PLY_AKM_Offset1b),a
+
+
+
+;Plays the sound stream.
+;---------------------------------
+                ld de,#PLY_AKM_PeriodTable
+        exx
+
+        ld c,#0b11100000          ;Register 7, shifted of 2 to the left. Bits 2 and 5 will be possibly changed by each iteration.
+
+        ld ix,#PLY_AKM_Track1_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_AKM_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_AKM_Track1_Registers
+        call PLY_AKM_PlaySoundStream
+
+        srl c                   ;Not RR, because we have to make sure the b6 is 0,.else no more keyboard (on CPC)!
+                                ;Also, on MSX, bit 6 must be 0.
+        ld ix,#PLY_AKM_Track2_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_AKM_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_AKM_Track2_Registers
+        call PLY_AKM_PlaySoundStream
+
+       .if PLY_AKM_HARDWARE_MSX
+                scf             ;On MSX, bit 7 must be 1.
+                rr c
+       .else
+                rr c            ;On other platforms, we don't care about b7.
+       .endif
+        ld ix,#PLY_AKM_Track3_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_AKM_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_AKM_Track3_Registers
+        call PLY_AKM_PlaySoundStream
+
+        ld a,c
+
+;Plays the sound effects, if desired.
+;-------------------------------------------
+       .if PLY_AKM_MANAGE_SOUND_EFFECTS
+                        call PLY_AKM_PlaySoundEffectsStream
+       .else
+                        ld (PLY_AKM_MixerRegister),a
+       .endif ;PLY_AKM_MANAGE_SOUND_EFFECTS
+
+
+
+;Sends the values to the PSG.
+;---------------------------------
+PLY_AKM_SendPsg:
+      .if PLY_AKM_HARDWARE_ENTERPRISE
+        ld      de,#PLY_AKM_Registers_RetTable
+        call    ayRegisterWriteDE   ;reg 8
+        call    ayRegisterWriteDE   ;reg 0
+        call    ayRegisterWriteDE   ;reg 1
+        call    ayRegisterWriteDE   ;reg 9
+        call    ayRegisterWriteDE   ;reg 2
+        call    ayRegisterWriteDE   ;reg 3
+        call    ayRegisterWriteDE   ;reg 10
+        call    ayRegisterWriteDE   ;reg 4
+        call    ayRegisterWriteDE   ;reg 5
+       .if PLY_AKM_USE_NoiseRegister        ;CONFIG SPECIFIC
+        call    ayRegisterWriteDE   ;reg 6
+       .endif
+       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        call    ayRegisterWriteDE   ;reg 7
+        call    ayRegisterWriteDE   ;reg 11
+        call    ayRegisterWriteDE   ;reg 12
+PLY_AKM_SendPsgRegisterR13:
+PLY_AKM_SetReg13: 
+        ld      a,#0x00
+PLY_AKM_SetReg13Old: 
+        cp      #0x00
+        ret     z
+        ;Different. R13 must be played. Updates the old R13 value.
+        ld      (PLY_AKM_SetReg13Old + 1),a
+        ld      c,#0x0d
+        jp      ayRegisterWrite     ;reg 13
+       .else
+        jp      ayRegisterWriteDE   ;reg 7
+       .endif
+PLY_AKM_SendPsgRegister:
+PLY_AKM_SendPsgRegisterAfterPop:
+PLY_AKM_SendPsgRegisterEnd: 
+      .else
+        ld sp,#PLY_AKM_Registers_RetTable
+
+       .if PLY_AKM_HARDWARE_CPC
+        ld bc,#0xf680
+        ld a,#0xc0
+        ld de,#0xf4f6
+        out (c),a	;#f6c0          ;Madram's trick requires to start with this. out (c),b works, but will activate K7's relay! Not clean.
+       .endif
+
+       .if PLY_AKM_HARDWARE_SPECTRUM + PLY_AKM_HARDWARE_PENTAGON
+        ld de,#0xbfff
+        ld c,#0xfd
+       .endif
+
+PLY_AKM_SendPsgRegister:
+        pop hl          ;H = value, L = register.
+PLY_AKM_SendPsgRegisterAfterPop:
+       .if PLY_AKM_HARDWARE_CPC
+        ld b,d
+        out (c),l       ;#f400 + register.
+        ld b,e
+        .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+        ld b,d
+        out (c),h       ;#f400 + value.
+        ld b,e
+        out (c),c       ;#f680
+        out (c),a       ;#f6c0
+       .endif
+
+       .if PLY_AKM_HARDWARE_SPECTRUM + PLY_AKM_HARDWARE_PENTAGON
+        ld b,e
+        out (c),l       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+       .endif
+
+       .if PLY_AKM_HARDWARE_MSX
+        ld a,l          ;Register.
+        out (#0xa0),a
+        ld a,h          ;Value.
+        out (#0xa1),a
+       .endif
+        ret
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+PLY_AKM_SendPsgRegisterR13:
+
+        ;Should the R13 be played? Yes only if different. No "force retrig" is managed by this player.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_SetReg13: ld a,#0x00
+PLY_AKM_SetReg13Old: cp #0x00
+       .else
+        ld a,(PLY_AKM_SetReg13Old)
+        ld b,a
+        ld a,(PLY_AKM_SetReg13)
+        cp b
+       .endif
+        jr z,PLY_AKM_SendPsgRegisterEnd
+        ;Different. R13 must be played. Updates the old R13 value.
+        ld (PLY_AKM_SetReg13Old + PLY_AKM_Offset1b),a
+
+        ld h,a
+        ld l,#0x0d
+
+       .if PLY_AKM_HARDWARE_CPC
+                ld a,#0xc0
+       .endif
+
+        ret                     ;Sends the 13th registers.
+                       .endif ;PLY_CFG_UseHardwareSounds
+PLY_AKM_SendPsgRegisterEnd:
+
+       .ifeq PLY_AKM_Rom
+PLY_AKM_SaveSP: ld sp,#0x0000
+       .else
+        ld sp,(PLY_AKM_SaveSP)
+       .endif
+        ret
+      .endif
+
+
+
+
+;Shifts B to the right, if carry, a transposition is read.
+;Shifts B to the right once again, if carry, a new Track is read (may be an index or a track offset).
+;IN:    HL = where to read the data.
+;       IX = points on the track data buffer.
+;       DE'= Track index table
+;       B  = flags.
+;OUT:   B  = shifted of two.
+;       HL = increased according to read data.
+PLY_AKM_CheckTranspositionAndTrack:
+        ;New transposition?
+        rr b
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        jr nc,PLY_AKM_CheckTranspositionAndTrack_AfterTransposition
+        ;Transposition.
+        ld a,(hl)
+        ld PLY_AKM_Data_OffsetTransposition (ix),a
+        inc hl
+PLY_AKM_CheckTranspositionAndTrack_AfterTransposition:
+                       .endif ;PLY_CFG_UseTranspositions
+        ;New Track?
+        rr b
+        jr nc,PLY_AKM_CheckTranspositionAndTrack_NoNewTrack
+        ;New Track.
+        ld a,(hl)
+        inc hl
+        ;Is it a reference?
+        sla a
+        jr nc,PLY_AKM_CheckTranspositionAndTrack_TrackOffset
+        ;Reference.
+        exx
+                ld l,a          ;A is the track index * 2.
+                ld h,#0x00
+                add hl,de       ;HL points on the track address.
+                ld a,(hl)
+                ld PLY_AKM_Data_OffsetPtStartTrack + 0 (ix),a
+                ld PLY_AKM_Data_OffsetPtTrack + 0 (ix),a
+                inc hl
+                ld a,(hl)
+                ld PLY_AKM_Data_OffsetPtStartTrack + 1 (ix),a
+                ld PLY_AKM_Data_OffsetPtTrack + 1 (ix),a
+        exx
+        ret
+PLY_AKM_CheckTranspositionAndTrack_TrackOffset:
+        ;The Track is an offset. Counter the previous shift.
+        rra             ;Carry was 0, so bit 7 is 0.
+        ld d,a          ;D is the MSB of the offset.
+        ld e,(hl)       ;Reads the LSB of the offset.
+        inc hl
+        
+        ld c,l          ;Saves HL.
+        ld a,h
+        
+        add hl,de       ;HL is now the Track (offset + $ (past offset));
+        ld PLY_AKM_Data_OffsetPtStartTrack + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtStartTrack + 1 (ix),h
+        ld PLY_AKM_Data_OffsetPtTrack + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtTrack + 1 (ix),h
+        
+        ld l,c          ;Retrieves HL.
+        ld h,a
+        ret
+PLY_AKM_CheckTranspositionAndTrack_NoNewTrack:
+        ;Copies the old Track inside the new Track pointer, as it evolves.
+        ld a,PLY_AKM_Data_OffsetPtStartTrack + 0 (ix)
+        ld PLY_AKM_Data_OffsetPtTrack + 0 (ix),a
+        ld a,PLY_AKM_Data_OffsetPtStartTrack + 1 (ix)
+        ld PLY_AKM_Data_OffsetPtTrack + 1 (ix),a
+        ret
+
+
+
+
+
+;Reads a Track.
+;IN:    IX = Data block of the Track.
+;       DE'= Instrument table. Do not modify!
+;       BC'= Note index table. Do not modify!
+PLY_AKM_ReadTrack:
+        ;Are there any empty lines to wait?
+        ld a,PLY_AKM_Data_OffsetWaitEmptyCell (ix)
+        sub #0x01
+        jr c,PLY_AKM_RT_NoEmptyCell
+        ;Wait!
+        ld PLY_AKM_Data_OffsetWaitEmptyCell (ix),a
+        ret
+
+PLY_AKM_RT_NoEmptyCell:
+        ;Reads the Track pointer.
+        ld l,PLY_AKM_Data_OffsetPtTrack + 0 (ix)
+        ld h,PLY_AKM_Data_OffsetPtTrack + 1 (ix)
+PLY_AKM_RT_GetDataByte:
+        ld b,(hl)
+        inc hl
+        ;First, reads the note/effect flag.
+       .if PLY_AKM_Rom
+        ld a,(PLY_AKM_FlagNoteAndEffectInCell)
+        ld c,a
+       .endif
+        ld a,b
+        and #0b1111       ;Keeps only the note/data.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_FlagNoteAndEffectInCell: cp #0x0c          ;0-12 = note reference if no effects in the song, or 0-11 if there are effects in the song.
+       .else
+        cp c
+       .endif
+        jr c,PLY_AKM_RT_NoteReference
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        sub #0x0c                                  ;Can not be optimized with the code above, its value is automodified.
+        jr z,PLY_AKM_RT_NoteAndEffects
+        dec a
+        jr z,PLY_AKM_RT_NoNoteMaybeEffects
+                       .else
+        sub #0x0d
+        jr z,PLY_AKM_RT_ReadWaitFlags          ;If no effects, directly check the wait flag.
+                       .endif ;PLY_CFG_UseEffects
+        dec a
+        jr z,PLY_AKM_RT_NewEscapeNote
+        ;15. Same escape note.
+        ld a,PLY_AKM_Data_OffsetEscapeNote (ix)
+        jr PLY_AKM_RT_AfterNoteRead
+        
+PLY_AKM_RT_NewEscapeNote:
+        ;Reads the escape note, and stores it, it may be reused by other cells.
+        ld a,(hl)
+        ld PLY_AKM_Data_OffsetEscapeNote (ix),a
+        inc hl
+        jr PLY_AKM_RT_AfterNoteRead
+
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+PLY_AKM_RT_NoteAndEffects:
+        ;There is a "note and effects". This is a special case. A new data byte must be read, with the note and the normal flags.
+        ;However, we use a "force effects" to mark the presence of effects.
+        dec a     ;A is 0, give it any other value.
+        ld (PLY_AKM_RT_ReadEffectsFlag + PLY_AKM_Offset1b),a
+        jr PLY_AKM_RT_GetDataByte
+        
+PLY_AKM_RT_NoNoteMaybeEffects:
+        ;Reads flag "instrument" to know what to do. The flags are diverted to indicate whether there are effects.
+        bit 4,b     ;Effects?
+        jr z,PLY_AKM_RT_ReadWaitFlags  ;No effects. As there is no note, logically, there are no instrument to read, so simply reads the Wait value.
+        ld a,b          ;B is not 0, so it works.
+        ld (PLY_AKM_RT_ReadEffectsFlag + PLY_AKM_Offset1b),a
+        jr PLY_AKM_RT_ReadWaitFlags
+                       .endif ;PLY_CFG_UseEffects        
+        
+PLY_AKM_RT_NoteReference:
+        ;A is the index of the note.
+        exx
+                ld l,a
+                ld h,#0x00
+                add hl,bc
+                ld a,(hl)
+        exx
+
+        ;A is the right note (0-127).
+PLY_AKM_RT_AfterNoteRead:
+        ;Adds the transposition.
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        add a,PLY_AKM_Data_OffsetTransposition (ix)
+                       .endif ;PLY_CFG_UseTranspositions
+        ld PLY_AKM_Data_OffsetBaseNote (ix) , a
+
+        ;Reads the instruments flags.
+        ;------------------
+        ld a,b
+        and #0b110000
+        jr z,PLY_AKM_RT_SameEscapeInstrument
+        cp #0b010000
+        jr z,PLY_AKM_RT_PrimaryInstrument
+        cp #0b100000
+        jr z,PLY_AKM_RT_SecondaryInstrument
+        ;New escape instrument. Reads and stores it, it may be reused by other cells.
+        ld a,(hl)
+        inc hl
+        ld PLY_AKM_Data_OffsetEscapeInstrument (ix),a
+        jr PLY_AKM_RT_StoreCurrentInstrument
+
+PLY_AKM_RT_SameEscapeInstrument:
+        ;Use the latest escape instrument.
+        ld a,PLY_AKM_Data_OffsetEscapeInstrument (ix)
+        jr PLY_AKM_RT_StoreCurrentInstrument
+
+PLY_AKM_RT_SecondaryInstrument:
+        ;Use the secondary instrument.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_SecondaryInstrument: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_SecondaryInstrument)
+       .endif
+        jr PLY_AKM_RT_StoreCurrentInstrument
+        
+PLY_AKM_RT_PrimaryInstrument:
+        ;Use the primary instrument.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PrimaryInstrument: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_PrimaryInstrument)
+       .endif
+        
+PLY_AKM_RT_StoreCurrentInstrument:
+        ;A is the instrument to play.
+        exx
+                ;Gets the address of the Instrument.
+                add a,a         ;Only 127 instruments max.
+                ld l,a
+                ld h,#0x00
+                add hl,de       ;Adds to the Instrument Table.
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a
+                ;Reads the header of the Instrument.
+                ld a,(hl)       ;Speed.
+                inc hl
+                ld PLY_AKM_Data_OffsetInstrumentSpeed (ix),a
+                ;Stores the pointer on the data of the Instrument.
+                ld PLY_AKM_Data_OffsetPtInstrument + 0 (ix),l
+                ld PLY_AKM_Data_OffsetPtInstrument + 1 (ix),h
+        exx
+        xor a
+        ;Resets the step on the Instrument.
+        ld PLY_AKM_Data_OffsetInstrumentCurrentStep (ix),a
+        ;Resets the Track pitch.
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetIsPitchUpDownUsed (ix),a
+        ld PLY_AKM_Data_OffsetTrackPitchInteger + 0 (ix),a
+        ld PLY_AKM_Data_OffsetTrackPitchInteger + 1 (ix),a
+        ;ld PLY_AKM_Data_OffsetTrackPitchDecimal (ix),a               ;Shouldn't be needed, the difference shouldn't be noticeable.
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+
+        ;Resets the offset on Arpeggio and Pitch tables.
+                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetPtArpeggioOffset (ix),a
+        ld PLY_AKM_Data_OffsetArpeggioCurrentStep (ix),a
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+        ld a,PLY_AKM_Data_OffsetArpeggioOriginalSpeed (ix)            ;The arpeggio speed must be reset.
+        ld PLY_AKM_Data_OffsetArpeggioCurrentSpeed (ix),a
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetPtPitchOffset (ix),a
+        ld PLY_AKM_Data_OffsetPitchCurrentStep (ix),a        
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+        ld a,PLY_AKM_Data_OffsetPitchOriginalSpeed (ix)               ;The pitch speed must be reset.
+        ld PLY_AKM_Data_OffsetPitchCurrentSpeed (ix),a
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+        
+        ;Reads the wait flags.
+        ;----------------------
+PLY_AKM_RT_ReadWaitFlags:
+        ld a,b
+        and #0b11000000
+        jr z,PLY_AKM_RT_SameEscapeWait
+        cp #0b01000000
+        jr z,PLY_AKM_RT_PrimaryWait
+        cp #0b10000000
+        jr z,PLY_AKM_RT_SecondaryWait
+        ;New escape wait. Reads and stores it, it may be reused by other cells.
+        ld a,(hl)
+        inc hl
+        ld PLY_AKM_Data_OffsetEscapeWait (ix),a
+        jr PLY_AKM_RT_StoreCurrentWait
+                
+PLY_AKM_RT_SameEscapeWait:
+        ;Use the latest escape wait.
+        ld a,PLY_AKM_Data_OffsetEscapeWait (ix)
+        jr PLY_AKM_RT_StoreCurrentWait
+        
+PLY_AKM_RT_PrimaryWait:
+        ;Use the primary wait.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PrimaryWait: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_PrimaryWait)
+       .endif
+        jr PLY_AKM_RT_StoreCurrentWait
+
+PLY_AKM_RT_SecondaryWait:
+        ;Use the secondary wait.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_SecondaryWait: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_SecondaryWait)
+       .endif
+
+PLY_AKM_RT_StoreCurrentWait:
+        ;A is the wait to store.
+        ld PLY_AKM_Data_OffsetWaitEmptyCell (ix),a
+
+        ;--------------------
+        ;Are there effects to read?
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+       .ifeq PLY_AKM_Rom
+PLY_AKM_RT_ReadEffectsFlag: ld a,#0x00
+       .else
+        ld a,(PLY_AKM_RT_ReadEffectsFlag)
+       .endif
+        or a
+        jr nz,PLY_AKM_RT_ReadEffects
+PLY_AKM_RT_AfterEffects:
+                       .endif ;PLY_CFG_UseEffects
+        ;No effects, or after they have been managed.
+        ;Saves the new pointer on the Track.
+        ld PLY_AKM_Data_OffsetPtTrack + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtTrack + 1 (ix),h
+        ret
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+PLY_AKM_RT_ReadEffects:
+        ;Resets the effect presence flag.
+        xor a
+        ld (PLY_AKM_RT_ReadEffectsFlag + PLY_AKM_Offset1b),a
+        
+PLY_AKM_RT_ReadEffect:
+        ld iy,#PLY_AKM_EffectTable
+        ;Reads effect number and possible data. All effect must jump to PLY_AKM_RT_ReadEffect_Return when finished.
+        ld b,(hl)
+        ld a,b
+        inc hl
+        
+        and #0b1110
+        ld e,a
+        ld d,#0x00
+        add iy,de
+        
+        ;As a convenience, puts the effect nibble "to the right", for direct use.
+        ld a,b
+        rra
+        rra
+        rra
+        rra
+        and #0b1111               ;This sets the carry flag, useful for the effects code.
+        ;Executes the effect code.
+        jp (iy)
+PLY_AKM_RT_ReadEffect_Return:
+        ;More effects?
+        bit 0,b
+        jr nz,PLY_AKM_RT_ReadEffect
+        jr PLY_AKM_RT_AfterEffects
+
+PLY_AKM_RT_WaitLong:
+        ;A 8-bit byte is encoded just after.
+        ld a,(hl)
+        inc hl
+        ld PLY_AKM_Data_OffsetWaitEmptyCell (ix),a
+        jr PLY_AKM_RT_CellRead
+PLY_AKM_RT_WaitShort:
+        ;Only a 2-bit value is encoded.
+        ld a,b
+        rlca                     ;Transfers the bit 7/6 to 1/0. Thanks Hicks for the RCLA trick!
+        rlca
+        and #0b11
+        ld PLY_AKM_Data_OffsetWaitEmptyCell (ix),a
+        ;jr PLY_AKM_RT_CellRead
+;Jumped to after the Cell has been read.
+;IN:    HL = new value of the Track pointer. Must point after the read Cell.
+PLY_AKM_RT_CellRead:
+        ld PLY_AKM_Data_OffsetPtTrack + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtTrack + 1 (ix),h
+        ret
+
+
+;Manages the effects, if any. For the activated effects, modifies the internal data for the Track which data block is given.
+;IN:    IX = data block of the Track.
+;OUT:   IX, IY = unmodified.
+;       C must NOT be modified!
+;       DE' must NOT be modified!
+PLY_AKM_ManageEffects:
+                               .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+        ;Pitch up/down used?
+        ld a,PLY_AKM_Data_OffsetIsPitchUpDownUsed (ix)
+        or a
+        jr z,PLY_AKM_ME_PitchUpDownFinished
+
+        ;Adds the LSB of integer part and decimal part, using one 16 bits operation.
+        ld l,PLY_AKM_Data_OffsetTrackPitchDecimal (ix)
+        ld h,PLY_AKM_Data_OffsetTrackPitchInteger + 0 (ix)
+
+        ld e,PLY_AKM_Data_OffsetTrackPitchSpeed + 0 (ix)
+        ld d,PLY_AKM_Data_OffsetTrackPitchSpeed + 1 (ix)
+
+        ld a,PLY_AKM_Data_OffsetTrackPitchInteger + 1 (ix)
+
+        ;Negative pitch?
+        bit 7,d
+        jr nz,PLY_AKM_ME_PitchUpDown_NegativeSpeed
+
+PLY_AKM_ME_PitchUpDown_PositiveSpeed:
+        ;Positive speed. Adds it to the LSB of the integer part, and decimal part.
+        add hl,de
+
+        ;Carry? Transmits it to the MSB of the integer part.
+        adc #0x00
+        jr PLY_AKM_ME_PitchUpDown_Save
+PLY_AKM_ME_PitchUpDown_NegativeSpeed:
+        ;Negative speed. Resets the sign bit. The encoded pitch IS positive.
+        ;Subtracts it to the LSB of the integer part, and decimal part.
+        res 7,d
+
+        or a
+        sbc hl,de
+
+        ;Carry? Transmits it to the MSB of the integer part.
+        sbc #0x00
+
+PLY_AKM_ME_PitchUpDown_Save:
+        ld PLY_AKM_Data_OffsetTrackPitchInteger + 1 (ix),a
+
+        ld PLY_AKM_Data_OffsetTrackPitchDecimal (ix),l
+        ld PLY_AKM_Data_OffsetTrackPitchInteger + 0 (ix),h
+
+PLY_AKM_ME_PitchUpDownFinished:
+                               .endif ;PLY_AKM_USE_EffectPitchUpDown
+
+
+
+        ;Manages the Arpeggio Table effect, if any.
+        ;------------------------------------------
+                               .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+        ld a,PLY_AKM_Data_OffsetIsArpeggioTableUsed (ix)
+        or a
+        jr z,PLY_AKM_ME_ArpeggioTableFinished
+
+        ;Plays the arpeggio current note. It is suppose to be correct (not a loop).
+        ;Plays it in any case, in order to manage some corner case with Force Arpeggio Speed.
+        ld e,PLY_AKM_Data_OffsetPtArpeggioTable + 0 (ix)
+        ld d,PLY_AKM_Data_OffsetPtArpeggioTable + 1 (ix)
+        ld l,PLY_AKM_Data_OffsetPtArpeggioOffset (ix)
+        ld h,#0x00
+        add hl,de
+        ld a,(hl)       ;Gets the Arpeggio value (b1-b7).
+        sra a           ;Carry is 0, because the ADD above surely didn't overflow.
+        ld PLY_AKM_Data_OffsetCurrentArpeggioValue (ix),a
+
+        ;Moves forward, if the speed has been reached.
+        ;Has the speed been reached?
+        ld a,PLY_AKM_Data_OffsetArpeggioCurrentStep (ix)
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+        cp PLY_AKM_Data_OffsetArpeggioCurrentSpeed (ix)
+                               .else
+        cp PLY_AKM_Data_OffsetArpeggioOriginalSpeed (ix)
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+        jr c,PLY_AKM_ME_ArpeggioTable_SpeedNotReached
+        ;Resets the speed. Reads the next Arpeggio value.
+        ld PLY_AKM_Data_OffsetArpeggioCurrentStep (ix),#0x00
+        
+        ;Advances in the Arpeggio.
+        inc PLY_AKM_Data_OffsetPtArpeggioOffset (ix)
+        inc hl          ;HL points on the next value. No need to add to the base offset like before, we have it.
+        ld a,(hl)
+        ;End of the Arpeggio?
+        rra             ;Carry is 0.
+        jr nc,PLY_AKM_ME_ArpeggioTableFinished
+        ;End of the Arpeggio. The loop offset is now in A.
+        ld l,a
+        ld PLY_AKM_Data_OffsetPtArpeggioOffset (ix),a
+        jr PLY_AKM_ME_ArpeggioTableFinished
+        
+PLY_AKM_ME_ArpeggioTable_SpeedNotReached:
+        inc a
+        ld PLY_AKM_Data_OffsetArpeggioCurrentStep (ix),a
+
+PLY_AKM_ME_ArpeggioTableFinished:
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+
+
+        ;Manages the Pitch Table effect, if any.
+        ;------------------------------------------
+                               .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld a,PLY_AKM_Data_OffsetIsPitchTableUsed (ix)
+        or a
+        ret z
+
+        ;Plays the Pitch Table current note. It is suppose to be correct (not a loop).
+        ;Plays it in any case, in order to manage some corner case with Force Pitch Speed.
+        ;Reads the Pitch Table. Adds the Pitch base address to an offset.
+        ld l,PLY_AKM_Data_OffsetPtPitchTable + 0 (ix)
+        ld h,PLY_AKM_Data_OffsetPtPitchTable + 1 (ix)
+        ld e,PLY_AKM_Data_OffsetPtPitchOffset (ix)
+        ld d,#0x00
+        add hl,de
+        ld a,(hl)       ;Gets the Pitch value (b1-b7).
+        sra a
+        ;A = pitch note. It is converted to 16 bits.
+        ;D is already 0.
+        jp p,PLY_AKM_ME_PitchTableEndNotReached_Positive
+        dec d
+PLY_AKM_ME_PitchTableEndNotReached_Positive:
+        ld PLY_AKM_Data_OffsetCurrentPitchTableValue + 0 (ix),a
+        ld PLY_AKM_Data_OffsetCurrentPitchTableValue + 1 (ix),d
+        
+        ;Moves forward, if the speed has been reached.
+        ;Has the speed been reached?
+        ld a,PLY_AKM_Data_OffsetPitchCurrentStep (ix)
+                       .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+        cp PLY_AKM_Data_OffsetPitchCurrentSpeed (ix)
+                       .else
+        cp PLY_AKM_Data_OffsetPitchOriginalSpeed (ix)
+                       .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+        jr c,PLY_AKM_ME_PitchTable_SpeedNotReached
+        ;Resets the speed, then reads the next Pitch value.
+        ld PLY_AKM_Data_OffsetPitchCurrentStep (ix),#0x00
+        
+        ;Advances in the Pitch.
+        inc PLY_AKM_Data_OffsetPtPitchOffset (ix)
+        inc hl          ;HL points on the next value. No need to add to the base offset like before, we have it.
+        ld a,(hl)
+        ;End of the Pitch?
+        rra             ;Carry is 0.
+        ret nc
+        ;End of the Pitch. The loop offset is now in A.
+        ld l,a
+        ld PLY_AKM_Data_OffsetPtPitchOffset (ix),a
+        ret
+
+PLY_AKM_ME_PitchTable_SpeedNotReached:
+        inc a
+        ld PLY_AKM_Data_OffsetPitchCurrentStep (ix),a
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+        ret
+                       .endif ;PLY_CFG_UseEffects
+        
+        
+
+
+;---------------------------------------------------------------------
+;Sound stream.
+;---------------------------------------------------------------------
+
+;Plays the sound stream, filling the PSG registers table (but not playing it).
+;The Instrument pointer must be updated as it evolves inside the Instrument.
+;IN:    IX = Data block of the Track.
+;       IY = Points at the beginning of the register structure related to the channel.
+;       C = R7. Only bit 2 (sound) must be *set* to cut the sound if needed, and bit 5 (noise) must be *reset* if there is noise.
+;       DE' = Period table. Must not be modified.
+PLY_AKM_PlaySoundStream:
+        ;Gets the pointer on the Instrument, from its base address and the offset.
+        ld l,PLY_AKM_Data_OffsetPtInstrument + 0 (ix)
+        ld h,PLY_AKM_Data_OffsetPtInstrument + 1 (ix)
+
+        ;Reads the first byte of the cell of the Instrument. What type?
+PLY_AKM_PSS_ReadFirstByte:
+        ld a,(hl)
+        ld b,a
+        inc hl
+        rra
+        jr c,PLY_AKM_PSS_SoftOrSoftAndHard
+
+        ;NoSoftNoHard or SoftwareToHardware
+        rra
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        jr c,PLY_AKM_PSS_SoftwareToHardware
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+        ;No software no hardware, or end of sound (loop)!
+        ;End of sound?
+        rra
+        jr nc,PLY_AKM_PSS_NSNH_NotEndOfSound
+   ;; Increment song loop times
+   ld    a, (_cpct_akpAKM_songLoopTimes)
+   inc   a
+   ld (_cpct_akpAKM_songLoopTimes), a 
+        ;The sound loops/ends. Where?
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ;As a sound always has at least one cell, we should safely be able to read its bytes without storing the instrument pointer.
+        ;However, we do it anyway to remove the overhead of the Speed management: if looping, the same last line will be read,
+        ;if several channels do so, it will be costly. So...
+        ld PLY_AKM_Data_OffsetPtInstrument + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtInstrument + 1 (ix),h
+        jr PLY_AKM_PSS_ReadFirstByte
+;; Loop times
+;;    Read here to know the number of times a song has looped
+_cpct_akpAKM_songLoopTimes:: .db 0 
+
+PLY_AKM_PSS_NSNH_NotEndOfSound:
+        ;No software, no hardware.
+        ;-------------------------
+        ;Stops the sound.
+        set 2,c
+
+        ;Volume. A now contains the volume on b0-3.
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+        call PLY_AKM_PSS_Shared_AdjustVolume
+                       .else
+        and #0b1111
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+        ld PLY_AKM_Registers_OffsetVolume (iy),a
+
+        ;Read noise?
+        rl b
+                       .if PLY_CFG_NoSoftNoHard_Noise        ;CONFIG SPECIFIC
+        call c,PLY_AKM_PSS_ReadNoise
+                       .endif ;PLY_CFG_NoSoftNoHard_Noise
+        jr PLY_AKM_PSS_Shared_StoreInstrumentPointer
+
+        ;Software sound, or Software and Hardware?
+PLY_AKM_PSS_SoftOrSoftAndHard:
+        rra
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        jr c,PLY_AKM_PSS_SoftAndHard
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+        ;Software sound.
+        ;-----------------
+        ;A is the volume. Already shifted twice, so it can be used directly.
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+        call PLY_AKM_PSS_Shared_AdjustVolume
+                       .else
+        and #0b1111
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+        ld PLY_AKM_Registers_OffsetVolume (iy),a
+
+        ;Arp and/or noise?
+        ld d,#0x00          ;Default arpeggio.
+        rl b
+        jr nc,PLY_AKM_PSS_S_AfterArpAndOrNoise
+        ld a,(hl)
+        inc hl
+        ;Noise?
+        sra a
+        ;A is now the signed Arpeggio. It must be kept.
+        ld d,a
+        ;Now takes care of the noise, if there is a Carry.
+                       .if PLY_CFG_SoftOnly_Noise          ;CONFIG SPECIFIC
+        call c,PLY_AKM_PSS_ReadNoise
+                       .endif ;PLY_CFG_SoftOnly_Noise
+PLY_AKM_PSS_S_AfterArpAndOrNoise:
+
+        ld a,d          ;Gets the instrument arpeggio, if any.
+        call PLY_AKM_CalculatePeriodForBaseNote
+
+        ;Read pitch?
+        rl b
+                       .if PLY_CFG_SoftOnly_SoftwarePitch    ;CONFIG SPECIFIC
+        call c,PLY_AKM_ReadPitchAndAddToPeriod
+                       .endif ;PLY_CFG_SoftOnly_SoftwarePitch
+
+        ;Stores the new period of this channel.
+        exx
+                ld PLY_AKM_Registers_OffsetSoftwarePeriodLSB (iy),l
+                ld PLY_AKM_Registers_OffsetSoftwarePeriodMSB (iy),h
+        exx
+
+        ;The code below is shared!
+        ;Stores the new instrument pointer, if Speed allows it.
+        ;--------------------------------------------------
+PLY_AKM_PSS_Shared_StoreInstrumentPointer:
+        ;Checks the Instrument speed, and only stores the Instrument new pointer if the speed is reached.
+        ld a,PLY_AKM_Data_OffsetInstrumentCurrentStep (ix)
+        cp PLY_AKM_Data_OffsetInstrumentSpeed (ix)
+        jr nc,PLY_AKM_PSS_S_SpeedReached
+        ;Increases the current step.
+        inc PLY_AKM_Data_OffsetInstrumentCurrentStep (ix)
+        ret
+PLY_AKM_PSS_S_SpeedReached:
+        ;Stores the Instrument new pointer, resets the speed counter.
+        ld PLY_AKM_Data_OffsetPtInstrument + 0 (ix),l
+        ld PLY_AKM_Data_OffsetPtInstrument + 1 (ix),h
+        ld PLY_AKM_Data_OffsetInstrumentCurrentStep (ix),#0x00
+        ret
+
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+
+        ;Software and Hardware.
+        ;----------------------------
+PLY_AKM_PSS_SoftAndHard:
+        ;Reads the envelope bit, the possible pitch, and sets the software period accordingly.
+        call PLY_AKM_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv
+        ;Reads the hardware period.
+        ld a,(hl)
+        ld (PLY_AKM_Reg11),a
+        inc hl
+        ld a,(hl)
+        ld (PLY_AKM_Reg12),a
+        inc hl
+
+        jr PLY_AKM_PSS_Shared_StoreInstrumentPointer
+
+
+        ;Software to Hardware.
+        ;-------------------------
+PLY_AKM_PSS_SoftwareToHardware:
+        call PLY_AKM_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv
+
+        ;Now we can calculate the hardware period thanks to the ratio (contray to LW, it is NOT inverted, we can use it as-is).
+        ld a,b
+        rlca
+        rlca
+        rlca
+        rlca
+        and #0b111
+        exx
+                jr z,PLY_AKM_PSS_STH_RatioEnd
+PLY_AKM_PSS_STH_RatioLoop:
+                srl h
+                rr l
+                dec a 
+                jr nz,PLY_AKM_PSS_STH_RatioLoop
+                ;If carry, rounds the period.
+                jr nc,PLY_AKM_PSS_STH_RatioEnd
+                inc hl
+PLY_AKM_PSS_STH_RatioEnd:
+                ld a,l
+                ld (PLY_AKM_Reg11),a
+                ld a,h
+                ld (PLY_AKM_Reg12),a
+        exx
+
+        jr PLY_AKM_PSS_Shared_StoreInstrumentPointer
+
+;A shared code for hardware sound.
+;Reads the envelope bit in bit 1, arpeggio in bit 7 pitch in bit 2 from A. If pitch present, adds it to BC'.
+;Converts the note to period, adds the instrument pitch, sets the software period of the channel.
+;Also sets the hardware volume, and sets the hardware curve.
+PLY_AKM_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv:
+        ;Envelope bit? R13 = 8 + 2 * (envelope bit?). Allows to have hardware envelope to 8 or 0xa.
+        ;Shifted by 2 to the right, bit 1 is now envelope bit, which is perfect for us.
+        and #0b10
+        add a,#0x08
+        ld (PLY_AKM_SetReg13 + PLY_AKM_Offset1b),a
+
+        ;Volume to 16 to trigger the hardware envelope.
+        ld PLY_AKM_Registers_OffsetVolume (iy),#0x10
+
+        ;Arpeggio?
+        xor a                   ;Default arpeggio.
+                       .if PLY_AKM_ArpeggioInHardwareInstrument  ;CONFIG SPECIFIC
+        bit 7,b                 ;Not shifted yet.
+        jr z,PLY_AKM_PSS_Shared_REnvBAP_AfterArpeggio
+        ;Reads the Arpeggio.
+        ld a,(hl)
+        inc hl
+PLY_AKM_PSS_Shared_REnvBAP_AfterArpeggio:
+                       .endif ;PLY_AKM_ArpeggioInHardwareInstrument
+        ;Calculates the software period.
+        call PLY_AKM_CalculatePeriodForBaseNote
+
+        ;Pitch?
+                       .if PLY_AKM_PitchInHardwareInstrument  ;CONFIG SPECIFIC
+        bit 2,b         ;Not shifted yet.
+        call nz,PLY_AKM_ReadPitchAndAddToPeriod
+                       .endif ;PLY_AKM_PitchInHardwareInstrument
+
+        ;Stores the new period of this channel.
+        exx
+                ld PLY_AKM_Registers_OffsetSoftwarePeriodLSB (iy),l
+                ld PLY_AKM_Registers_OffsetSoftwarePeriodMSB (iy),h
+        exx
+        ret
+
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+;Decreases the given volume (encoded in possibly more then 4 bits). If <0, forced to 0.
+;IN:    A = volume, not ANDed.
+;OUT:   A = new volume.
+PLY_AKM_PSS_Shared_AdjustVolume:
+        and #0b1111
+        sub PLY_AKM_Data_OffsetTrackInvertedVolume (ix)
+        ret nc
+        xor a
+        ret
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+
+;Reads and stores the noise pointed by HL, opens the noise channel.
+;IN:    HL = instrument data where the noise is.
+;OUT:   HL = HL++.
+;MOD:   A.
+               .if PLY_AKM_USE_Noise          ;CONFIG SPECIFIC
+PLY_AKM_PSS_ReadNoise:
+        ld a,(hl)
+        inc hl
+        ld (PLY_AKM_NoiseRegister),a
+        res 5,c                 ;Opens the noise channel.
+        ret
+               .endif ;PLY_AKM_USE_Noise
+                
+;Calculates the period according to the base note and put it in BC'. Used by both software and hardware codes.
+;IN:    DE' = period table.
+;       A = instrument arpeggio (0 if not used).
+;OUT:   HL' = period.
+;MOD:   A
+PLY_AKM_CalculatePeriodForBaseNote:
+        ;Gets the period from the current note.
+        exx
+                ld h,#0x00
+                add a,PLY_AKM_Data_OffsetBaseNote (ix)                         ;Adds the instrument Arp to the base note (including the transposition).
+                               .if PLY_CFG_UseEffect_ArpeggioTable            ;CONFIG SPECIFIC
+                add PLY_AKM_Data_OffsetCurrentArpeggioValue (ix)               ;Adds the Arpeggio Table effect.
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+                ;Finds the period from a single line of octave look-up table. This is slow...
+                ;IN:    DE = PeriodTable.
+                ;       A = note (>=0).
+                ;OUT:   HL = period.
+                ;       DE unmodified.
+                ;       BC modified.
+
+                ;Finds the octave.
+                ld bc,#255 * 256 + 12            ;B = Octave (>=0). Will be increased just below.
+PLY_AKM_FindOctave_Loop:
+                inc b           ;Next octave.
+                sub c
+                jr nc,PLY_AKM_FindOctave_Loop
+                add a,c         ;Compensates the first iteration that may not have been useful.
+        
+                ;A = note inside the octave. Gets the period for the note, for the lowest octave.
+                add a,a
+                ld l,a
+                ld h,#0x00
+                add hl,de       ;Points on the period on the lowest octave.
+                ld a,(hl)
+                inc hl
+                ld h,(hl)       ;HL is the period on the lowest octave.
+                ld l,a
+                ;Divides the period as long as we haven't reached the octave.
+                ld a,b
+                or a
+                jr z,PLY_AKM_FindOctave_OctaveShiftLoop_Finished
+PLY_AKM_FindOctave_OctaveShiftLoop:
+                srl h
+                rr l
+                djnz PLY_AKM_FindOctave_OctaveShiftLoop          ;Fortunately, does not modify the carry, used below.
+PLY_AKM_FindOctave_OctaveShiftLoop_Finished:
+                ;Rounds the period at the last iteration.
+                jr nc,PLY_AKM_FindOctave_Finished
+                inc hl
+PLY_AKM_FindOctave_Finished:
+
+                ;Adds the Pitch Table value, if used.
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+                ld a,PLY_AKM_Data_OffsetIsPitchTableUsed (ix)
+                or a
+                jr z,PLY_AKM_CalculatePeriodForBaseNote_NoPitchTable
+                ld c,PLY_AKM_Data_OffsetCurrentPitchTableValue + 0 (ix)
+                ld b,PLY_AKM_Data_OffsetCurrentPitchTableValue + 1 (ix)
+                add hl,bc
+PLY_AKM_CalculatePeriodForBaseNote_NoPitchTable:
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+                ;Adds the Track Pitch.
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+                ld c,PLY_AKM_Data_OffsetTrackPitchInteger + 0 (ix)
+                ld b,PLY_AKM_Data_OffsetTrackPitchInteger + 1 (ix)
+                add hl,bc
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+        exx
+        ret
+
+                       .if PLY_AKM_PitchInInstrument  ;CONFIG SPECIFIC
+;Reads the pitch in the Instruments (16 bits) and adds it to HL', which should contain the software period.
+;IN:    HL = points on the pitch value.
+;OUT:   HL = points after the pitch.
+;MOD:   A, BC', HL' updated.
+PLY_AKM_ReadPitchAndAddToPeriod:
+        ;Reads 2 * 8 bits for the pitch. Slow...
+        ld a,(hl)
+        inc hl
+        exx
+                ld c,a                  ;Adds the read pitch to the note period.
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                ld b,a
+                add hl,bc
+        exx
+        ret
+                       .endif ;PLY_AKM_PitchInInstrument
+
+
+
+
+
+
+
+;---------------------------------------------------------------------
+;Effect management.
+;---------------------------------------------------------------------
+
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+                        
+;IN:    HL = points after the first byte.
+;       A = data of the first byte on bits 0-3, the other bits are 0.
+;       Carry = 0.
+;       Z flag = 1 if the data is 0.
+;       DE'= Instrument Table (not useful here). Do not modify!
+;       IX = data block of the Track.
+;       B = Do not modify!
+;OUT:   HL = points after the data of the effect (maybe nothing to do).
+;       Each effect must jump to PLY_AKM_RT_ReadEffect_Return.
+
+                               .if PLY_CFG_UseEffect_Reset           ;CONFIG SPECIFIC.
+;Clears all the effects (volume, pitch table, arpeggio table).
+PLY_AKM_EffectResetWithVolume:
+        ;Inverted volume.
+                                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetTrackInvertedVolume (ix),a
+                                       .endif ;PLY_CFG_UseEffect_SetVolume
+        xor a
+        ;The inverted volume is managed above, so don't change it.
+                                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetIsPitchUpDownUsed (ix),a
+                                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+                                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetIsArpeggioTableUsed (ix),a
+        ld PLY_AKM_Data_OffsetCurrentArpeggioValue (ix),a      ;Contrary to the Pitch, the value must be reset.
+                                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        ld PLY_AKM_Data_OffsetIsPitchTableUsed (ix),a
+                                       .endif ;PLY_CFG_UseEffect_PitchTable
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_Reset
+
+
+;Changes the volume.
+                               .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+PLY_AKM_EffectVolume:
+        ld PLY_AKM_Data_OffsetTrackInvertedVolume (ix),a
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_SetVolume
+
+                               .if PLY_CFG_UseEffect_ForceInstrumentSpeed        ;CONFIG SPECIFIC
+;Forces the speed of the Instrument. The current step is NOT changed.
+PLY_AKM_EffectForceInstrumentSpeed:
+        call PLY_AKM_EffectReadIfEscape         ;Makes sure the data is 0-14,.else 15 means: read the next escape value.
+        ld PLY_AKM_Data_OffsetInstrumentSpeed (ix),a
+        
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+;Forces the speed of the Pitch. The current step is NOT changed.
+PLY_AKM_EffectForcePitchSpeed:
+        call PLY_AKM_EffectReadIfEscape         ;Makes sure the data is 0-14,.else 15 means: read the next escape value.
+        ld PLY_AKM_Data_OffsetPitchCurrentSpeed (ix),a
+        ;ld PLY_AKM_Data_OffsetPitchCurrentStep (ix),a                ;No need to force next note of the Arpeggio. Faster, and more compliant with the C++ player.
+        
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+        
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+;Forces the speed of the Arpeggio. The current step is NOT changed.
+PLY_AKM_EffectForceArpeggioSpeed:
+        call PLY_AKM_EffectReadIfEscape         ;Makes sure the data is 0-14,.else 15 means: read the next escape value.
+        ld PLY_AKM_Data_OffsetArpeggioCurrentSpeed (ix),a
+        ;ld PLY_AKM_Data_OffsetArpeggioCurrentStep (ix),a             ;No need to force next note of the Arpeggio. Faster, and more compliant with the C++ player.
+        
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+
+
+;Effect table. Each entry jumps to an effect management code.
+;Put after the code above so that the JR are within bound.
+PLY_AKM_EffectTable:
+                               .if PLY_CFG_UseEffect_Reset           ;CONFIG SPECIFIC.
+        jr PLY_AKM_EffectResetWithVolume                         ;000
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_Reset
+                                
+                               .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectVolume                                  ;001
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_SetVolume
+        
+                               .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectPitchUpDown                             ;010
+                               .else
+                                jr $
+                               .endif ;PLY_AKM_USE_EffectPitchUpDown
+
+                               .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectArpeggioTable                           ;011
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                               
+                               .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectPitchTable                              ;100
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+        
+                               .if PLY_CFG_UseEffect_ForceInstrumentSpeed        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectForceInstrumentSpeed                    ;101
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_ForceInstrumentSpeed
+        
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectForceArpeggioSpeed                      ;110
+                               .else
+                                jr $
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+                   
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+        jr PLY_AKM_EffectForcePitchSpeed                         ;111
+                               .else
+                                ;jr $   ;Last one. No need to encode it.
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed             
+
+
+                               .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+;Pitch up/down effect, activation or stop.
+PLY_AKM_EffectPitchUpDown:
+        rra     ;Pitch present or pitch stop?
+        jr nc,PLY_AKM_EffectPitchUpDown_Deactivated
+        ;Activates the effect.
+        ld PLY_AKM_Data_OffsetIsPitchUpDownUsed (ix),#0xff
+        ld a,(hl)
+        inc hl
+        ld PLY_AKM_Data_OffsetTrackPitchSpeed + 0 (ix),a
+        ld a,(hl)
+        inc hl
+        ld PLY_AKM_Data_OffsetTrackPitchSpeed + 1 (ix),a
+        jp PLY_AKM_RT_ReadEffect_Return
+PLY_AKM_EffectPitchUpDown_Deactivated:
+        ;Pitch stop.
+        ld PLY_AKM_Data_OffsetIsPitchUpDownUsed (ix),#0x00
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_AKM_USE_EffectPitchUpDown
+                        
+
+                               .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+;Arpeggio table effect, activation or stop.
+PLY_AKM_EffectArpeggioTable:
+        call PLY_AKM_EffectReadIfEscape         ;Makes sure the data is 0-14,.else 15 means: read the next escape value.
+        ld PLY_AKM_Data_OffsetIsArpeggioTableUsed (ix),a       ;Sets to 0 if the Arpeggio is stopped, or any other value if it starts.
+        jr z,PLY_AKM_EffectArpeggioTable_Stop
+
+        ;Gets the Arpeggio address.
+        add a,a
+        exx
+                ld l,a
+                ld h,#0x00
+        ;BC is modified, will be restored below.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PtArpeggios: ld bc,#0x0000            ;Arpeggio table does not encode entry 0, but the pointer points two bytes earlier to compensate.
+       .else
+        ld bc,(PLY_AKM_PtArpeggios)
+       .endif
+                add hl,bc
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a
+                ld a,(hl)               ;Reads the speed.
+                inc hl
+                ld PLY_AKM_Data_OffsetArpeggioOriginalSpeed (ix),a
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+                ld PLY_AKM_Data_OffsetArpeggioCurrentSpeed (ix),a
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+                ld PLY_AKM_Data_OffsetPtArpeggioTable + 0 (ix),l
+                ld PLY_AKM_Data_OffsetPtArpeggioTable + 1 (ix),h
+                
+                ld bc,(PLY_AKM_NoteIndexTable + PLY_AKM_Offset1b)
+        exx
+
+        ;Resets the offset of the Arpeggio to restart the Arpeggio, and forces a step to read immediately.
+        xor a
+        ld PLY_AKM_Data_OffsetPtArpeggioOffset (ix),a
+        ld PLY_AKM_Data_OffsetArpeggioCurrentStep (ix),a
+        jp PLY_AKM_RT_ReadEffect_Return
+PLY_AKM_EffectArpeggioTable_Stop:
+        ;Contrary to the Pitch, the Arpeggio must also be set to 0 when stopped.
+        ld PLY_AKM_Data_OffsetCurrentArpeggioValue (ix),a
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+                               .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+;Pitch table effect, activation or stop.
+;This is almost exactly the same code as for the Arpeggio, but I can't find a way to share it...
+PLY_AKM_EffectPitchTable:
+        call PLY_AKM_EffectReadIfEscape         ;Makes sure the data is 0-14,.else 15 means: read the next escape value.
+        ld PLY_AKM_Data_OffsetIsPitchTableUsed (ix),a  ;Sets to 0 if the Pitch is stopped, or any other value if it starts.
+        jp z,PLY_AKM_RT_ReadEffect_Return
+        
+        ;Gets the Pitch address.
+        add a,a
+        exx
+                ld l,a
+                ld h,#0x00
+        ;BC is modified, will be restored below.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PtPitches: ld bc,#0x0000            ;Pitch table does not encode entry 0, but the pointer points two bytes earlier to compensate.
+       .else
+        ld bc,(PLY_AKM_PtPitches)
+       .endif
+                add hl,bc
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a
+                ld a,(hl)               ;Reads the speed.
+                inc hl
+                ld PLY_AKM_Data_OffsetPitchOriginalSpeed (ix),a
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+                ld PLY_AKM_Data_OffsetPitchCurrentSpeed (ix),a
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+                ld PLY_AKM_Data_OffsetPtPitchTable + 0 (ix),l
+                ld PLY_AKM_Data_OffsetPtPitchTable + 1 (ix),h
+                
+                ld bc,(PLY_AKM_NoteIndexTable + PLY_AKM_Offset1b)
+        exx
+
+        ;Resets the offset of the Pitch to restart the Pitch, and forces a step to read immediately.
+        xor a
+        ld PLY_AKM_Data_OffsetPtPitchOffset (ix),a
+        ld PLY_AKM_Data_OffsetPitchCurrentStep (ix),a
+        jp PLY_AKM_RT_ReadEffect_Return
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+
+
+
+
+
+        
+;Reads the next escape byte if A is 15,.else returns A (0-14).
+;IN:    HL= data in the effect
+;       A = 0-15. bit 7-4 must be 0.
+;OUT:   HL= may be increased if an escape value is read.
+;       A = the 8-bit value.
+PLY_AKM_EffectReadIfEscape:
+        cp #0x0f
+        ret c
+        ;Reads the escape value.
+        ld a,(hl)
+        inc hl
+        ret
+
+                       .endif ;PLY_CFG_UseEffects
+                        
+                        
+;---------------------------------------------------------------------
+;Data blocks for the three channels. Make sure NOTHING is added between, as the init clears everything!
+;---------------------------------------------------------------------
+
+        ;Specific generic data for ROM (non-related to channels).
+        ;Important: must be declared BEFORE the channel-specific data.
+       .if PLY_AKM_Rom
+PLY_AKM_PtInstruments  .dw      #0x0000
+PLY_AKM_PtArpeggios    .dw      #0x0000
+PLY_AKM_PtPitches      .dw      #0x0000
+PLY_AKM_PtLinker       .dw      #0x0000
+PLY_AKM_NoteIndexTable .dw      #0x0000
+PLY_AKM_TrackIndex     .dw      #0x0000
+PLY_AKM_SaveSP         .dw      #0x0000
+        
+PLY_AKM_DefaultStartNoteInTracks       .db      #0x00
+PLY_AKM_DefaultStartInstrumentInTracks .db      #0x00
+PLY_AKM_DefaultStartWaitInTracks       .db      #0x00
+PLY_AKM_PrimaryInstrument              .db      #0x00
+PLY_AKM_SecondaryInstrument            .db      #0x00
+PLY_AKM_PrimaryWait                    .db      #0x00
+PLY_AKM_SecondaryWait                  .db      #0x00
+PLY_AKM_FlagNoteAndEffectInCell        .db      #0x00
+                                       .db      #0x00
+PLY_AKM_PatternRemainingHeight         .db      #0x00
+PLY_AKM_LinkerPreviousRemainingHeight  .db      #0x00
+PLY_AKM_Speed                          .db      #0x00
+PLY_AKM_TickCounter                    .db      #0x00
+PLY_AKM_SetReg13Old                    .db      #0x00
+PLY_AKM_SetReg13                       .db      #0x00
+PLY_AKM_RT_ReadEffectsFlag             .db      #0x00
+        
+        ;RET table: db register, db value, dw code to jump to once the value is read.
+        ;MUST be consistent with the RAM buffer!
+.equ PLY_AKM_Registers_RetTable , PLY_AKM_ROM_Buffer + counter
+        ;Reg 8.
+PLY_AKM_Track1_Registers                   .db      #0x00
+PLY_AKM_Track1_Volume                      .db      #0x00
+PLY_AKM_Track1_VolumeRet                   .dw      #0x0000
+        ;Reg 0.
+PLY_AKM_Track1_SoftwarePeriodLSBRegister   .db      #0x00
+PLY_AKM_Track1_SoftwarePeriodLSB           .db      #0x00
+PLY_AKM_Track1_SoftwarePeriodLSBRet        .dw      #0x0000
+        ;Reg 1.
+PLY_AKM_Track1_SoftwarePeriodMSBRegister   .db      #0x00
+PLY_AKM_Track1_SoftwarePeriodMSB           .db      #0x00
+PLY_AKM_Track1_SoftwarePeriodMSBRet        .dw      #0x0000
+        
+        ;Reg 9.
+PLY_AKM_Track2_Registers                   .db      #0x00
+PLY_AKM_Track2_Volume                      .db      #0x00
+PLY_AKM_Track2_VolumeRet                   .dw      #0x0000
+        ;Reg 2.
+PLY_AKM_Track2_SoftwarePeriodLSBRegister   .db      #0x00
+PLY_AKM_Track2_SoftwarePeriodLSB           .db      #0x00
+PLY_AKM_Track2_SoftwarePeriodLSBRet        .dw      #0x0000
+        ;Reg 3.
+PLY_AKM_Track2_SoftwarePeriodMSBRegister   .db      #0x00
+PLY_AKM_Track2_SoftwarePeriodMSB           .db      #0x00
+PLY_AKM_Track2_SoftwarePeriodMSBRet        .dw      #0x0000
+        
+        ;Reg 10.
+PLY_AKM_Track3_Registers                   .db      #0x00
+PLY_AKM_Track3_Volume                      .db      #0x00
+PLY_AKM_Track3_VolumeRet                   .dw      #0x0000
+        ;Reg 4.
+PLY_AKM_Track3_SoftwarePeriodLSBRegister   .db      #0x00
+PLY_AKM_Track3_SoftwarePeriodLSB           .db      #0x00
+PLY_AKM_Track3_SoftwarePeriodLSBRet        .dw      #0x0000
+        ;Reg 5.
+PLY_AKM_Track3_SoftwarePeriodMSBRegister   .db      #0x00
+PLY_AKM_Track3_SoftwarePeriodMSB           .db      #0x00
+PLY_AKM_Track3_SoftwarePeriodMSBRet        .dw      #0x0000
+        
+       .if PLY_AKM_USE_NoiseRegister          ;CONFIG SPECIFIC
+                ;Reg 6.
+PLY_AKM_NoiseRegisterPlaceholder           .db      #0x00
+PLY_AKM_NoiseRegister                      .db      #0x00     ;Misnomer: this is the value.
+PLY_AKM_NoiseRegisterRet                   .dw      #0x0000
+       .endif
+        
+        ;Reg 7.
+PLY_AKM_MixerRegisterPlaceholder           .db      #0x00
+PLY_AKM_MixerRegister                      .db      #0x00     ;Misnomer: this is the value.
+       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+PLY_AKM_MixerRegisterRet                   .dw      #0x0000
+                ;Reg 11.
+PLY_AKM_Reg11Register                      .db      #0x00
+PLY_AKM_Reg11                              .db      #0x00
+PLY_AKM_Reg11Ret                           .dw      #0x0000
+                ;Reg 12.
+PLY_AKM_Reg12Register                      .db      #0x00
+PLY_AKM_Reg12                              .db      #0x00
+PLY_AKM_Reg12Ret                           .dw      #0x0000
+                ;This one is a trick to send the register after R13 is managed.
+PLY_AKM_Reg12Ret2                          .dw      #0x0000
+       .endif
+        
+PLY_AKM_RegsFinalRet                       .dw      #0x0000
+        
+        
+        ;The buffers for sound effects (if any), for each channel. They are treated apart, because they must be consecutive.
+               .if PLY_AKM_MANAGE_SOUND_EFFECTS
+PLY_AKM_PtSoundEffectTable                 .dw      #0x0000
+
+PLY_AKM_Channel1_SoundEffectData           .dw      #0x0000
+PLY_AKM_Channel1_SoundEffectInvertedVolume .db      #0x00
+PLY_AKM_Channel1_SoundEffectCurrentStep    .db      #0x00
+PLY_AKM_Channel1_SoundEffectSpeed          .db      #0x00
+PLY_AKM_Channel2_SoundEffectData           .dw      #0x0000
+PLY_AKM_Channel2_SoundEffectInvertedVolume .db      #0x00
+PLY_AKM_Channel2_SoundEffectCurrentStep    .db      #0x00
+PLY_AKM_Channel2_SoundEffectSpeed          .db      #0x00
+PLY_AKM_Channel3_SoundEffectData           .dw      #0x0000
+PLY_AKM_Channel3_SoundEffectInvertedVolume .db      #0x00
+PLY_AKM_Channel3_SoundEffectCurrentStep    .db      #0x00
+PLY_AKM_Channel3_SoundEffectSpeed          .db      #0x00
+               .endif ;PLY_AKM_MANAGE_SOUND_EFFECTS
+        
+        
+       .endif ;PLY_AKM_Rom
+        
+;Data block for channel 1.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track1_Data:
+       .else
+                counterStartInTrackData = counter                    ;Duplicates the counter value to determine later the size of the track buffer.
+       .endif
+PLY_AKM_Track1_WaitEmptyCell:              .db      #0x00            ;How many empty cells have to be waited. 0 = none.
+       .if PLY_AKM_Rom
+.equ PLY_AKM_Track1_Data , PLY_AKM_Track1_WaitEmptyCell
+       .endif
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+PLY_AKM_Track1_Transposition:              .db      #0x00
+                       .endif ;PLY_CFG_UseTranspositions
+PLY_AKM_Track1_PtStartTrack:               .dw      #0x0000            ;Points at the start of the Track to read. Does not change, unless the Track changes.
+PLY_AKM_Track1_PtTrack:                    .dw      #0x0000            ;Points on the next Cell of the Track to read. Evolves.
+PLY_AKM_Track1_BaseNote:                   .db      #0x00              ;Base note, such as the note played. The transposition IS included.
+PLY_AKM_Track1_EscapeNote:                 .db      #0x00              ;The escape note. The transposition is NOT included.
+PLY_AKM_Track1_EscapeInstrument:           .db      #0x00              ;The escape instrument.
+PLY_AKM_Track1_EscapeWait:                 .db      #0x00              ;The escape wait.
+PLY_AKM_Track1_PtInstrument:               .dw      #0x0000            ;Points on the Instrument, evolves.
+PLY_AKM_Track1_InstrumentCurrentStep:      .db      #0x00              ;The current step on the Instrument (>=0, till it reaches the Speed).
+PLY_AKM_Track1_InstrumentSpeed:            .db      #0x00              ;The Instrument speed (>=0).
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+PLY_AKM_Track1_TrackInvertedVolume:        .db      #0x00
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+PLY_AKM_Track1_IsPitchUpDownUsed:          .db      #0x00               ;>0 if a Pitch Up/Down is currently in use.
+PLY_AKM_Track1_TrackPitchInteger:          .dw      #0x0000             ;The integer part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track1_TrackPitchDecimal:          .db      #0x00               ;The decimal part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track1_TrackPitchSpeed:            .dw      #0x0000             ;The integer and decimal part of the Track pitch speed. Is added to the Track Pitch every frame.
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+PLY_AKM_Track1_IsArpeggioTableUsed:        .db      #0x00               ;>0 if an Arpeggio Table is currently in use.
+PLY_AKM_Track1_PtArpeggioTable:            .dw      #0x0000             ;Point on the base of the Arpeggio table, does not evolve.
+PLY_AKM_Track1_PtArpeggioOffset:           .db      #0x00               ;Increases over the Arpeggio.
+PLY_AKM_Track1_ArpeggioCurrentStep:        .db      #0x00               ;The arpeggio current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track1_ArpeggioCurrentSpeed:       .db      #0x00               ;The arpeggio speed (>=0, may be changed by the Force Arpeggio Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+PLY_AKM_Track1_ArpeggioOriginalSpeed:      .db      #0x00               ;The arpeggio original speed (>=0, NEVER changes for this arpeggio).
+PLY_AKM_Track1_CurrentArpeggioValue:       .db      #0x00               ;Value from the Arpeggio to add to the base note. Read even if the Arpeggio effect is deactivated.
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+PLY_AKM_Track1_IsPitchTableUsed:           .db      #0x00               ;>0 if a Pitch Table is currently in use.
+PLY_AKM_Track1_PtPitchTable:               .dw      #0x0000             ;Points on the base of the Pitch table, does not evolve.
+PLY_AKM_Track1_PtPitchOffset:              .db      #0x00               ;Increases over the Pitch.
+PLY_AKM_Track1_PitchCurrentStep:           .db      #0x00               ;The Pitch current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track1_PitchCurrentSpeed:          .db      #0x00               ;The Pitch speed (>=0, may be changed by the Force Pitch Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+PLY_AKM_Track1_PitchOriginalSpeed:         .db      #0x00               ;The Pitch original speed (>=0, NEVER changes for this pitch).
+PLY_AKM_Track1_CurrentPitchTableValue:     .dw      #0x0000             ;16 bit value from the Pitch to add to the base note. Not read if the Pitch effect is deactivated.
+
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track1_Data_End:
+.equ PLY_AKM_Track1_Data_Size , PLY_AKM_Track1_Data_End - PLY_AKM_Track1_Data
+       .else
+PLY_AKM_Track1_Data_Size = counter - counterStartInTrackData
+PLY_AKM_Track1_Data_End = PLY_AKM_Track1_Data + PLY_AKM_Track1_Data_Size
+       .endif
+
+.equ PLY_AKM_Data_OffsetWaitEmptyCell                , PLY_AKM_Track1_WaitEmptyCell - PLY_AKM_Track1_Data
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetTransposition                , PLY_AKM_Track1_Transposition - PLY_AKM_Track1_Data
+                       .endif ;PLY_CFG_UseTranspositions
+.equ PLY_AKM_Data_OffsetPtStartTrack                  , PLY_AKM_Track1_PtStartTrack - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtTrack                       , PLY_AKM_Track1_PtTrack - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetBaseNote                      , PLY_AKM_Track1_BaseNote - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetEscapeNote                    , PLY_AKM_Track1_EscapeNote - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetEscapeInstrument              , PLY_AKM_Track1_EscapeInstrument - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetEscapeWait                    , PLY_AKM_Track1_EscapeWait - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetSecondaryInstrument           , PLY_AKM_Track1_EscapeWait - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtInstrument                  , PLY_AKM_Track1_PtInstrument - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetInstrumentCurrentStep         , PLY_AKM_Track1_InstrumentCurrentStep - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetInstrumentSpeed               , PLY_AKM_Track1_InstrumentSpeed - PLY_AKM_Track1_Data
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetTrackInvertedVolume          , PLY_AKM_Track1_TrackInvertedVolume - PLY_AKM_Track1_Data
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetIsPitchUpDownUsed             , PLY_AKM_Track1_IsPitchUpDownUsed - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetTrackPitchInteger             , PLY_AKM_Track1_TrackPitchInteger - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetTrackPitchDecimal             , PLY_AKM_Track1_TrackPitchDecimal - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetTrackPitchSpeed               , PLY_AKM_Track1_TrackPitchSpeed - PLY_AKM_Track1_Data
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetIsArpeggioTableUsed           , PLY_AKM_Track1_IsArpeggioTableUsed - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtArpeggioTable               , PLY_AKM_Track1_PtArpeggioTable - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtArpeggioOffset              , PLY_AKM_Track1_PtArpeggioOffset - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetArpeggioCurrentStep           , PLY_AKM_Track1_ArpeggioCurrentStep - PLY_AKM_Track1_Data
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetArpeggioCurrentSpeed          , PLY_AKM_Track1_ArpeggioCurrentSpeed - PLY_AKM_Track1_Data
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+.equ PLY_AKM_Data_OffsetArpeggioOriginalSpeed         , PLY_AKM_Track1_ArpeggioOriginalSpeed - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetCurrentArpeggioValue          , PLY_AKM_Track1_CurrentArpeggioValue - PLY_AKM_Track1_Data
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetIsPitchTableUsed              , PLY_AKM_Track1_IsPitchTableUsed - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtPitchTable                  , PLY_AKM_Track1_PtPitchTable - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPtPitchOffset                 , PLY_AKM_Track1_PtPitchOffset - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetPitchCurrentStep              , PLY_AKM_Track1_PitchCurrentStep - PLY_AKM_Track1_Data
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+.equ PLY_AKM_Data_OffsetPitchCurrentSpeed             , PLY_AKM_Track1_PitchCurrentSpeed - PLY_AKM_Track1_Data
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+.equ PLY_AKM_Data_OffsetPitchOriginalSpeed            , PLY_AKM_Track1_PitchOriginalSpeed - PLY_AKM_Track1_Data
+.equ PLY_AKM_Data_OffsetCurrentPitchTableValue        , PLY_AKM_Track1_CurrentPitchTableValue - PLY_AKM_Track1_Data
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+;Data block for channel 2.
+;Data block for channel 2.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track2_Data:
+       .else
+                counterStartInTrackData = counter                    ;Duplicates the counter value to determine later the size of the track buffer.
+       .endif
+PLY_AKM_Track2_WaitEmptyCell:              .db      #0x00              ;How many empty cells have to be waited. 0 = none.
+       .if PLY_AKM_Rom
+.equ PLY_AKM_Track2_Data , PLY_AKM_Track2_WaitEmptyCell
+       .endif
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+PLY_AKM_Track2_Transposition:              .db      #0x00
+                       .endif ;PLY_CFG_UseTranspositions
+PLY_AKM_Track2_PtStartTrack:               .dw      #0x0000            ;Points at the start of the Track to read. Does not change, unless the Track changes.
+PLY_AKM_Track2_PtTrack:                    .dw      #0x0000            ;Points on the next Cell of the Track to read. Evolves.
+PLY_AKM_Track2_BaseNote:                   .db      #0x00              ;Base note, such as the note played. The transposition IS included.
+PLY_AKM_Track2_EscapeNote:                 .db      #0x00              ;The escape note. The transposition is NOT included.
+PLY_AKM_Track2_EscapeInstrument:           .db      #0x00              ;The escape instrument.
+PLY_AKM_Track2_EscapeWait:                 .db      #0x00              ;The escape wait.
+PLY_AKM_Track2_PtInstrument:               .dw      #0x0000            ;Points on the Instrument, evolves.
+PLY_AKM_Track2_InstrumentCurrentStep:      .db      #0x00              ;The current step on the Instrument (>=0, till it reaches the Speed).
+PLY_AKM_Track2_InstrumentSpeed:            .db      #0x00              ;The Instrument speed (>=0).
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+PLY_AKM_Track2_TrackInvertedVolume:        .db      #0x00
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+PLY_AKM_Track2_IsPitchUpDownUsed:          .db      #0x00               ;>0 if a Pitch Up/Down is currently in use.
+PLY_AKM_Track2_TrackPitchInteger:          .dw      #0x0000             ;The integer part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track2_TrackPitchDecimal:          .db      #0x00               ;The decimal part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track2_TrackPitchSpeed:            .dw      #0x0000             ;The integer and decimal part of the Track pitch speed. Is added to the Track Pitch every frame.
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+PLY_AKM_Track2_IsArpeggioTableUsed:        .db      #0x00               ;>0 if an Arpeggio Table is currently in use.
+PLY_AKM_Track2_PtArpeggioTable:            .dw      #0x0000             ;Point on the base of the Arpeggio table, does not evolve.
+PLY_AKM_Track2_PtArpeggioOffset:           .db      #0x00               ;Increases over the Arpeggio.
+PLY_AKM_Track2_ArpeggioCurrentStep:        .db      #0x00               ;The arpeggio current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track2_ArpeggioCurrentSpeed:       .db      #0x00               ;The arpeggio speed (>=0, may be changed by the Force Arpeggio Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+PLY_AKM_Track2_ArpeggioOriginalSpeed:      .db      #0x00               ;The arpeggio original speed (>=0, NEVER changes for this arpeggio).
+PLY_AKM_Track2_CurrentArpeggioValue:       .db      #0x00               ;Value from the Arpeggio to add to the base note. Read even if the Arpeggio effect is deactivated.
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+PLY_AKM_Track2_IsPitchTableUsed:           .db      #0x00               ;>0 if a Pitch Table is currently in use.
+PLY_AKM_Track2_PtPitchTable:               .dw      #0x0000             ;Points on the base of the Pitch table, does not evolve.
+PLY_AKM_Track2_PtPitchOffset:              .db      #0x00               ;Increases over the Pitch.
+PLY_AKM_Track2_PitchCurrentStep:           .db      #0x00               ;The Pitch current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track2_PitchCurrentSpeed:          .db      #0x00               ;The Pitch speed (>=0, may be changed by the Force Pitch Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+PLY_AKM_Track2_PitchOriginalSpeed:         .db      #0x00               ;The Pitch original speed (>=0, NEVER changes for this pitch).
+PLY_AKM_Track2_CurrentPitchTableValue:     .dw      #0x0000             ;16 bit value from the Pitch to add to the base note. Not read if the Pitch effect is deactivated.
+
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track2_Data_End:
+.equ PLY_AKM_Track2_Data_Size , PLY_AKM_Track2_Data_End - PLY_AKM_Track2_Data
+       .else
+PLY_AKM_Track2_Data_Size = counter - counterStartInTrackData
+PLY_AKM_Track2_Data_End = PLY_AKM_Track2_Data + PLY_AKM_Track2_Data_Size
+       .endif
+
+.equ PLY_AKM_Track2_WaitEmptyCell       , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetWaitEmptyCell
+.equ PLY_AKM_Track2_PtTrack             , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetPtTrack
+.equ PLY_AKM_Track2_PtInstrument        , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetPtInstrument
+.equ PLY_AKM_Track2_EscapeNote          , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetEscapeNote
+.equ PLY_AKM_Track2_EscapeInstrument    , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetEscapeInstrument
+.equ PLY_AKM_Track2_EscapeWait          , PLY_AKM_Track2_Data + PLY_AKM_Data_OffsetEscapeWait
+
+;Data block for channel 3.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track3_Data:
+       .else
+                counterStartInTrackData = counter                    ;Duplicates the counter value to determine later the size of the track buffer.
+       .endif
+PLY_AKM_Track3_WaitEmptyCell:              .db      #0x00              ;How many empty cells have to be waited. 0 = none.
+       .if PLY_AKM_Rom
+.equ PLY_AKM_Track3_Data , PLY_AKM_Track3_WaitEmptyCell
+       .endif
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+PLY_AKM_Track3_Transposition:              .db      #0x00
+                       .endif ;PLY_CFG_UseTranspositions
+PLY_AKM_Track3_PtStartTrack:               .dw      #0x0000            ;Points at the start of the Track to read. Does not change, unless the Track changes.
+PLY_AKM_Track3_PtTrack:                    .dw      #0x0000            ;Points on the next Cell of the Track to read. Evolves.
+PLY_AKM_Track3_BaseNote:                   .db      #0x00              ;Base note, such as the note played. The transposition IS included.
+PLY_AKM_Track3_EscapeNote:                 .db      #0x00              ;The escape note. The transposition is NOT included.
+PLY_AKM_Track3_EscapeInstrument:           .db      #0x00              ;The escape instrument.
+PLY_AKM_Track3_EscapeWait:                 .db      #0x00              ;The escape wait.
+PLY_AKM_Track3_PtInstrument:               .dw      #0x0000            ;Points on the Instrument, evolves.
+PLY_AKM_Track3_InstrumentCurrentStep:      .db      #0x00              ;The current step on the Instrument (>=0, till it reaches the Speed).
+PLY_AKM_Track3_InstrumentSpeed:            .db      #0x00              ;The Instrument speed (>=0).
+                       .if PLY_CFG_UseEffect_SetVolume        ;CONFIG SPECIFIC
+PLY_AKM_Track3_TrackInvertedVolume:        .db      #0x00
+                       .endif ;PLY_CFG_UseEffect_SetVolume
+                       .if PLY_AKM_USE_EffectPitchUpDown        ;CONFIG SPECIFIC
+PLY_AKM_Track3_IsPitchUpDownUsed:          .db      #0x00               ;>0 if a Pitch Up/Down is currently in use.
+PLY_AKM_Track3_TrackPitchInteger:          .dw      #0x0000             ;The integer part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track3_TrackPitchDecimal:          .db      #0x00               ;The decimal part of the Track pitch. Evolves as the pitch goes up/down.
+PLY_AKM_Track3_TrackPitchSpeed:            .dw      #0x0000             ;The integer and decimal part of the Track pitch speed. Is added to the Track Pitch every frame.
+                       .endif ;PLY_AKM_USE_EffectPitchUpDown
+                       .if PLY_CFG_UseEffect_ArpeggioTable        ;CONFIG SPECIFIC
+PLY_AKM_Track3_IsArpeggioTableUsed:        .db      #0x00               ;>0 if an Arpeggio Table is currently in use.
+PLY_AKM_Track3_PtArpeggioTable:            .dw      #0x0000             ;Point on the base of the Arpeggio table, does not evolve.
+PLY_AKM_Track3_PtArpeggioOffset:           .db      #0x00               ;Increases over the Arpeggio.
+PLY_AKM_Track3_ArpeggioCurrentStep:        .db      #0x00               ;The arpeggio current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForceArpeggioSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track3_ArpeggioCurrentSpeed:       .db      #0x00               ;The arpeggio speed (>=0, may be changed by the Force Arpeggio Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForceArpeggioSpeed
+PLY_AKM_Track3_ArpeggioOriginalSpeed:      .db      #0x00               ;The arpeggio original speed (>=0, NEVER changes for this arpeggio).
+PLY_AKM_Track3_CurrentArpeggioValue:       .db      #0x00               ;Value from the Arpeggio to add to the base note. Read even if the Arpeggio effect is deactivated.
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                       .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+PLY_AKM_Track3_IsPitchTableUsed:           .db      #0x00               ;>0 if a Pitch Table is currently in use.
+PLY_AKM_Track3_PtPitchTable:               .dw      #0x0000             ;Points on the base of the Pitch table, does not evolve.
+PLY_AKM_Track3_PtPitchOffset:              .db      #0x00               ;Increases over the Pitch.
+PLY_AKM_Track3_PitchCurrentStep:           .db      #0x00               ;The Pitch current step (>=0, increases).
+                               .if PLY_CFG_UseEffect_ForcePitchTableSpeed        ;CONFIG SPECIFIC
+PLY_AKM_Track3_PitchCurrentSpeed:          .db      #0x00               ;The Pitch speed (>=0, may be changed by the Force Pitch Speed effect).
+                               .endif ;PLY_CFG_UseEffect_ForcePitchTableSpeed
+PLY_AKM_Track3_PitchOriginalSpeed:         .db      #0x00               ;The Pitch original speed (>=0, NEVER changes for this pitch).
+PLY_AKM_Track3_CurrentPitchTableValue:     .dw      #0x0000             ;16 bit value from the Pitch to add to the base note. Not read if the Pitch effect is deactivated.
+
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+       .ifeq PLY_AKM_Rom
+PLY_AKM_Track3_Data_End:
+.equ PLY_AKM_Track3_Data_Size , PLY_AKM_Track3_Data_End - PLY_AKM_Track3_Data
+       .else
+PLY_AKM_Track3_Data_Size = counter - counterStartInTrackData
+PLY_AKM_Track3_Data_End = PLY_AKM_Track3_Data + PLY_AKM_Track3_Data_Size
+       .endif
+        
+        
+
+.equ PLY_AKM_Track3_WaitEmptyCell       , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetWaitEmptyCell
+.equ PLY_AKM_Track3_PtTrack             , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetPtTrack
+.equ PLY_AKM_Track3_PtInstrument        , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetPtInstrument
+.equ PLY_AKM_Track3_EscapeNote          , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetEscapeNote
+.equ PLY_AKM_Track3_EscapeInstrument    , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetEscapeInstrument
+.equ PLY_AKM_Track3_EscapeWait          , PLY_AKM_Track3_Data + PLY_AKM_Data_OffsetEscapeWait
+
+;---------------------------------------------------------------------
+;Register block for all the channels. They are "polluted" with pointers to code because all this
+;is actually a RET table!
+;---------------------------------------------------------------------
+;DB register, DB value then DW code to jump to once the value is read.
+       .ifeq PLY_AKM_Rom              ;For ROM, a table is generated.
+PLY_AKM_Registers_RetTable:
+PLY_AKM_Track1_Registers:
+       .db 8
+PLY_AKM_Track1_Volume: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 0
+PLY_AKM_Track1_SoftwarePeriodLSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+
+       .db 1
+PLY_AKM_Track1_SoftwarePeriodMSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+
+PLY_AKM_Track2_Registers:
+       .db 9
+PLY_AKM_Track2_Volume: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 2
+PLY_AKM_Track2_SoftwarePeriodLSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 3
+PLY_AKM_Track2_SoftwarePeriodMSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+
+PLY_AKM_Track3_Registers:
+       .db 10
+PLY_AKM_Track3_Volume: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 4
+PLY_AKM_Track3_SoftwarePeriodLSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 5
+PLY_AKM_Track3_SoftwarePeriodMSB: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+;Generic registers.
+                       .if PLY_AKM_USE_NoiseRegister          ;CONFIG SPECIFIC
+       .db 6
+PLY_AKM_NoiseRegister: .db 0
+       .dw PLY_AKM_SendPsgRegister
+                       .endif ;PLY_AKM_USE_NoiseRegister
+
+       .db 7
+PLY_AKM_MixerRegister: .db 0
+       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+       .dw PLY_AKM_SendPsgRegister
+        
+       .db 11
+PLY_AKM_Reg11: .db 0
+       .dw PLY_AKM_SendPsgRegister
+
+       .db 12
+PLY_AKM_Reg12: .db 0
+       .dw PLY_AKM_SendPsgRegisterR13
+                ;This one is a trick to send the register after R13 is managed.
+               .dw PLY_AKM_SendPsgRegisterAfterPop
+       .endif ;PLY_CFG_UseHardwareSounds
+       .dw PLY_AKM_SendPsgRegisterEnd
+
+       .endif ;PLY_AKM_Rom
+
+
+.equ PLY_AKM_Registers_OffsetVolume  , PLY_AKM_Track1_Volume - PLY_AKM_Track1_Registers
+.equ PLY_AKM_Registers_OffsetSoftwarePeriodLSB  , PLY_AKM_Track1_SoftwarePeriodLSB - PLY_AKM_Track1_Registers
+.equ PLY_AKM_Registers_OffsetSoftwarePeriodMSB  , PLY_AKM_Track1_SoftwarePeriodMSB - PLY_AKM_Track1_Registers
+
+;The period table for the first octave only.
+PLY_AKM_PeriodTable:
+       .if PLY_AKM_HARDWARE_CPC + PLY_AKM_HARDWARE_ENTERPRISE
+        ;PSG running to 1000000 Hz.
+        .dw 3822,3608,3405,3214,3034,2863,2703,2551,2408,2273,2145,2025          ; Octave 0.
+        ;dw 1911,1804,1703,1607,1517,1432,1351,1276,1204,1136,1073,1012          ;12
+        ;dw  956, 902, 851, 804, 758, 716, 676, 638, 602, 568, 536, 506          ;24
+        ;dw  478, 451, 426, 402, 379, 358, 338, 319, 301, 284, 268, 253          ;36
+        ;dw  239, 225, 213, 201, 190, 179, 169, 159, 150, 142, 134, 127          ;48
+        ;dw  119, 113, 106, 100,  95,  89,  84,  80,  75,  71,  67,  63          ;60
+        ;dw   60,  56,  53,  50,  47,  45,  42,  40,  38,  36,  34,  32          ;72
+        ;dw   30,  28,  27,  25,  24,  22,  21,  20,  19,  18,  17,  16          ;84
+        ;dw   15,  14,  13,  13,  12,  11,  11,  10,   9,   9,   8,   8          ;96
+        ;dw    7,   7,   7,   6,   6,   6,   5,   5,   5,   4,   4,   4          ;108
+        ;dw    4,   4,   3,   3,   3,   3,   3,   2  ;,2,   2,   2,   2          ;120 -> 127
+       .endif
+
+       .if PLY_AKM_HARDWARE_SPECTRUM + PLY_AKM_HARDWARE_MSX
+        ;PSG running to 1773400 Hz.
+       .dw 6778, 6398, 6039, 5700, 5380, 5078, 4793, 4524, 4270, 4030, 3804, 3591	; Octave 0.
+       .endif
+
+       .if PLY_AKM_HARDWARE_PENTAGON
+        ;PSG running to 1750000 Hz.
+       .dw 6689, 6314, 5959, 5625, 5309, 5011, 4730, 4464, 4214, 3977, 3754, 3543	; Octave 0.
+       .endif
+PLY_AKM_End:
+
+; =============================================================================
+ .if PLY_AKM_HARDWARE_ENTERPRISE
+  .ifeq NO_ENVELOPE_IRQ
+
+envelopeInterrupt:
+
+    .if ENABLE_1000HZ_IRQ 
+        ld    a, #0x13
+        out   (#0xb4), a
+    .endif
+        push  hl
+        push  bc
+envelopeInterrupt.l1:    ld    hl,#0x0000                 ; * envelope counter
+      .if ENABLE_1000HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #500) / #1000)
+      .else
+        .if ENABLE_300HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #150) / #300)
+        .else
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #25) / #50)
+        .endif
+      .endif
+        add   hl, bc
+envelopeInterrupt.l2:    jr    c, envelopeInterrupt.l19                   ; * JR if envelope is stopped
+envelopeInterrupt.l3:    ld    bc, #0xffff               ; * envelope frequency
+envelopeInterrupt.l4:    ld    a,#0x00                   ; * envelope state (0 to 15)
+envelopeInterrupt.l5:    dec   a                         ; * envelope direction (INC A or DEC A)
+        add   hl, bc
+        jr    nc, envelopeInterrupt.l5
+        ld    (envelopeInterrupt.l1 + 1), hl
+        cp    #0x10
+envelopeInterrupt.l6:    jr    nc, envelopeInterrupt.l21                  ; * envelope mode
+envelopeInterrupt.l7:    ld    (envelopeInterrupt.l4 + 1), a
+envelopeInterrupt.l8:    add   a,#<ayVolumeTable
+        ld    l, a
+        adc   a, #>ayVolumeTable
+        sub   l
+        ld    h,a
+        or    a
+envelopeInterrupt.l9:
+        ld    a, (hl)
+        pop   bc
+envelopeInterrupt.l10:   jr    envelopeInterrupt.l12                      ; * envelope enable mode
+envelopeInterrupt.l11:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channel A only
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l12:   pop   hl
+        ret
+envelopeInterrupt.l13:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and B
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l14:
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; envelope on channel B only (Carry=0)
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l15:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l16:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channel C only
+        pop   hl
+        ret
+envelopeInterrupt.l17:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A, B, and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l18:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channels B and C
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l19:   ld    (envelopeInterrupt.l1 + 1), hl
+        pop   bc
+        pop   hl
+        ret
+envelopeInterrupt.l20:   ld    l, #<(ayVolumeTable + 15)       ; envelope modes 11 and 13
+        .db  #0x01                      ; = LD BC, nnnn
+envelopeInterrupt.l21:   ld    l, #<ayVolumeTable      ; envelope modes 0 to 7, 9, and 15
+        ld    h, #>ayVolumeTable
+        ld    a, #0x18                  ; = JR +nn
+        ld    (envelopeInterrupt.l2), a                  ; stop envelope
+        jp    envelopeInterrupt.l9
+envelopeInterrupt.l22:   and   #0x0f                     ; envelope modes 8 and 12
+        jp    envelopeInterrupt.l7
+envelopeInterrupt.l23:   jp    m, envelopeInterrupt.l24                   ; envelope modes 10 and 14
+        xor   #0x1f
+        ld    l, a
+        ld    h,#0x3d                   ; set direction to DEC A
+        ld    (envelopeInterrupt.l4 + 1), hl             ; assume .l5 = .l4 + 2
+        jp    envelopeInterrupt.l8
+envelopeInterrupt.l24:   cpl
+        ld    l, a
+        ld    h,#0x3c                   ; set direction to INC A
+        ld    (envelopeInterrupt.l4 + 1), hl
+        jp    envelopeInterrupt.l8
+
+  .endif
+; -----------------------------------------------------------------------------
+
+ayVolumeTable:
+        .db   0,  1,  2,  3,  4,  5,  6,  9
+        .db  12, 17, 22, 28, 36, 44, 53, 63
+
+ayRegisterMaskTable:
+        .db  #0xff,#0x0f,#0xff,#0x0f,#0xff,#0x0f,#0x1f,#0xff
+        .db  #0x1f,#0x1f,#0x1f,#0xff,#0xff,#0x0f,#0xff,#0xff
+
+ayRegisters:
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+
+ayRegWriteTable:
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l7 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l5 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l9 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l10 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l11 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l15 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+
+
+    .ifeq NO_ENVELOPE_IRQ
+
+envelopeModeTable:
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+
+envelopeEnableTable:
+        .db  <(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l11 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l14 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l13 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l16 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l15 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l18 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l17 - envelopeInterrupt.l11)
+
+    .endif
+
+setChannelAmplitude:
+        cp    #0x10
+        jr    c, setChannelAmplitude.l1
+    .ifeq NO_ENVELOPE_IRQ
+        res   3, b
+        ld    a, (envelopeInterrupt.l4 + 1)
+    .else
+        xor   a
+    .endif
+setChannelAmplitude.l1:                                    ; HL = ayRegWriteTable + (8 + channel)
+        add     a,#<ayVolumeTable
+        ld      l,a
+        adc     a,#>ayVolumeTable
+        sub     l
+        ld      h,a
+    .ifne ENABLE_STEREO
+        bit     0,c                     ; Z = 0: channel B, Z = 1: channel A, C
+    .endif
+        ld    a, (hl)
+    .ifne ENABLE_STEREO 
+        jr    z, setChannelAmplitude.l2
+        or    a
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (c), a
+        set   2, c
+setChannelAmplitude.l2:    out   (c), a
+    .ifeq NO_ENVELOPE_IRQ
+setChannelAmplitude.l3:    ld      a,#0x00                   ; *
+        ld      c,a
+        or      b
+        cp      #0x08
+        jr      c,setChannelAmplitude.l4
+        xor     b
+setChannelAmplitude.l4:    cp      c
+        jr      z, setChannelAmplitude.l5                    ; envelope enable bit has not changed ?
+        ld      (setChannelAmplitude.l3+1), a
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeEnableTable
+        add     hl,bc
+        ld      a,(hl)
+        ld      (envelopeInterrupt.l10+1),a
+    .endif
+setChannelAmplitude.l5:    pop   bc
+;        pop   af
+        ret
+
+setChannelAFreq:
+        ld    c, #0xa0 + (ayDaveChnA * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters)
+    .if toneAndNoiseModeAtone
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+        and   #0x04
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeAnoise
+        bit   3, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeAtnns
+        and   #0x09
+        jr    z, setToneGenAAsNoise     ; tone + noise generator enabled ?
+        cp    #0x08
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnA * 2)), a
+        out   (#0xa1 + (ayDaveChnA * 2)), a
+        ret
+
+setChannelBFreq:
+        ld    c, #0xa0 + (ayDaveChnB * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 2)
+    .if toneAndNoiseModeBtone
+        bit   1, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x10
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeBnoise
+        bit   4, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x02
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeBtnns
+        and   #0x12
+        jr    z, setToneGenBAsNoise     ; tone + noise generator enabled ?
+        cp    #0x10
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnB * 2)), a
+        out   (#0xa1 + (ayDaveChnB * 2)), a
+        ret
+
+setChannelCFreq:
+        ld    c, #0xa0 + (ayDaveChnC * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 4)
+    .if toneAndNoiseModeCtone
+        bit   2, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x20
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeCnoise
+        bit   5, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x04
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeCtnns
+        and   #0x24
+        jr    z, setToneGenCAsNoise     ; tone + noise generator enabled ?
+        cp    #0x20
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnC * 2)), a
+        out   (#0xa1 + (ayDaveChnC * 2)), a
+        ret
+
+    .if toneAndNoiseModeAtnns
+setToneGenAAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeBtnns
+setToneGenBAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeCtnns
+setToneGenCAsNoise:
+        ld    a,#0x30
+        .db   #0xfe                      ; = CP nn
+    .endif
+
+setToneGenFrequency:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        xor   a
+    .endif
+
+setToneGenFrequency_:
+        add   hl, hl
+        dec   hl
+        bit   4, h
+        jr    nz, setToneGenFrequency_.l2                   ; overflow ?
+setToneGenFrequency_.l1:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        or    h                         ; non-zero for tone + noise
+    .endif
+        out   (c), l
+        inc   c
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        out   (c), a
+    .else
+        out   (c), h
+    .endif
+        ret
+setToneGenFrequency_.l2:    ld    l,#0x01
+        inc   h
+        jr    z, setToneGenFrequency_.l1
+        ld    hl,#0x0fff
+        jp    setToneGenFrequency_.l1
+
+    .if (toneAndNoiseModeAtnns * toneAndNoiseModeAnoise)
+setToneGenAAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeBtnns * toneAndNoiseModeBnoise)
+setToneGenBAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeCtnns * toneAndNoiseModeCnoise)
+setToneGenCAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+setNoiseGenFreq:
+        ld    h,#0x30
+
+setNoiseGenFreq_:
+        ld    a, (ayRegisters + 6)
+        add   a, a
+        add   a, a
+        jr    nz, setNoiseGenFreq_.l1
+        ld    a,#0x04
+setNoiseGenFreq_.l1:    dec   a
+        out   (c), a
+        inc   c
+        out   (c), h
+        ret
+; -----------------------------------------------------------------------------
+; reset AY-3-8912 emulation
+
+ayReset:
+;        di
+        ld    hl, #ayRegisters - 1
+        ld    bc, #0x10af
+        xor   a
+ayReset.l1:    inc   hl
+        out   (c), a
+        ld    (hl), a
+        dec   c
+        djnz  ayReset.l1
+        res   3, l                      ; register 7
+        ld    (hl), #0x3f
+    .ifeq NO_ENVELOPE_IRQ
+        ld    (envelopeInterrupt.l4 + 1), a
+        ld    a, #0x18                    ; = JR +nn
+        ld    (envelopeInterrupt.l2), a
+        ld    hl, #MIN_ENV_FREQVAL
+        ld    (envelopeInterrupt.l3 + 1), hl
+        ld    a, #<(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        ld    (envelopeInterrupt.l10 + 1), a
+        xor     a
+        ld    (setChannelAmplitude.l3 + 1), a
+    .endif
+        ld    a, #0x04
+        out   (#0xbf), a
+        ld    c, b
+        call  ayReset.l2
+        ld    l, b
+        call  ayReset.l2                       ; L = 1 kHz interrupts per video frame
+        ld    a, #25
+        cp    l
+        ld    a, #0x03
+        rla
+        rla
+        out   (#0xbf), a                 ; Z80 <= 5 MHz: 04h, > 5 MHz: 06h
+        ld    a, #0x10                    ; use 17-bit noise generator
+        out   (#0xa6), a
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, #0x33
+    .else
+        ld    a, #0x30
+    .endif
+        out   (#0xb4), a                 ; enable 1 kHz and video interrupts
+        ret
+ayReset.l2:    in    a, (#0xb4)
+        and   #0x11
+        or    c
+        rlca
+        and   #0x66
+        ld    c, a                      ; -ON--ON-
+        rlca                            ; ON--ON--
+        xor   c                         ; OXN-OXN-
+        bit   2, a
+        jr    z, ayReset.l3
+        inc   l                         ; 1 kHz interrupt
+ayReset.l3:    cp    #0xc0
+        jr    c, ayReset.l2                    ; not 50 Hz interrupt ?
+        ret
+
+;; read AY-3-8912 register A, returning the value in A
+;
+;ayRegisterRead:
+;        and   0fh
+;        or    <ayRegisters
+;        ld    l, a
+;        ld    h, >ayRegisters
+;        ld    a, (hl)
+;        or    a
+;        ret
+
+; write C to AY-3-8912 register A
+; NOTE: interrupts may be enabled on return
+ayRegisterWriteDE:
+        ld      a,(de)
+        ld      c,a
+        inc     de
+        ld      a,(de)
+        inc     de
+        inc     de
+        inc     de
+
+ayRegisterWrite:
+        ld      b,#0x00
+        ld      hl,#ayRegisterMaskTable
+        add     hl,bc
+        inc     c
+        and     (hl)
+        push    bc
+        ld      c,#0x10
+        add     hl,bc                   ;ayRegisters
+        cp      (hl)
+        jr      z,ayRegisterWrite.l2                   ; register not changed ?
+        ld      (hl),a
+        add     hl,bc                   ;ayRegWriteTable
+        ld      a,(hl)
+        ld      (ayRegisterWrite.l1+1),a
+ayRegisterWrite.l1:    jr      ayRegisterWrite.l8                     ; *
+ayRegisterWrite.l2:    
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, l
+        xor   #<(ayRegisters + 13)
+        jr    z, ayRegisterWrite.l16                   ; envelope restart ?
+    .endif
+        pop     bc
+;        pop   af
+        ret
+ayRegisterWrite.l3:    call  setChannelAFreq           ; tone generator A frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l4:    call  setChannelBFreq           ; tone generator B frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l5:    call  setChannelAFreq           ; mixer
+        call  setChannelBFreq
+ayRegisterWrite.l6:    call  setChannelCFreq           ; tone generator C frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l7:    ld    a, (ayRegisters + 7)      ; noise generator frequency
+    .if toneAndNoiseModeAnoise
+        ld    b, a
+        and   #0x08
+    .else
+        xor   #0x07
+        ld    b, a
+        and   #0x09
+    .endif
+        call  z, setChannelAFreq
+    .if toneAndNoiseModeBnoise
+        bit   4, b
+    .else
+        ld    a, b
+        and   #0x12
+    .endif
+        call  z, setChannelBFreq
+    .if toneAndNoiseModeCnoise
+        bit   5, b
+    .else
+        ld    a, b
+        and   #0x24
+    .endif
+        call  z, setChannelCFreq
+ayRegisterWrite.l8:    pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l9:    ld    a, (ayRegisters + 8)      ; channel A amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x09a8 + ayDaveChnA
+    .else
+        ld    c,#0xa8 + ayDaveChnA
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l10:   ld    a, (ayRegisters + 9)      ; channel B amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0aa8 + ayDaveChnB
+    .else
+        ld    c,#0xa8 + ayDaveChnB
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l11:   ld    a, (ayRegisters + 10)     ; channel C amplitude / envelope enable
+    .ifeq ENABLE_STEREO
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0ca8 + ayDaveChnC
+      .else
+        ld    c,#0xa8 + ayDaveChnC
+      .endif
+    .else
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0cac + ayDaveChnC
+      .else
+        ld    c,#0xac + ayDaveChnC
+      .endif
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l12:
+    .ifeq NO_ENVELOPE_IRQ
+        ld    hl, (ayRegisters + 11)    ; envelope generator frequency
+        ld    a, h
+        or    a
+        jr    nz, ayRegisterWrite.l13
+        ld    a, #MIN_ENV_FREQVAL
+        cp    l
+        jr    c, ayRegisterWrite.l13
+        ld    l, a                      ; limit envelope frequency
+ayRegisterWrite.l13:   ld    (envelopeInterrupt.l3 + 1), hl
+        pop   bc
+;        pop   af
+        ret
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+ayRegisterWrite.l15:                                   ; envelope generator mode / restart
+    .ifeq NO_ENVELOPE_IRQ
+ayRegisterWrite.l16:   ld      hl,(envelopeInterrupt.l3+1)
+        ld      (envelopeInterrupt.l1+1),hl
+        ld      a,#0x38                     ; = JR C, +nn
+        ld      (envelopeInterrupt.l2),a    ; enable envelope
+        ld      a,(ayRegisters+13)
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeModeTable
+        add     hl,bc
+        and     #0x04
+        ld    a, (hl)
+        ld    (envelopeInterrupt.l6 + 1), a
+        ld    hl,#0x3c00                    ; INC A, state = 0
+        ld    a, l
+        jr    nz, ayRegisterWrite.l17                      ; attack ?
+        ld    hl,#0x3d0f                    ; DEC A, state = 15
+        ld    a,#0x3f
+ayRegisterWrite.l17:   ld    (envelopeInterrupt.l4 + 1), hl    ; assume eInt.l5 = eInt.l4 + 2
+        call  ayRegisterWrite.l18
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l18:   call  envelopeInterrupt.l10     ; NOTE: this will pop return address
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+
+ .endif
+; =============================================================================
+
+
+   ;PLY_UseEnterprise_End  
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm_SoundEffects.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm_SoundEffects.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm_SoundEffects.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm_SoundEffects.src	2025-01-11 16:57:38
@@ -0,0 +1,608 @@
+;       Player of sound effects, for the AKM player.
+;       Note that this is the exact same code as for the Lightweight player, as the way to output to the PSG is the same.
+
+        ;Is there a loaded Player Configuration source? If no, use a default configuration.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKM_SFXInit
+   ;;
+   ;;    Initializes sound effect instruments to be able to play sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKM_SFXInit> (void* *sfx_song_data*)
+   ;;
+   ;; Input Parameters (2 bytes):
+   ;;  (2B DE) sfx_song_data - Pointer to the start of a song file containing instrument data for SFX
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKM_SFXInit_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *sfx_song_data* must be a song in binary AKS format. However, this song 
+   ;; only needs to have instruments defined (there is not need for an actual "song"
+   ;; as a list of notes, patterns and others). Instruments will be set up for 
+   ;; playing SFX later on with functions like <cpct_akp_SFXPlay>.
+   ;;
+   ;; Details:
+   ;;    This function initializes instruments that will be used later on to play 
+   ;; FX sounds at will using <cpct_akp_SFXPlay>. In order for the instruments to
+   ;; be initialized, *sfx_song_data* must point to a song defined in AKS format.
+   ;; For the purpose of this function, the song only requires to have instruments
+   ;; defined in it, as patterns, notes and other information is not used for FX
+   ;; sounds. 
+   ;;
+   ;;    You may use instruments from another song or a specific song containing
+   ;; instrument data only. Any song with instruments defined in it is valid to
+   ;; set up SFX with Arkos Tracker Player.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, DE, HL
+   ;;
+   ;; Required memory:
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;;    Any     |  146   |  36.50
+   ;; --------------------------------
+   ;; Asm saving |  -41   | -10.25
+   ;; -------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   PLY_SFX_Init:
+   _cpct_akpAKM_SFXInit::
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  e, (hl)                                  ;; [ 7]
+      inc hl                                       ;; [ 6]
+      ld  d, (hl)                                  ;; [ 7] HL = Pointer to the SFX "Song"
+      ex  de, hl
+
+   cpct_akpAKM_SFXInit_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Initializes the sound effects. It MUST be called at any times before a first sound effect is triggered.
+;It doesn't matter whether the song is playing or not, or if it has been initialized or not.
+;IN:    HL = Address to the sound effects data.
+PLY_AKM_InitSoundEffectsDisarkGenerateExternalLabel:
+PLY_AKM_InitSoundEffects:
+        ld (PLY_AKM_PtSoundEffectTable + PLY_AKM_Offset1b),hl
+        ret
+
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKM_SFXPlay
+   ;;
+   ;;    Plays a concrete sound effect, using the instruments of the "SFX song" 
+   ;; given to <cpct_akpAKM_SFXInit> when initializing sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKM_SFXPlay> (<u8> *sfx_num*, <u8> *channel_bitmask*, <u8> *volume*,)
+   ;;
+   ;; Input Parameters (3 bytes):
+   ;;  (1B A ) sfx_num         - Number of the instrument in the SFX Song (>0), same as the number given to the 
+   ;; instrument in Arkos Tracker.
+   ;;  (1B C ) channel
+   ;;  (1B B ) inv vol
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKM_SFXPlay_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Details:
+   ;;    Plays a given sound effect, along with the music, in a concrete channel 
+   ;; and with some parameters (Volume, Note, Speed, Inverted Pitch). This lets
+   ;; you create lots of different (and potentially complex) sound effects 
+   ;; from a set of instruments. In fact, you could play a song made of sound
+   ;; effect calls. 
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, BC, DE, HL,
+   ;;
+   ;; Required memory:
+   ;;    95 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles  | microSecs (us)
+   ;; --------------------------------------
+   ;;    Any     |     To be done
+   ;; --------------------------------------
+   ;; Asm saving |  -141   |  -45.25
+   ;; --------------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpAKM_SFXPlay::
+   PLY_SFX_Play:
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  a, (hl)                                  ;; [ 7] sfx
+      inc hl                                       ;; [ 6]
+      ld  c, (hl)                                  ;; [ 7] channel
+      inc hl                                       ;; [ 6]
+      ld  b, (hl)                                  ;; [ 7] vol
+
+      cpct_akpAKM_SFXPlay_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Plys a sound effect. If a previous one was already playing on the same channel, it is replaced.
+;This does not actually plays the sound effect, but programs its playing.
+;The music player, when called, will call the PLY_AKM_PlaySoundEffectsStream method below.
+;IN:    A = Sound effect number (>0!).
+;       C = The channel where to play the sound effect (0, 1, 2).
+;       B = Inverted volume (0 = full volume, 16 = no sound). Hardware sounds are also lowered.
+PLY_AKM_PlaySoundEffectDisarkGenerateExternalLabel:
+PLY_AKM_PlaySoundEffect:
+        ;Gets the address to the sound effect.
+        dec a                   ;The 0th is not encoded.
+       .ifeq PLY_AKM_Rom
+PLY_AKM_PtSoundEffectTable: ld hl,#0x0000
+       .else
+        ld hl,(PLY_AKM_PtSoundEffectTable)
+       .endif
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        add hl,de
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        ;Reads the header of the sound effect to get the speed.
+        ld a,(de)
+        inc de
+        ex af,af'
+
+        ld a,b
+
+        ;Finds the pointer to the sound effect of the desired channel.
+        ld hl,#PLY_AKM_Channel1_SoundEffectData
+        ld b,#0x00
+        sla c
+        sla c
+        sla c
+        add hl,bc
+        ld (hl),e
+        inc hl
+        ld (hl),d
+        inc hl        
+        
+        ;Now stores the inverted volume.
+        ld (hl),a
+        inc hl
+        
+        ;Resets the current speed, stores the instrument speed.
+        ld (hl),#0x00
+        inc hl
+        ex af,af'
+        ld (hl),a
+        
+        ret
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpAKM_SFXStop
+   ;;
+   ;;    Stops the reproduction sound FX on given channels
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpAKM_SFXStop> (<u8> *stop_bitmask*)
+   ;;
+   ;; Input Parameters (1 byte):
+   ;;  (1B A) stop_bitmask - A value where the 3 Least Significant Bits represent which channels to stop 
+   ;; (bits enabled = channels to stop)
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpAKM_SFXStop_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *stop_bitmask* must be a value that operates as a set of enabled / 
+   ;; disabled bits (a bitmask). Concretely, the 3 Least Significant bits, 2, 1 
+   ;; and 0 (xxxxx210) refer to Channels C, B and A respectively. Rest of the 
+   ;; bits are ignored. Bits set to 1 mean that those channels will be stopped. 
+   ;; Bits set to 0 mean that those channels are to be left as they are.
+   ;;
+   ;; Details:
+   ;;    This function lets you selectively stop sound FX reproduction on one, two
+   ;; or the 3 available channels. A *stop_bitmask* is given as parameter containing
+   ;; the information about what channels shall be stopped.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, HL
+   ;;
+   ;; Required memory:
+   ;;    30 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2082 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;; Case       | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;; Best (0)   |  101   |  25.25 
+   ;; --------------------------------
+   ;; Best (1)   |  149   |  37.25 
+   ;; --------------------------------
+   ;; Asm saving |  -28   |  -7.00
+   ;; --------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpAKM_SFXStop::
+   PLY_SFX_Stop:
+      ld   hl, #2                             ;; [10] Get Parameter from Stack
+      add  hl, sp                             ;; [11]
+      ld    a, (hl)                           ;; [ 7] A = Channel number to be stopped
+
+   cpct_akpAKM_SFXStop_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Stops a sound effect. Nothing happens if there was no sound effect.
+;IN:    A = The channel where to stop the sound effect (0, 1, 2).
+PLY_AKM_StopSoundEffectFromChannelDisarkGenerateExternalLabel:
+PLY_AKM_StopSoundEffectFromChannel:
+        ;Puts 0 to the pointer of the sound effect.
+        add a,a
+        add a,a
+        add a,a
+        ld e,a
+        ld d,#0x00
+        ld hl,#PLY_AKM_Channel1_SoundEffectData
+        add hl,de
+        ld (hl),d               ;0 means "no sound".
+        inc hl
+        ld (hl),d
+        ret
+
+;Plays the sound effects, if any has been triggered by the user.
+;This does not actually send registers to the PSG, it only overwrite the required values of the registers of the player.
+;The sound effects initialization method must have been called before!
+;As R7 is required, this must be called after the music has been played, but BEFORE the registers are sent to the PSG.
+;IN:    A = R7.
+PLY_AKM_PlaySoundEffectsStream:
+        ;Shifts the R7 to the left twice, so that bit 2 and 5 only can be set for each track, below.
+        rla
+        rla
+
+        ;Plays the sound effects on every track.
+        ld ix,#PLY_AKM_Channel1_SoundEffectData
+        ld iy,#PLY_AKM_Track1_Registers
+        ld c,a
+        call PLY_AKM_PSES_Play
+        ld ix,#PLY_AKM_Channel2_SoundEffectData
+        ld iy,#PLY_AKM_Track2_Registers
+        srl c                                   ;Not RR, to make sure bit 6 is 0 (else, no more keyboard on CPC!).
+                                                ;Also, on MSX, bit 6 must be 0.
+        call PLY_AKM_PSES_Play
+        ld ix,#PLY_AKM_Channel3_SoundEffectData
+        ld iy,#PLY_AKM_Track3_Registers
+       .if PLY_AKM_HARDWARE_MSX
+                scf             ;On MSX, bit 7 must be 1.
+                rr c
+       .else
+                rr c            ;On other platforms, we don't care about b7.
+       .endif
+        call PLY_AKM_PSES_Play
+
+        ld a,c
+        ld (PLY_AKM_MixerRegister),a
+        ret
+
+
+;Plays the sound stream from the given pointer to the sound effect. If 0, no sound is played.
+;The given R7 is given shift twice to the left, so that this code MUST set/reset the bit 2 (sound), and maybe reset bit 5 (noise).
+;This code MUST overwrite these bits because sound effects have priority over the music.
+;IN:    IX = Points on the sound effect pointer. If the sound effect pointer is 0, nothing must be played.
+;       IY = Points at the beginning of the register structure related to the channel.
+;       C = R7, shifted twice to the left.
+;OUT:   The pointed pointer by IX may be modified as the sound advances.
+;       C = R7, MUST be modified if there is a sound effect.
+PLY_AKM_PSES_Play:
+        ;Reads the pointer pointed by IX.
+        ld l,0 (ix)
+        ld h,1 (ix)
+        ld a,l
+        or h
+        ret z           ;No sound to be played? Returns immediately.
+
+        ;Reads the first byte. What type of sound is it?
+PLY_AKM_PSES_ReadFirstByte:
+        ld a,(hl)
+        inc hl
+        ld b,a
+        rra
+        jr c,PLY_AKM_PSES_SoftwareOrSoftwareAndHardware
+        rra
+                       .if PLY_CFG_SFX_HardOnly              ;CONFIG SPECIFIC
+        jr c,PLY_AKM_PSES_HardwareOnly
+                       .endif ;PLY_CFG_SFX_HardOnly
+
+        ;No software, no hardware, or end/loop.
+        ;-------------------------------------------
+        ;End or loop?
+        rra
+                       .if PLY_CFG_SFX_NoSoftNoHard         ;CONFIG SPECIFIC. If not present, the jump is not needed, the method is just below.
+        jr c,PLY_AKM_PSES_S_EndOrLoop
+                        
+        ;No software, no hardware.
+        ;-------------------------------------------
+        ;Gets the volume.
+        call PLY_AKM_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+                               .if PLY_CFG_SFX_NoSoftNoHard_Noise                ;CONFIG SPECIFIC
+        rl b
+        call c,PLY_AKM_PSES_ReadNoiseAndOpenNoiseChannel
+                               .endif ;PLY_CFG_SFX_NoSoftNoHard_Noise
+
+        jr PLY_AKM_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_NoSoftNoHard
+
+        ;**Warning!** Do not put any instruction between EndOrLoop and NoSoftNoHard.
+
+PLY_AKM_PSES_S_EndOrLoop:
+                       .if PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC. If no "loop to", the sounds always end, no need to test.
+        ;Is it an end?
+        rra
+        jr c,PLY_AKM_PSES_S_Loop
+                       .endif ;PLY_CFG_SFX_LoopTo
+        ;End of the sound. Marks the sound pointer with 0, meaning "no sound".
+        xor a
+        ld 0 (ix),a
+        ld 1 (ix),a
+        ret
+                       .if PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC.
+PLY_AKM_PSES_S_Loop:
+        ;Loops. Reads the pointer and directly uses it.
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jr PLY_AKM_PSES_ReadFirstByte
+                       .endif ;PLY_CFG_SFX_LoopTo
+
+
+;Saves HL into IX, and exits. This must be called at the end of each Cell.
+;If the speed has not been reached, it is not saved.
+PLY_AKM_PSES_SavePointerAndExit:
+        ;Speed reached?
+        ld a,PLY_AKM_SoundEffectData_OffsetCurrentStep (ix)
+        cp PLY_AKM_SoundEffectData_OffsetSpeed (ix)
+        jr c,PLY_AKM_PSES_NotReached
+        ;The speed has been reached, so resets it and saves the pointer to the next cell to read.
+        ld PLY_AKM_SoundEffectData_OffsetCurrentStep (ix),#0x00
+        ld 0 (ix),l
+        ld 1 (ix),h
+        ret
+PLY_AKM_PSES_NotReached:
+        ;Speed not reached. Increases it, that's all. The same cell will be read next time.
+        inc PLY_AKM_SoundEffectData_OffsetCurrentStep (ix)
+        ret
+
+                       .if PLY_CFG_SFX_HardOnly         ;CONFIG SPECIFIC
+        ;Hardware only.
+        ;-------------------------------------------
+PLY_AKM_PSES_HardwareOnly:
+        ;Calls the shared code that manages everything.
+        call PLY_AKM_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+        ;Cuts the sound.
+        set 2,c
+
+        jr PLY_AKM_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_HardOnly
+
+
+
+PLY_AKM_PSES_SoftwareOrSoftwareAndHardware:
+        ;Software only?
+        rra
+                       .if PLY_CFG_SFX_SoftAndHard         ;CONFIG SPECIFIC
+        jr c,PLY_AKM_PSES_SoftwareAndHardware
+                       .endif ;PLY_CFG_SFX_SoftAndHard
+
+        ;Software.
+        ;-------------------------------------------
+                       .if PLY_CFG_SFX_SoftOnly          ;CONFIG SPECIFIC
+        ;Volume.
+        call PLY_AKM_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+        rl b
+                               .if PLY_CFG_SFX_SoftOnly_Noise                ;CONFIG SPECIFIC
+        call c,PLY_AKM_PSES_ReadNoiseAndOpenNoiseChannel
+                               .endif ;PLY_CFG_SFX_SoftOnly_Noise
+
+        ;Opens the "sound" channel.
+        res 2,c
+
+        ;Reads the software period.
+        call PLY_AKM_PSES_ReadSoftwarePeriod
+
+        jr PLY_AKM_PSES_SavePointerAndExit
+                       .endif ;PLY_CFG_SFX_SoftOnly
+
+
+        ;Software and Hardware.
+        ;-------------------------------------------
+                       .if PLY_AKM_SE_HardwareSounds         ;CONFIG SPECIFIC
+PLY_AKM_PSES_SoftwareAndHardware:
+        ;Calls the shared code that manages everything.
+        call PLY_AKM_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+
+        ;Reads the software period.
+        call PLY_AKM_PSES_ReadSoftwarePeriod
+
+        ;Opens the sound.
+        res 2,c
+
+        jr PLY_AKM_PSES_SavePointerAndExit
+                       .endif ;PLY_AKM_SE_HardwareSounds
+
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Shared code used by the "hardware only" and "software and hardware" part.
+        ;Reads the Retrig flag, the Hardware Envelope, the possible noise, the hardware period,
+        ;and sets the volume to 16. The R7 sound channel is NOT modified.
+PLY_AKM_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise:
+        ;Retrig?
+        rra
+                               .if PLY_AKM_SE_Retrig                  ;CONFIG SPECIFIC
+        jr nc,PLY_AKM_PSES_H_AfterRetrig
+        ld d,a
+        ld a,#0xff
+        ld (PLY_AKM_SetReg13Old + PLY_AKM_Offset1b),a
+        ld a,d
+PLY_AKM_PSES_H_AfterRetrig:
+                               .endif ;PLY_AKM_SE_Retrig
+
+        ;The hardware envelope can be set (8-15).
+        and #0b111
+        add a,#0x08
+        ld (PLY_AKM_SetReg13 + PLY_AKM_Offset1b),a
+
+        ;Noise?
+                               .if PLY_AKM_SE_HardwareNoise           ;CONFIG SPECIFIC. B not needed after, we can put it in the condition too.
+        rl b
+        call c,PLY_AKM_PSES_ReadNoiseAndOpenNoiseChannel
+                               .endif ;PLY_AKM_SE_HardwareNoise
+
+        ;Reads the hardware period.
+        call PLY_AKM_PSES_ReadHardwarePeriod
+
+        ;Sets the volume to "hardware". It still may be decreased.
+        ld a,#0x10
+        jp PLY_AKM_PSES_ManageVolumeFromA_Hard
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+
+                       .if PLY_AKM_SE_Noise
+;Reads the noise pointed by HL, increases HL, and opens the noise channel.
+PLY_AKM_PSES_ReadNoiseAndOpenNoiseChannel:
+        ;Reads the noise.
+        ld a,(hl)
+        ld (PLY_AKM_NoiseRegister),a
+        inc hl
+
+        ;Opens noise channel.
+        res 5,c
+        ret
+                       .endif ;PLY_AKM_SE_Noise
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+;Reads the hardware period from HL and sets the R11/R12 registers. HL is incremented of 2.
+PLY_AKM_PSES_ReadHardwarePeriod:
+        ld a,(hl)
+        ld (PLY_AKM_Reg11),a
+        inc hl
+        ld a,(hl)
+        ld (PLY_AKM_Reg12),a
+        inc hl
+        ret
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+;Reads the software period from HL and sets the period registers thanks to IY. HL is incremented of 2.
+PLY_AKM_PSES_ReadSoftwarePeriod:
+        ld a,(hl)
+        ld PLY_AKM_Registers_OffsetSoftwarePeriodLSB (iy),a
+        inc hl
+        ld a,(hl)
+        ld PLY_AKM_Registers_OffsetSoftwarePeriodMSB (iy),a
+        inc hl
+        ret
+
+                       .if PLY_AKM_SE_VolumeSoft      ;CONFIG SPECIFIC
+;Reads the volume in A, decreases it from the inverted volume of the channel, and sets the volume via IY.
+;IN:    A = volume, from 0 to 15 (no hardware envelope).
+PLY_AKM_PSES_ManageVolumeFromA_Filter4Bits:
+        and #0b1111
+                       .endif ;PLY_AKM_SE_VolumeSoft
+                       .if PLY_AKM_SE_VolumeSoftOrHard        ;CONFIG SPECIFIC
+;After the filtering. Useful for hardware sound (volume has been forced to 16).
+PLY_AKM_PSES_ManageVolumeFromA_Hard:
+        ;Decreases the volume, checks the limit.
+        sub PLY_AKM_SoundEffectData_OffsetInvertedVolume (ix)
+        jr nc,PLY_AKM_PSES_MVFA_NoOverflow
+        xor a
+PLY_AKM_PSES_MVFA_NoOverflow:
+        ld PLY_AKM_Registers_OffsetVolume (iy),a
+        ret
+                       .endif ;PLY_AKM_SE_VolumeSoftOrHard
+
+
+        ;The data for RAM player. For ROM player, it is declared in the main player.
+       .ifeq PLY_AKM_Rom
+;The data of the Channels MUST be consecutive.
+PLY_AKM_Channel1_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKM_Channel1_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKM_Channel1_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKM_Channel1_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+.equ PLY_AKM_Channel_SoundEffectDataSize , . - PLY_AKM_Channel1_SoundEffectData
+    
+PLY_AKM_Channel2_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKM_Channel2_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKM_Channel2_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKM_Channel2_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+
+PLY_AKM_Channel3_SoundEffectData:
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_AKM_Channel3_SoundEffectInvertedVolume:
+       .db 0                                            ;Inverted volume.
+PLY_AKM_Channel3_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_AKM_Channel3_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+
+
+       .endif ;PLY_AKM_Rom
+        
+;Offset from the beginning of the data, to reach the inverted volume.
+.equ PLY_AKM_SoundEffectData_OffsetInvertedVolume  , PLY_AKM_Channel1_SoundEffectInvertedVolume - PLY_AKM_Channel1_SoundEffectData
+.equ PLY_AKM_SoundEffectData_OffsetCurrentStep  , PLY_AKM_Channel1_SoundEffectCurrentStep - PLY_AKM_Channel1_SoundEffectData
+.equ PLY_AKM_SoundEffectData_OffsetSpeed  , PLY_AKM_Channel1_SoundEffectSpeed - PLY_AKM_Channel1_SoundEffectData
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm_var.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm_var.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAkm_var.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAkm_var.src	2025-01-11 16:57:38
@@ -0,0 +1,147 @@
+    .if HARDWARE_ENTERPRISE
+.equ PLY_AKM_HARDWARE_ENTERPRISE  , 1
+    .else
+.equ PLY_AKM_HARDWARE_ENTERPRISE  , 0
+    .endif
+    .if HARDWARE_CPC
+.equ PLY_AKM_HARDWARE_CPC         , 1
+    .else
+.equ PLY_AKM_HARDWARE_CPC         , 0
+    .endif
+
+.equ PLY_AKM_HARDWARE_MSX         , 0
+.equ PLY_AKM_HARDWARE_SPECTRUM    , 0
+.equ PLY_AKM_HARDWARE_PENTAGON    , 0
+
+.equ PLY_AKM_USE_HOOKS                       ,   1       ;Use hooks for external calls? 0 if the Init/Play methods are directly called, will save a few bytes.
+.equ PLY_AKM_STOP_SOUNDS                     ,   1       ;1 to have the "stop sounds" code. Set it to 0 if you never plan on stopping your music.
+
+.equ PLY_CFG_UseTranspositions               ,   1
+.equ PLY_CFG_UseSpeedTracks                  ,   1
+.equ PLY_CFG_UseEffects                      ,   1
+.equ PLY_CFG_UseHardwareSounds               ,   1
+.equ PLY_CFG_NoSoftNoHard_Noise              ,   1
+.equ PLY_CFG_SoftOnly_Noise                  ,   1
+.equ PLY_CFG_SoftOnly_SoftwarePitch          ,   1
+.equ PLY_CFG_SoftOnly_SoftwareArpeggio       ,   1
+.equ PLY_CFG_SoftToHard_SoftwarePitch        ,   1
+.equ PLY_CFG_SoftToHard_SoftwareArpeggio     ,   1
+.equ PLY_CFG_SoftAndHard_SoftwarePitch       ,   1
+.equ PLY_CFG_SoftAndHard_SoftwareArpeggio    ,   1
+.equ PLY_CFG_UseEffect_ArpeggioTable         ,   1
+.equ PLY_CFG_UseEffect_ForcePitchTableSpeed  ,   1
+.equ PLY_CFG_UseEffect_ForceArpeggioSpeed    ,   1
+.equ PLY_CFG_UseEffect_ForceInstrumentSpeed  ,   1
+.equ PLY_CFG_UseEffect_PitchUp               ,   1
+.equ PLY_CFG_UseEffect_PitchDown             ,   1
+.equ PLY_CFG_UseEffect_PitchTable            ,   1
+.equ PLY_CFG_UseEffect_SetVolume             ,   1
+.equ PLY_CFG_UseEffect_Reset                 ,   1
+
+.equ PLY_AKM_MANAGE_SOUND_EFFECTS            ,   1
+
+;PLY_CFG_UseHardwareSounds               ,   1
+.equ PLY_CFG_SFX_LoopTo                      ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard                ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard_Noise          ,   1
+.equ PLY_CFG_SFX_SoftOnly                    ,   1
+.equ PLY_CFG_SFX_SoftOnly_Noise              ,   1
+.equ PLY_CFG_SFX_HardOnly                    ,   1
+.equ PLY_CFG_SFX_HardOnly_Noise              ,   1
+.equ PLY_CFG_SFX_HardOnly_Retrig             ,   1
+.equ PLY_CFG_SFX_SoftAndHard                 ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Noise           ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Retrig          ,   1
+
+        ;Agglomerates some flags, because they are treated the same way by this player.
+        ;--------------------------------------------------
+        ;Creates a flag for pitch in instrument, and also pitch in hardware.
+       .if PLY_CFG_SoftOnly_SoftwarePitch + PLY_CFG_SoftToHard_SoftwarePitch + PLY_CFG_SoftAndHard_SoftwarePitch
+.equ PLY_AKM_PitchInInstrument , 1
+       .else
+.equ PLY_AKM_PitchInInstrument , 0
+       .endif
+       .if PLY_CFG_SoftToHard_SoftwarePitch + PLY_CFG_SoftAndHard_SoftwarePitch
+.equ PLY_AKM_PitchInHardwareInstrument , 1
+       .else
+.equ PLY_AKM_PitchInHardwareInstrument , 0
+       .endif
+        ;A flag for Arpeggios in Instrument, both in software and hardware.
+       .if PLY_CFG_SoftOnly_SoftwareArpeggio + PLY_CFG_SoftToHard_SoftwareArpeggio + PLY_CFG_SoftAndHard_SoftwareArpeggio
+.equ PLY_AKM_ArpeggioInSoftwareOrHardwareInstrument , 1
+       .else
+.equ PLY_AKM_ArpeggioInSoftwareOrHardwareInstrument , 0
+       .endif
+       .if PLY_CFG_SoftToHard_SoftwareArpeggio + PLY_CFG_SoftAndHard_SoftwareArpeggio
+.equ PLY_AKM_ArpeggioInHardwareInstrument , 1
+       .else
+.equ PLY_AKM_ArpeggioInHardwareInstrument , 0
+       .endif
+
+        ;A flag if noise is used (noise in hardware not tested, not present in this format).
+       .if PLY_CFG_NoSoftNoHard_Noise + PLY_CFG_SoftOnly_Noise
+.equ PLY_AKM_USE_Noise , 1
+       .else
+.equ PLY_AKM_USE_Noise , 0
+       .endif
+        
+        ;Mixing Pitch up/down effects.
+       .if PLY_CFG_UseEffect_PitchUp + PLY_CFG_UseEffect_PitchDown
+.equ PLY_AKM_USE_EffectPitchUpDown , 1
+       .else
+.equ PLY_AKM_USE_EffectPitchUpDown , 0
+       .endif
+        
+        ;If the Force Arpeggio Speed if used, it means the ArpeggioTable effect must also be!
+       .if PLY_CFG_UseEffect_ForceArpeggioSpeed 
+        .ifeq PLY_CFG_UseEffect_ArpeggioTable
+            FAIL "please set: PLY_CFG_UseEffect_ArpeggioTable , 1"
+        .endif
+       .endif
+        ;If the Force Pitch Table Speed if used, it means the PitchTable effect must also be!
+       .if PLY_CFG_UseEffect_ForcePitchTableSpeed 
+        .ifeq PLY_CFG_UseEffect_PitchTable
+            FAIL "please set: PLY_CFG_UseEffect_PitchTable , 1"
+        .endif
+       .endif 
+        
+       .if PLY_CFG_SFX_HardOnly + PLY_CFG_SFX_SoftAndHard
+.equ PLY_AKM_SE_HardwareSounds , 1
+       .else
+.equ PLY_AKM_SE_HardwareSounds , 0
+       .endif
+;       Mixes the Hardware Noise flags into one.
+       .if PLY_CFG_SFX_HardOnly_Noise + PLY_CFG_SFX_SoftAndHard_Noise
+.equ PLY_AKM_SE_HardwareNoise , 1
+       .else
+.equ PLY_AKM_SE_HardwareNoise , 0
+       .endif
+;       Mixes the Noise flags into one.
+       .if PLY_AKM_SE_HardwareNoise + PLY_CFG_SFX_NoSoftNoHard_Noise + PLY_CFG_SFX_SoftOnly
+.equ PLY_AKM_SE_Noise , 1
+       .else
+.equ PLY_AKM_SE_Noise , 0
+       .endif
+;       Mixes the Software Volume flags into one.
+       .if PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly
+.equ PLY_AKM_SE_VolumeSoft , 1
+       .else
+.equ PLY_AKM_SE_VolumeSoft , 0
+       .endif
+       .if PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly + PLY_CFG_UseHardwareSounds
+.equ PLY_AKM_SE_VolumeSoftOrHard , 1
+       .else
+.equ PLY_AKM_SE_VolumeSoftOrHard , 0
+       .endif
+;       Mixes the retrig flags into one.
+       .if PLY_CFG_SFX_HardOnly_Retrig + PLY_CFG_SFX_SoftAndHard_Retrig
+.equ PLY_AKM_SE_Retrig , 1
+       .else
+.equ PLY_AKM_SE_Retrig , 0
+       .endif
+
+       .if PLY_AKM_USE_Noise + PLY_AKM_SE_Noise
+.equ PLY_AKM_USE_NoiseRegister , 1
+       .else
+.equ PLY_AKM_USE_NoiseRegister , 0
+       .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAky.s cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAky.s
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAky.s	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAky.s	2025-01-11 16:57:38
@@ -0,0 +1,2502 @@
+;       AKY music player - V1.0.
+;       By Julien Nvo a.k.a. Targhan/Arkos.
+;       CPC PSG sending optimization trick by Madram/Overlanders.
+;       December 2016.
+;
+;       This compiles with RASM. Please check the compatibility page on Arkos Tracker 2 website, there is a Source Converter (Disark) for ANY assembler!
+;
+;       The player uses the stack for optimizations. Make sure the interruptions are disabled before it is called.
+;       The stack pointer is saved at the beginning and restored at the end.
+;
+;       Multi-PSG
+;       ----------------------
+;       This player only target 1 PSG, as it allows some nice optimizations.
+;       For Multi-PSG hardware, such as PlayCity (CPC), TurboSound (Spectrum) or SpecNext, please check the PlayerAkyMultiPsg.asm!
+;
+;       Hardware target
+;       ----------------------
+;       This code can target Amstrad CPC, MSX, Spectrum and Pentagon. By default, it targets Amstrad CPC.
+;       Simply use one of the follow line (BEFORE this player):
+;       PLY_AKY_HARDWARE_CPC = 1
+;       PLY_AKY_HARDWARE_MSX = 1
+;       PLY_AKY_HARDWARE_SPECTRUM = 1
+;       PLY_AKY_HARDWARE_PENTAGON = 1
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+;
+;       Sound effects
+;       ----------------------
+;       This player does not support sound effects. For this, use the AKY Multi-Psg (in the same folder).
+;
+;       ROM
+;       ----------------------
+;       To use a ROM player (no automodification, use of a small buffer to put in RAM):
+;       PLY_AKY_ROM = 1
+;       PLY_AKY_ROM_Buffer = #4000 (or wherever). The buffer is 29 bytes long (PLY_AKY_ROM_BufferSize).
+;       This makes the player a bit slower and very slightly bigger.
+;
+;       Optimizations
+;       ----------------------
+;       - Use the Player Configuration of Arkos Tracker 2 to generate a configuration file to be included at the beginning of this player.
+;         It will disable useless features according to your songs! Check the manual for more details, or more simply the testers.
+;       - SIZE: The JP hooks at the beginning can be removed if you include this code in yours directly (see the PLY_AKY_UseHooks flag below).
+;       - SIZE: If you don't play a song twice, all the code in PLY_AKY_Init can be removed, except the first lines that skip the header.
+;       - SIZE: The header is only needed for players that want to load any song. Most of the time, you don't need it. Erase both the init code and the header bytes in the song.
+;       - CPU:  We *could* save 3 NOPS by removing the first "jp PLY_AKY_ReadRegisterBlock" and stucking the whole code instead. But it would make the whole really ugly.
+;
+;       -------------------------------------------------------
+; _main::
+.module cpct_audio
+        .include "../../CPCteleraHW.src"
+        .include "arkostrackerAky_var.src"
+.equ PLY_AKY_ROM                 ,   0
+
+PLY_AKY_Start:
+
+        ;A nice trick to manage the offset using the same instructions, according to the player (ROM or not).
+       .if PLY_AKY_ROM
+.equ PLY_AKY_Offset1b  , 0
+       .else
+.equ PLY_AKY_Offset1b  , 1
+       .endif
+
+       .ifeq PLY_AKY_ROM
+.equ PLY_AKY_OPCODE_OR_A  , #0xb7                        ;Opcode for "or a".
+.equ PLY_AKY_OPCODE_SCF  , #0x37                         ;Opcode for "scf".
+       .else
+        ;Another trick for the ROM player. The original opcodes are converted to number, which will be multiplied by 2, provoking a carry or not.
+.equ PLY_AKY_OPCODE_OR_A  , 0                          ;0 * 2 = 0, no carry.
+.equ PLY_AKY_OPCODE_SCF  , #0xff                         ;255 * 2 = carry.
+       .endif
+
+        ;Only 3 channels for this player.        
+PLY_AKY_ChannelCount = 3
+
+       
+      ;-------------------------------------------------------
+
+        ;Hooks for external calls. Can be removed if not needed.
+        .if PLY_AKY_UseHooks
+                jp PLY_AKY_Init             ;Player + 0.
+                jp PLY_AKY_Play             ;Player + 3.
+        .endif
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKY_musicInit
+;;
+;;    Sets up a music into Arkos Tracker Player to be played later on with
+;; <cpct_akpAKY_musicPlay>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKY_musicInit> (void* *songdata*)
+;;
+;; Input Parameters (2 bytes):
+;;    (2B HL) songdata - Pointer to the start of the array containing song's data in AKS binary format
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKY_musicInit_asm
+;;
+;; Parameter Restrictions:
+;;    * *songdata* must be an array containing dong's data in AKS binary format.
+;; Take into account that AKS binary format enforces a concrete start location in
+;; memory. Therefore, song must have been created in Arkos Tracker and exported 
+;; to the same memory location that *songdata* points to. If you fail to 
+;; locate the song at the same memory location it was exported for in Arkos 
+;; Tracker, unexpected results will happen (Typically, noise will be played but,
+;; occasionally your program may hang or crash).
+;;
+;; Known limitations:
+;;    * *songdata* must be the same memory address that the one given to Arkos
+;; Tracker when exporting song's binary. Arkos Tracker songs are created to
+;; be at a concrete memory location, due to optimization constraints. Therefore,
+;; this must be taken into account. If you wanted to change the memory location
+;; of the song, you should first open the song into Arkos Tracker and export
+;; it again with the new desired memory location.
+;;    * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function should be called fist to initialize the song that is to be 
+;; played. The function reads the song header and sets up the player to start 
+;; playing it. Once this process is done, <cpct_akp_musicPlay> should be called
+;; at the required frequency to continuously play the song.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL
+;;
+;; Required memory:
+;;    ? bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
+_cpct_akpAKY_musicInit::
+   ld   hl, #2    ;; [10] Retrieve parameters from stack
+   add  hl, sp    ;; [11]
+   ld    e, (hl)  ;; [ 7] DE = Pointer to the start of music
+   inc  hl        ;; [ 6]
+   ld    d, (hl)  ;; [ 7]
+   ex   de,hl
+
+cpct_akpAKY_musicInit_asm::   ;; Entry point for assembly calls using registers for parameter passing
+   ;; First, set song loop times to 0 when we start
+   xor   a                          ;; A = 0
+   ld (_cpct_akpAKY_songLoopTimes), a  ;; _cpct_akpAKY_songLoopTimes = 0
+
+;       Initializes the player.
+;       HL = music address.
+PLY_AKY_InitDisarkGenerateExternalLabel:
+PLY_AKY_Init:
+        ;Skips the header.
+        inc hl                          ;Skips the format version.
+        ld a,(hl)                       ;Channel count.
+        inc hl
+        ld de,#0x0004
+PLY_AKY_Init_SkipHeaderLoop:                ;There is always at least one PSG to skip.
+        add hl,de
+        sub #0x03                           ;A PSG is three channels.
+        jr z,PLY_AKY_Init_SkipHeadeENDM
+        jr nc,PLY_AKY_Init_SkipHeaderLoop   ;Security in case of the PSG channel is not a multiple of 3.
+PLY_AKY_Init_SkipHeadeENDM:
+        ld (PLY_AKY_PtLinker + PLY_AKY_Offset1b),hl        ;HL now points on the Linker.
+
+        ld a,#PLY_AKY_OPCODE_OR_A
+        ld (PLY_AKY_Channel1_RegisterBlockLineState_Opcode),a
+        ld (PLY_AKY_Channel2_RegisterBlockLineState_Opcode),a
+        ld (PLY_AKY_Channel3_RegisterBlockLineState_Opcode),a
+        ld hl,#0x01
+        ld (PLY_AKY_PatternFrameCounter + PLY_AKY_Offset1b),hl
+   .if HARDWARE_ENTERPRISE
+        jp     ayReset
+   .else
+        ret
+   .endif
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpAKY_musicPlay
+;;
+;;    Plays next music cycle of the present song with Arkos Tracker Player. Song 
+;; has had to be previously established with <cpct_akp_musicInit>.
+;;
+;; C Definition:
+;;    void <cpct_akpAKY_musicPlay> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpAKY_musicPlay_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function is to be called to start and continue playing the presently 
+;; selected song with Arkos Tracker Player. Depending on the frequency at which 
+;; the song were created, this function should be called 12, 25, 50, 100, 200 
+;; or 300 times per second. 
+;;
+;;    Each time you call the function, it plays 1/frequency seconds. This means
+;; that you have to manually synchronize your calls to this function to have
+;; a stable music playing. If you call too fast or too slow you will either 
+;; interrupt sound or have sound valleys. Therefore, you are responsible for
+;; calling this function with the most accurate timing possible, to get best 
+;; sound results.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL
+;;
+;; Required memory:
+;;    xxxx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpAKY_musicPlay::
+cpct_akpAKY_musicPlay_asm::   ;; Entry point for assembly calls  
+  .if HARDWARE_ENTERPRISE
+   .ifeq NO_ENVELOPE_IRQ
+    .if ENABLE_1000HZ_IRQ
+        in      a,(#0xb4)
+        and     #0x02
+        jp      nz,envelopeInterrupt
+        ld      a,#0x31
+        out     (#0xb4),a
+    .else
+     .if ENABLE_300HZ_IRQ
+cntr    ld      a,#0x06
+        dec     a
+        ld      (cntr+1),a
+        jp      nz,envelopeInterrupt
+        ld      a,#0x06
+        ld      (cntr+1),a
+     .else
+        call    envelopeInterrupt
+     .endif
+    .endif
+   .endif
+  .endif
+
+;       Plays the music. It must have been initialized before.
+;       The interruption SHOULD be disabled (DI), as the stack is heavily used.
+PLY_AKY_PlayDisarkGenerateExternalLabel:
+PLY_AKY_Play:
+       .ifeq PLY_AKY_ROM
+        ld (PLY_AKY_Exit + 1),sp
+       .else
+        ld (PLY_AKY_SaveSp),sp
+       .endif
+
+
+;Linker.
+;----------------------------------------
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_PatternFrameCounter: ld hl,#0x01                ;How many frames left before reading the next Pattern.
+       .else
+        ld hl,(PLY_AKY_PatternFrameCounter)
+       .endif
+        dec hl
+        ld a,l
+        or h
+        jr z,PLY_AKY_PatternFrameCounter_Over
+        ld (PLY_AKY_PatternFrameCounter + PLY_AKY_Offset1b),hl
+        ;The pattern is not over.
+       .ifeq PLY_AKY_ROM
+        jr PLY_AKY_Channel1_WaitBeforeNextRegisterBlock
+       .else
+        jr PLY_AKY_Channel1_WaitBeforeNextRegisterBlock_Start
+       .endif
+
+PLY_AKY_PatternFrameCounter_Over:
+
+;The pattern is over. Reads the next one.
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_PtLinker: ld sp,#0x0000                                   ;Points on the Pattern of the linker.
+       .else
+        ld sp,(PLY_AKY_PtLinker)                            ;Points on the Pattern of the linker.
+       .endif
+        pop hl                                          ;Gets the duration of the Pattern, or 0 if end of the song.
+        ld a,l
+        or h
+        jr nz,PLY_AKY_LinkerNotEndSong
+   ;; Increment song loop times
+   ld    a, (_cpct_akpAKY_songLoopTimes)
+   inc   a
+   ld (_cpct_akpAKY_songLoopTimes), a 
+        ;End of the song. Where to loop?
+        pop hl
+        ;We directly point on the frame counter of the pattern to loop to.
+        ld sp,hl
+        ;Gets the duration again. No need to check the end of the song,
+        ;we know it contains at least one pattern.
+        pop hl
+PLY_AKY_LinkerNotEndSong:
+        ld (PLY_AKY_PatternFrameCounter + PLY_AKY_Offset1b),hl
+
+        pop hl
+        ld (PLY_AKY_Channel1_PtTrack + PLY_AKY_Offset1b),hl
+        pop hl
+        ld (PLY_AKY_Channel2_PtTrack + PLY_AKY_Offset1b),hl
+        pop hl
+        ld (PLY_AKY_Channel3_PtTrack + PLY_AKY_Offset1b),hl
+
+        ld (PLY_AKY_PtLinker + PLY_AKY_Offset1b),sp
+
+        ;Resets the RegisterBlocks of the channel >1. The first one is skipped so there is no need to do so.
+        ld a,#0x01
+        ld (PLY_AKY_Channel2_WaitBeforeNextRegisterBlock + PLY_AKY_Offset1b),a
+        ld (PLY_AKY_Channel3_WaitBeforeNextRegisterBlock + PLY_AKY_Offset1b),a
+        jr PLY_AKY_Channel1_WaitBeforeNextRegisterBlock_Over
+;; Loop times
+;;    Read here to know the number of times a song has looped
+_cpct_akpAKY_songLoopTimes:: .db 0 
+;Reading the Tracks.
+;----------------------------------------
+
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel1_WaitBeforeNextRegisterBlock: ld a,#0x01        ;Frames to wait before reading the next RegisterBlock. 0 = finished.
+       .else
+PLY_AKY_Channel1_WaitBeforeNextRegisterBlock_Start:
+        ld a,(PLY_AKY_Channel1_WaitBeforeNextRegisterBlock)
+       .endif
+        dec a
+        jr nz,PLY_AKY_Channel1_RegisterBlock_Process
+PLY_AKY_Channel1_WaitBeforeNextRegisterBlock_Over:
+        ;This RegisterBlock is finished. Reads the next one from the Track.
+        ;Obviously, starts at the initial state.
+        ld a,#PLY_AKY_OPCODE_OR_A
+        ld (PLY_AKY_Channel1_RegisterBlockLineState_Opcode),a
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel1_PtTrack: ld sp,#0x0000                   ;Points on the Track.
+       .else
+        ld sp,(PLY_AKY_Channel1_PtTrack)
+       .endif
+        dec sp                                  ;Only one byte is read. Compensate.
+        pop af                                  ;Gets the duration.
+        pop hl                                  ;Reads the RegisterBlock address.
+
+        ld (PLY_AKY_Channel1_PtTrack + PLY_AKY_Offset1b),sp
+        ld (PLY_AKY_Channel1_PtRegisterBlock + PLY_AKY_Offset1b),hl
+
+        ;A is the duration of the block.
+PLY_AKY_Channel1_RegisterBlock_Process:
+        ;Processes the RegisterBlock, whether it is the current one or a new one.
+        ld (PLY_AKY_Channel1_WaitBeforeNextRegisterBlock + PLY_AKY_Offset1b),a
+        
+
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel2_WaitBeforeNextRegisterBlock: ld a,#0x01        ;Frames to wait before reading the next RegisterBlock. 0 = finished.
+       .else
+PLY_AKY_Channel2_WaitBeforeNextRegisterBlock_Start:
+        ld a,(PLY_AKY_Channel2_WaitBeforeNextRegisterBlock)
+       .endif
+        dec a
+        jr nz,PLY_AKY_Channel2_RegisterBlock_Process
+PLY_AKY_Channel2_WaitBeforeNextRegisterBlock_Over:
+        ;This RegisterBlock is finished. Reads the next one from the Track.
+        ;Obviously, starts at the initial state.
+        ld a,#PLY_AKY_OPCODE_OR_A
+        ld (PLY_AKY_Channel2_RegisterBlockLineState_Opcode),a
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel2_PtTrack: ld sp,#0x0000                   ;Points on the Track.
+       .else
+        ld sp,(PLY_AKY_Channel2_PtTrack)
+       .endif
+        dec sp                                  ;Only one byte is read. Compensate.
+        pop af                                  ;Gets the duration.
+        pop hl                                  ;Reads the RegisterBlock address.
+
+        ld (PLY_AKY_Channel2_PtTrack + PLY_AKY_Offset1b),sp
+        ld (PLY_AKY_Channel2_PtRegisterBlock + PLY_AKY_Offset1b),hl
+
+        ;A is the duration of the block.
+PLY_AKY_Channel2_RegisterBlock_Process:
+        ;Processes the RegisterBlock, whether it is the current one or a new one.
+        ld (PLY_AKY_Channel2_WaitBeforeNextRegisterBlock + PLY_AKY_Offset1b),a
+        
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel3_WaitBeforeNextRegisterBlock: ld a,#0x01        ;Frames to wait before reading the next RegisterBlock. 0 = finished.
+       .else
+PLY_AKY_Channel3_WaitBeforeNextRegisterBlock_Start:
+        ld a,(PLY_AKY_Channel3_WaitBeforeNextRegisterBlock)
+       .endif
+        dec a
+        jr nz,PLY_AKY_Channel3_RegisterBlock_Process
+PLY_AKY_Channel3_WaitBeforeNextRegisterBlock_Over:
+        ;This RegisterBlock is finished. Reads the next one from the Track.
+        ;Obviously, starts at the initial state.
+        ld a,#PLY_AKY_OPCODE_OR_A
+        ld (PLY_AKY_Channel3_RegisterBlockLineState_Opcode),a
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel3_PtTrack: ld sp,#0x0000                   ;Points on the Track.
+       .else
+        ld sp,(PLY_AKY_Channel3_PtTrack)
+       .endif
+        dec sp                                  ;Only one byte is read. Compensate.
+        pop af                                  ;Gets the duration.
+        pop hl                                  ;Reads the RegisterBlock address.
+
+        ld (PLY_AKY_Channel3_PtTrack + PLY_AKY_Offset1b),sp
+        ld (PLY_AKY_Channel3_PtRegisterBlock + PLY_AKY_Offset1b),hl
+
+        ;A is the duration of the block.
+PLY_AKY_Channel3_RegisterBlock_Process:
+        ;Processes the RegisterBlock, whether it is the current one or a new one.
+        ld (PLY_AKY_Channel3_WaitBeforeNextRegisterBlock + PLY_AKY_Offset1b),a
+        
+
+
+
+;Reading the RegisterBlock.
+;----------------------------------------
+        ;Auxiliary registers are for the PSG access.
+          ld hl,#0x08                             ;H = first frequency register, L = first volume register.
+       .if PLY_AKY_HARDWARE_CPC
+          ld de,#0xf4f6                             ;PSG ports.
+          ld bc,#0xf690                             ;#90 used for both #80 for the PSG, and volume 16!
+
+          ld a,#0xc0                                ;Used for PSG.
+          out (c),a                               ;f6c0. Madram's trick requires to start with this. out (c),b works, but will activate K7's relay! Not clean.
+        ex af,af'
+       .endif
+
+       .if PLY_AKY_HARDWARE_MSX
+                ld c,#0x10                          ;Hardware volume.
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+          ld de,#0xbfff                             ;PSG ports. E is also used for Volume = Hardware (bit 5 to 1).
+          ld bc,#0xfffd
+       .endif
+        exx
+
+        ;In B, R7 with default values: fully sound-open but noise-close.
+        ;R7 has been shift twice to the left, it will be shifted back as the channels are treated.
+        ld bc,#0b11100000 * 256 + #0xff                     ;C is 255 to prevent the following LDIs to decrease B.
+
+       .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld sp,(PLY_AKY_Exit+1)
+       .else
+        ld sp,#PLY_AKY_RetTable_ReadRegisterBlock
+       .endif
+        ;Channel 1
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel1_PtRegisterBlock: ld hl,#0x0000                   ;Points on the data of the RegisterBlock to read.
+       .else
+        ld hl,(PLY_AKY_Channel1_PtRegisterBlock)
+       .endif
+
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel1_RegisterBlockLineState_Opcode: or a        ;"or a" if initial state, "scf" (#37) if non-initial state.
+       .else
+        ld a,(PLY_AKY_Channel1_RegisterBlockLineState_Opcode)
+        add a,a                                             ;Carry is set according to the opcode.
+       .endif
+       .if PLY_AKY_HARDWARE_ENTERPRISE
+        call PLY_AKY_ReadRegisterBlock
+       .else
+        jp PLY_AKY_ReadRegisterBlock
+       .endif
+PLY_AKY_Channel1_RegisterBlock_Return:
+        ld a,#PLY_AKY_OPCODE_SCF
+        ld (PLY_AKY_Channel1_RegisterBlockLineState_Opcode),a
+        ld (PLY_AKY_Channel1_PtRegisterBlock + PLY_AKY_Offset1b),hl        ;This is new pointer on the RegisterBlock.
+
+
+        ;Channel 2
+        ;Shifts the R7 for the next channels.
+        srl b           ;Not RR, because we have to make sure the b6 is 0, else no more keyboard (on CPC)!
+                        ;Also, on MSX, bit 6 must be 0.
+
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel2_PtRegisterBlock: ld hl,#0x0000                   ;Points on the data of the RegisterBlock to read.
+       .else
+        ld hl,(PLY_AKY_Channel2_PtRegisterBlock)
+       .endif
+
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel2_RegisterBlockLineState_Opcode: or a        ;"or a" if initial state, "scf" (#37) if non-initial state.
+       .else
+        ld a,(PLY_AKY_Channel2_RegisterBlockLineState_Opcode)
+        add a,a                                             ;Carry is set according to the opcode.
+       .endif
+       .if PLY_AKY_HARDWARE_ENTERPRISE
+        call PLY_AKY_ReadRegisterBlock
+       .else
+        jp PLY_AKY_ReadRegisterBlock
+       .endif
+PLY_AKY_Channel2_RegisterBlock_Return:
+        ld a,#PLY_AKY_OPCODE_SCF
+        ld (PLY_AKY_Channel2_RegisterBlockLineState_Opcode),a
+        ld (PLY_AKY_Channel2_PtRegisterBlock + PLY_AKY_Offset1b),hl        ;This is new pointer on the RegisterBlock.
+
+        
+        ;Channel 3
+        ;Shifts the R7 for the next channels.
+       .if PLY_AKY_HARDWARE_MSX
+                scf             ;On MSX, bit 7 must be 1.
+                rr b
+       .else
+                rr b            ;Safe to use RR, we don't care if b7 of R7 is 0 or 1.
+       .endif
+
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Channel3_PtRegisterBlock: ld hl,#0x0000                   ;Points on the data of the RegisterBlock to read.
+       .else
+        ld hl,(PLY_AKY_Channel3_PtRegisterBlock)
+       .endif
+
+       .ifeq PLY_AKY_ROM
+PLY_AKY_Channel3_RegisterBlockLineState_Opcode: or a        ;"or a" if initial state, "scf" (#37) if non-initial state.
+       .else
+        ld a,(PLY_AKY_Channel3_RegisterBlockLineState_Opcode)
+        add a,a                                             ;Carry is set according to the opcode.
+       .endif
+       .if PLY_AKY_HARDWARE_ENTERPRISE
+        call PLY_AKY_ReadRegisterBlock
+       .else
+        jp PLY_AKY_ReadRegisterBlock
+       .endif
+PLY_AKY_Channel3_RegisterBlock_Return:
+        ld a,#PLY_AKY_OPCODE_SCF
+        ld (PLY_AKY_Channel3_RegisterBlockLineState_Opcode),a
+        ld (PLY_AKY_Channel3_PtRegisterBlock + PLY_AKY_Offset1b),hl        ;This is new pointer on the RegisterBlock.
+
+        
+        ;Register 7 to A.
+        ld a,b
+
+;Almost all the channel specific registers have been sent. Now sends the remaining registers (6, 7, 11, 12, 13).
+
+;Register 7. Note that managing register 7 before 6/11/12 is done on purpose (the 6/11/12 registers are filled using OUTI).
+        exx
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,#0x07
+        call    ayRegisterWrite
+;Register 6
+       .if PLY_AKY_USE_Noise         ;CONFIG SPECIFIC
+        ld      c,#0x06
+        ld      a,(PLY_AKY_PsgRegister6)
+        call    ayRegisterWrite
+       .endif
+        
+       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ld      c,#0x0b
+        ld      a,(PLY_AKY_PsgRegister11)
+        call    ayRegisterWrite
+        ld      c,#0x0c
+        ld      a,(PLY_AKY_PsgRegister12)
+        call    ayRegisterWrite
+       .endif ;PLY_CFG_UseHardwareSounds
+      .endif
+
+       .if PLY_AKY_HARDWARE_CPC
+                inc h           ;Was 6, so now 7!
+
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+
+;Register 6
+                       .if PLY_AKY_USE_Noise         ;CONFIG SPECIFIC
+                dec h
+
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+
+                ld hl,#PLY_AKY_PsgRegister6
+                dec b           ; -1, not -2 because of OUTI does -1 before doing the out.
+                outi            ;f400 + value
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+                       .else
+                        ;No noise. Still, makes HL points on the data after the noise.
+                        ld hl,#PLY_AKY_PsgRegister6 + 1
+                       .endif ;PLY_AKY_USE_Noise
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+;Register 11
+                ld a,#0x0b         ;Next register
+
+                ld b,d
+                out (c),a       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                dec b
+                outi            ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+
+
+;Register 12
+                inc a           ;Next register
+
+                ld b,d
+                out (c),a       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                dec b
+                outi            ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+                       .endif ;PLY_CFG_UseHardwareSounds
+                
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                inc h           ;Was 6, so now 7!
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+        
+                ;Register 6.
+                       .if PLY_AKY_USE_Noise         ;CONFIG SPECIFIC
+                dec h
+                out (c),h       ;#fffd + register.
+                ld b,d
+                ld a,(PLY_AKY_PsgRegister6)     ;COULD be optimized, but I didn't want to change the code structure from one platform to another one.
+                out (c),a       ;#bffd + value
+                ld b,e
+                       .endif ;PLY_AKY_USE_Noise
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+
+                ;Register 11.
+                ld h,#0x0b
+                out (c),h       ;#fffd + register.
+                ld b,d
+                ld a,(PLY_AKY_PsgRegister11)
+                out (c),a       ;#bffd + value
+                ld b,e
+                
+                ;Register 12.
+                inc h
+                out (c),h       ;#fffd + register.
+                ld b,d
+                ld a,(PLY_AKY_PsgRegister12)
+                out (c),a       ;#bffd + value
+                ld b,e
+                       .endif ;PLY_CFG_UseHardwareSounds
+                
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a          ;Preserves R7.
+                ld a,#0x07
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+        
+                       .if PLY_AKY_USE_Noise         ;CONFIG SPECIFIC
+                ld a,#0x06
+                out (#0xa0),a     ;Register.
+                ld a,(PLY_AKY_PsgRegister6)     ;COULD be optimized, but I didn't want to change the code structure from one platform to another one.
+                out (#0xa1),a     ;Value.
+                       .endif ;PLY_AKY_USE_Noise
+                
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+                ld a,#0x0b
+                out (#0xa0),a     ;Register.
+                ld a,(PLY_AKY_PsgRegister11)
+                out (#0xa1),a     ;Value.
+                
+                ld a,#0x0c
+                out (#0xa0),a     ;Register.
+                ld a,(PLY_AKY_PsgRegister12)
+                out (#0xa1),a     ;Value.
+                       .endif ;PLY_CFG_UseHardwareSounds
+       .endif
+
+;Register 13
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+PLY_AKY_PsgRegister13_Code:
+       .if PLY_AKY_ROM
+                ld a,(PLY_AKY_PsgRegister13_Retrig)     ;ROM: needs to keep retrig in a register to compare A with it later.
+                ld b,a
+       .endif
+
+       .if PLY_AKY_HARDWARE_CPC
+                ld a,(hl)
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON + PLY_AKY_HARDWARE_ENTERPRISE + PLY_AKY_HARDWARE_MSX
+                ld a,(PLY_AKY_PsgRegister13)
+       .endif
+        
+       .ifeq PLY_AKY_ROM
+PLY_AKY_PsgRegister13_Retrig: cp #0xff                         ;If IsRetrig?, force the R13 to be triggered.
+       .else
+                cp b
+       .endif
+                jr z,PLY_AKY_PsgRegister13_End
+                ld (PLY_AKY_PsgRegister13_Retrig + PLY_AKY_Offset1b),a
+
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,#0x0d
+        jp      ayRegisterWrite
+      .endif
+
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                ld l,#0x0d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ;ex af,af'
+                
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+               .if PLY_AKY_ROM
+                        ld b,e  ;B has been modified if ROM.
+               .endif
+                ld l,#0x0d
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,#0x0d
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.           
+       .endif
+PLY_AKY_PsgRegister13_End:
+
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+       .ifeq PLY_AKY_ROM
+
+PLY_AKY_Exit: ld sp,#0x0000
+       .else
+        ld sp,(PLY_AKY_SaveSp)
+       .endif
+        ret
+
+
+
+
+
+
+
+
+;Generic code interpreting the RegisterBlock
+;IN:    HL = First byte.
+;       Carry = 0 = initial state, 1 = non-initial state.
+;----------------------------------------------------------------
+
+PLY_AKY_ReadRegisterBlock:
+        ;Gets the first byte of the line. What type? Jump to the matching code.
+        ld a,(hl)
+        inc hl
+        jp c,PLY_AKY_RRB_NonInitialState
+        ;Initial state.
+        rra
+        jr c,PLY_AKY_RRB_IS_SoftwareOnlyOrSoftwareAndHardware
+        rra
+                       .if PLY_CFG_HardOnly  ;CONFIG SPECIFIC
+        jr c,PLY_AKY_RRB_IS_HardwareOnly
+                       .endif ;PLY_CFG_HardOnly
+        ;jr PLY_AKY_RRB_IS_NoSoftwareNoHardware
+
+;Generic code interpreting the RegisterBlock - Initial state.
+;----------------------------------------------------------------
+;IN:    HL = Points after the first byte.
+;       A = First byte, twice shifted to the right (type removed).
+;       B = Register 7. All sounds are open (0) by default, all noises closed (1). The code must put ONLY bit 2 and 5 for sound and noise respectively. NOT any other bits!
+;       C = May be used as a temp. BUT must NOT be 0, as ldi will decrease it, we do NOT want B to be decreased!!
+;       DE = free to use.
+;       IX = free to use (not used!).
+;       IY = free to use (not used!).
+
+;       A' = free to use (not used).
+;       DE' = f4f6
+;       BC' = f680
+;       L' = Volume register.
+;       H' = LSB frequency register.
+
+;OUT:   HL MUST point after the structure.
+;       B = updated (ONLY bit 2 and 5).
+;       L' = Volume register increased of 1 (*** IMPORTANT! The code MUST increase it, even if not using it! ***)
+;       H' = LSB frequency register, increased of 2 (see above).
+;       DE' = unmodified (f4f6)
+;       BC' = unmodified (f680)
+
+.equ PLY_AKY_RRB_NoiseChannelBit  , 5          ;Bit to modify to set/reset the noise channel.
+.equ PLY_AKY_RRB_SoundChannelBit  , 2          ;Bit to modify to set/reset the sound channel.
+
+                       .if PLY_CFG_NoSoftNoHard        ;CONFIG SPECIFIC
+PLY_AKY_RRB_IS_NoSoftwareNoHardware:
+        ;No software no hardware.
+        rra                     ;Noise?
+                       .if PLY_CFG_NoSoftNoHard_Noise        ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_NIS_NoSoftwareNoHardware_ReadVolume
+        ;There is a noise. Reads it.
+        ld de,#PLY_AKY_PsgRegister6
+        ldi                     ;Safe for B, C is not 0. Preserves A.
+
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+PLY_AKY_RRB_NIS_NoSoftwareNoHardware_ReadVolume:
+                       .endif ;PLY_CFG_NoSoftNoHard_Noise
+        ;The volume is now in b0-b3.
+        ;and %1111      ;No need, the bit 7 was 0.
+
+        exx
+                ;Sends the volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+       .endif
+                inc l           ;Increases the volume register.
+                inc h           ;Increases the frequency register.
+                inc h
+        exx
+
+        ;Closes the sound channel.
+        set PLY_AKY_RRB_SoundChannelBit, b
+        ret
+                       .endif ;PLY_CFG_NoSoftNoHard
+
+
+;---------------------
+                       .if PLY_CFG_HardOnly  ;CONFIG SPECIFIC
+PLY_AKY_RRB_IS_HardwareOnly:
+        ;Retrig?
+        rra
+                       .if PLY_CFG_HardOnly_Retrig   ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_IS_HO_NoRetrig
+        set 7,a                         ;A value to make sure the retrig is performed, yet A can still be use.
+        ld (PLY_AKY_PsgRegister13_Retrig + PLY_AKY_Offset1b),a
+PLY_AKY_RRB_IS_HO_NoRetrig:
+                       .endif ;PLY_CFG_HardOnly_Retrig
+
+        ;Noise?
+        rra
+                       .if PLY_CFG_HardOnly_Noise   ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_IS_HO_NoNoise
+        ;Reads the noise.
+        ld de,#PLY_AKY_PsgRegister6
+        ldi                     ;Safe for B, C is not 0. Preserves A.
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+PLY_AKY_RRB_IS_HO_NoNoise:
+                       .endif ;PLY_CFG_HardOnly_Noise
+
+        ;The envelope.
+        and #0b1111
+        ld (PLY_AKY_PsgRegister13),a
+
+        ;Copies the hardware period.
+        ld de,#PLY_AKY_PsgRegister11
+        ldi
+        ldi
+
+        ;Closes the sound channel.
+        set PLY_AKY_RRB_SoundChannelBit, b
+
+        exx
+                ;Sets the hardware volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ld      a,#0x10
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),c       ;f400 + value (volume to 16).
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),e       ;#bffd + value (volume to 16).
+                ld b,e        
+       .endif
+
+       .if PLY_AKY_HARDWARE_MSX
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,c
+                out (#0xa1),a     ;Value (volume to 16).
+       .endif
+
+                inc l           ;Increases the volume register.
+                inc h           ;Increases the frequency register (mandatory!).
+                inc h
+        exx
+        ret
+                       .endif ;PLY_CFG_HardOnly
+
+
+;---------------------
+PLY_AKY_RRB_IS_SoftwareOnlyOrSoftwareAndHardware:
+        ;Another decision to make about the sound type.
+        rra
+                       .if PLY_AKY_USE_SoftAndHard_Agglomerated      ;CONFIG SPECIFIC
+        jr c,PLY_AKY_RRB_IS_SoftwareAndHardware
+                       .endif ;PLY_AKY_USE_SoftAndHard_Agglomerated
+
+        ;Software only. Structure: 0vvvvntt.
+        ;Noise?
+        rra
+                       .if PLY_CFG_SoftOnly_Noise    ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_IS_SoftwareOnly_NoNoise
+        ;Noise. Reads it.
+        ld de,#PLY_AKY_PsgRegister6
+        ldi                     ;Safe for B, C is not 0. Preserves A.
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+PLY_AKY_RRB_IS_SoftwareOnly_NoNoise:
+                       .endif ;PLY_CFG_SoftOnly_Noise
+        ;Reads the volume (now b0-b3).
+        ;Note: we do NOT peform a "and %1111" because we know the bit 7 of the original byte is 0, so the bit 4 is currently 0. Else the hardware volume would be on!
+        exx
+                ;Sends the volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc l           ;Increases the volume register.
+        exx
+
+        ;Reads the software period.
+        ld a,(hl)
+        inc hl
+        exx
+                ;Sends the LSB software frequency.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc h           ;Increases the frequency register.
+        exx
+
+        ld a,(hl)
+        inc hl
+        exx
+                ;Sends the MSB software frequency.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc h           ;Increases the frequency register.
+        exx
+
+        ret
+
+
+
+
+
+;---------------------
+                       .if PLY_AKY_USE_SoftAndHard_Agglomerated      ;CONFIG SPECIFIC
+PLY_AKY_RRB_IS_SoftwareAndHardware:
+        ;Retrig?
+        rra
+                               .if PLY_CFG_UseRetrig      ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_IS_SAH_NoRetrig
+        set 7,a                         ;A value to make sure the retrig is performed, yet A can still be use.
+        ld (PLY_AKY_PsgRegister13_Retrig + PLY_AKY_Offset1b),a
+PLY_AKY_RRB_IS_SAH_NoRetrig:
+                               .endif ;PLY_CFG_UseRetrig
+
+        ;Noise?
+        rra
+                               .if PLY_AKY_USE_SoftAndHard_Noise_Agglomerated
+        jr nc,PLY_AKY_RRB_IS_SAH_NoNoise
+        ;Reads the noise.
+        ld de,#PLY_AKY_PsgRegister6
+        ldi                     ;Safe for B, C is not 0. Preserves A.
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+PLY_AKY_RRB_IS_SAH_NoNoise:
+                               .endif ;PLY_AKY_USE_SoftAndHard_Noise_Agglomerated
+
+        ;The envelope.
+        and #0b1111
+        ld (PLY_AKY_PsgRegister13),a
+
+        ;Reads the software period.
+        ld a,(hl)
+        inc hl
+        exx
+                ;Sends the LSB software frequency.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc h           ;Increases the frequency register.
+        exx
+
+        ld a,(hl)
+        inc hl
+        exx
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ;Sends the MSB software frequency.
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc h           ;Increases the frequency register.
+
+                ;Sets the hardware volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ld      a,#0x10
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),c       ;f400 + value (volume to 16).
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+                
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),e       ;#bffd + value (volume to 16).
+                ld b,e
+                
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,c
+                out (#0xa1),a     ;Value (volume to 16).
+                        
+       .endif
+                inc l           ;Increases the volume register.
+        exx
+
+        ;Copies the hardware period.
+        ld de,#PLY_AKY_PsgRegister11
+        ldi
+        ldi
+        ret
+                       .endif ;PLY_AKY_USE_SoftAndHard_Agglomerated
+
+
+
+
+
+
+
+        ;Manages the loop. This code is put here so that no jump needs to be coded when its job is done.
+PLY_AKY_RRB_NIS_NoSoftwareNoHardware_Loop:
+        ;Loops. Reads the next pointer to this RegisterBlock.
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+
+        ;Makes another iteration to read the new data.
+        ;Since we KNOW it is not an initial state (because no jump goes to an initial state), we can directly go to the right branching.
+        ;Reads the first byte.
+        ld a,(hl)
+        inc hl
+        ;jr PLY_AKY_RRB_NonInitialState
+
+;Generic code interpreting the RegisterBlock - Non initial state. See comment about the Initial state for the registers ins/outs.
+;----------------------------------------------------------------
+PLY_AKY_RRB_NonInitialState:
+        rra
+        jr c,PLY_AKY_RRB_NIS_SoftwareOnlyOrSoftwareAndHardware
+        rra
+                       .if PLY_CFG_HardOnly  ;CONFIG SPECIFIC
+        jp c,PLY_AKY_RRB_NIS_HardwareOnly
+                       .endif ;PLY_CFG_HardOnly
+
+        ;No software, no hardware, OR loop.
+
+        ld e,a
+        and #0b11         ;Bit 3:loop?/volume bit 0, bit 2: volume?
+        cp #0b10          ;If no volume, yet the volume is >0, it means loop.
+        jr z,PLY_AKY_RRB_NIS_NoSoftwareNoHardware_Loop
+
+        ;No loop: so "no software no hardware".
+                       .if PLY_CFG_NoSoftNoHard        ;CONFIG SPECIFIC
+
+        ;Closes the sound channel.
+        set PLY_AKY_RRB_SoundChannelBit, b
+
+        ;Volume? bit 2 - 2.
+        ld a,e
+        rra
+        jr nc,PLY_AKY_RRB_NIS_NoVolume
+        and #0b1111
+        exx
+                ;Sends the volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+        exx
+PLY_AKY_RRB_NIS_NoVolume:
+        ;Sadly, have to lose a bit of CPU here, as this must be done in all cases.
+        exx
+                inc l           ;Next volume register.
+                inc h           ;Next frequency registers.
+                inc h
+        exx
+
+        ;Noise? Was on bit 7, but there has been two shifts. We can't use A, it may have been modified by the volume AND.
+                       .if PLY_CFG_NoSoftNoHard_Noise        ;CONFIG SPECIFIC
+        bit 7 - 2, e
+        ret z
+        ;Noise.
+        ld a,(hl)
+        ld (PLY_AKY_PsgRegister6),a
+        inc hl
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+                       .endif ;PLY_CFG_NoSoftNoHard_Noise
+        ret
+                       .endif ;PLY_CFG_NoSoftNoHard
+
+
+
+
+
+
+PLY_AKY_RRB_NIS_SoftwareOnlyOrSoftwareAndHardware:
+        ;Another decision to make about the sound type.
+        rra
+                       .if PLY_AKY_USE_SoftAndHard_Agglomerated      ;CONFIG SPECIFIC
+        jp c,PLY_AKY_RRB_NIS_SoftwareAndHardware
+                       .endif
+
+
+;---------------------
+                       .if PLY_CFG_SoftOnly  ;CONFIG SPECIFIC
+        ;Software only. Structure: mspnoise lsp v  v  v  v  (0  1).
+        ld e,a
+        ;Gets the volume (already shifted).
+        and #0b1111
+        exx
+                ;Sends the volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc l           ;Increases the volume register.
+        exx
+
+        ;LSP? (Least Significant byte of Period). Was bit 6, but now shifted.
+        bit 6 - 2, e
+        jr z,PLY_AKY_RRB_NIS_SoftwareOnly_NoLSP
+        ld a,(hl)
+        inc hl
+        exx
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ;Sends the LSB software frequency.
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                ;H not incremented on purpose.
+        exx
+PLY_AKY_RRB_NIS_SoftwareOnly_NoLSP:
+
+        ;MSP AND/OR (Noise and/or new Noise)? (Most Significant byte of Period).
+        bit 7 - 2, e
+        jr nz,PLY_AKY_RRB_NIS_SoftwareOnly_MSPAndMaybeNoise
+        ;Bit of loss of CPU, but has to be done in all cases.
+        exx
+                inc h
+                inc h
+        exx
+        ret
+PLY_AKY_RRB_NIS_SoftwareOnly_MSPAndMaybeNoise:
+        ;MSP and noise?, in the next byte. nipppp (n = newNoise? i = isNoise? p = MSB period).
+        ld a,(hl)       ;Useless bits at the end, not a problem.
+        inc hl
+        exx
+                ;Sends the MSB software frequency.
+                inc h           ;Was not increased before.
+
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        push    af
+        call    ayRegisterWrite
+        pop     af
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                inc h           ;Increases the frequency register.
+        exx
+                               .if PLY_CFG_SoftOnly_Noise  ;CONFIG SPECIFIC
+        rla     ;Carry is isNoise?
+        ret nc
+
+        ;Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+
+        ;Is there a new noise value? If yes, gets the noise.
+        rla
+        ret nc
+        ;Gets the noise.
+        ld de,#PLY_AKY_PsgRegister6
+        ldi
+                               .endif ;PLY_CFG_SoftOnly_Noise
+        ret
+                       .endif ;PLY_CFG_SoftOnly
+
+
+;---------------------
+                       .if PLY_CFG_HardOnly  ;CONFIG SPECIFIC
+PLY_AKY_RRB_NIS_HardwareOnly:
+        ;Gets the envelope (initially on b2-b4, but currently on b0-b2). It is on 3 bits, must be encoded on 4. Bit 0 must be 0.
+        rla
+        ld e,a
+        and #0b1110
+        ld (PLY_AKY_PsgRegister13),a
+
+        ;Closes the sound channel.
+        set PLY_AKY_RRB_SoundChannelBit, b
+
+        ;Hardware volume.
+        exx
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ld      a,#0x10
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),c       ;f400 + value (16, hardware volume).
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),e       ;#bffd + value (volume to 16).
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,c
+                out (#0xa1),a     ;Value (16, hardware volume).
+       .endif
+
+                inc l           ;Increases the volume register.
+
+                inc h           ;Increases the frequency register.
+                inc h
+        exx
+
+        ld a,e
+
+        ;LSB for hardware period? Currently on b6.
+        rla
+        rla
+        jr nc,PLY_AKY_RRB_NIS_HardwareOnly_NoLSB
+        ld de,#PLY_AKY_PsgRegister11
+        ldi
+PLY_AKY_RRB_NIS_HardwareOnly_NoLSB:
+
+        ;MSB for hardware period?
+        rla
+        jr nc,PLY_AKY_RRB_NIS_HardwareOnly_NoMSB
+        ld de,#PLY_AKY_PsgRegister12
+        ldi
+PLY_AKY_RRB_NIS_HardwareOnly_NoMSB:
+
+        ;Noise or retrig?
+        rla
+        jr c,PLY_AKY_RRB_NIS_Hardware_Shared_NoiseOrRetrig_AndStop          ;The retrig/noise code is shared.
+
+        ret
+                       .endif ;PLY_CFG_HardOnly
+
+
+;---------------------
+                       .if PLY_AKY_USE_SoftAndHard_Agglomerated      ;CONFIG SPECIFIC
+PLY_AKY_RRB_NIS_SoftwareAndHardware:
+        ;Hardware volume.
+        exx
+                ;Sends the volume.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,l
+        ex      af,af'
+        ld      a,#0x10
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+        ex      af,af'
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),l       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),c       ;f400 + value (16 = hardware volume).
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),l       ;#fffd + register.
+                ld b,d
+                out (c),e       ;#bffd + value (volume to 16).
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a          ;A must be preserved.
+                ld a,l
+                out (#0xa0),a     ;Register.
+                ld a,c
+                out (#0xa1),a     ;Value (16 = hardware volume).
+                ld a,b
+       .endif
+        
+                inc l           ;Increases the volume register.
+        exx
+
+        ;LSB of hardware period?
+        rra
+        jr nc,PLY_AKY_RRB_NIS_SAHH_AfterLSBH
+        ld de,#PLY_AKY_PsgRegister11
+        ldi
+PLY_AKY_RRB_NIS_SAHH_AfterLSBH:
+        ;MSB of hardware period?
+        rra
+        jr nc,PLY_AKY_RRB_NIS_SAHH_AfterMSBH
+        ld de,#PLY_AKY_PsgRegister12
+        ldi
+PLY_AKY_RRB_NIS_SAHH_AfterMSBH:
+
+        ;LSB of software period?
+        rra
+        jr nc,PLY_AKY_RRB_NIS_SAHH_AfterLSBS
+        ld e,a
+        ld a,(hl)
+        inc hl
+        exx
+                ;Sends the LSB software frequency.
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                ;H not increased on purpose.
+        exx
+        ld a,e
+PLY_AKY_RRB_NIS_SAHH_AfterLSBS:
+
+        ;MSB of software period?
+        rra
+        jr nc,PLY_AKY_RRB_NIS_SAHH_AfterMSBS
+        ld e,a
+        ld a,(hl)
+        inc hl
+        exx
+                ;Sends the MSB software frequency.
+                inc h
+
+      .if PLY_AKY_HARDWARE_ENTERPRISE
+        ld      c,h
+        ex      de,hl
+        call    ayRegisterWrite
+        ex      de,hl
+      .endif
+       .if PLY_AKY_HARDWARE_CPC
+                ld b,d
+                out (c),h       ;f400 + register.
+                ld b,e
+                .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+                ld b,d
+                out (c),a       ;f400 + value.
+                ld b,e
+                out (c),c       ;f680
+                ex af,af'
+                out (c),a       ;f6c0.
+                ex af,af'
+       .endif
+       .if PLY_AKY_HARDWARE_SPECTRUM + PLY_AKY_HARDWARE_PENTAGON
+                out (c),h       ;#fffd + register.
+                ld b,d
+                out (c),a       ;#bffd + value.
+                ld b,e
+       .endif
+       .if PLY_AKY_HARDWARE_MSX
+                ld b,a
+                ld a,h
+                out (#0xa0),a     ;Register.
+                ld a,b
+                out (#0xa1),a     ;Value.
+       .endif
+                dec h           ;Yup. Will be compensated below.
+        exx
+        ld a,e
+PLY_AKY_RRB_NIS_SAHH_AfterMSBS:
+        ;A bit of loss of CPU, but this has to be done every time!
+        exx
+                inc h
+                inc h
+        exx
+
+        ;New hardware envelope?
+        rra
+        jr nc,PLY_AKY_RRB_NIS_SAHH_AfterEnvelope
+        ld de,#PLY_AKY_PsgRegister13
+        ldi
+PLY_AKY_RRB_NIS_SAHH_AfterEnvelope:
+
+        ;Retrig and/or noise?
+        rra
+        ret nc
+                       .endif ;PLY_AKY_USE_SoftAndHard_Agglomerated
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;This code is shared with the HardwareOnly. It reads the Noise/Retrig byte, interprets it and exits.
+        ;------------------------------------------
+PLY_AKY_RRB_NIS_Hardware_Shared_NoiseOrRetrig_AndStop:
+        ;Noise or retrig. Reads the next byte.
+        ld a,(hl)
+        inc hl
+
+        ;Retrig?
+        rra
+                       .if PLY_CFG_UseRetrig         ;CONFIG SPECIFIC
+        jr nc,PLY_AKY_RRB_NIS_S_NOR_NoRetrig
+        set 7,a                         ;A value to make sure the retrig is performed, yet A can still be use.
+        ld (PLY_AKY_PsgRegister13_Retrig + PLY_AKY_Offset1b),a
+PLY_AKY_RRB_NIS_S_NOR_NoRetrig:
+                       .endif ;PLY_CFG_UseRetrig
+
+                       .if PLY_AKY_USE_SoftAndHard_Noise_Agglomerated        ;CONFIG SPECIFIC
+        ;Noise? If no, nothing more to do.
+        rra
+        ret nc
+        ;Noise. Opens the noise channel.
+        res PLY_AKY_RRB_NoiseChannelBit, b
+        ;Is there a new noise value? If yes, gets the noise.
+        rra
+        ret nc
+        ;Sets the noise.
+        ld (PLY_AKY_PsgRegister6),a
+                       .endif ;PLY_AKY_USE_SoftAndHard_Noise_Agglomerated
+        ret
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+
+       .ifeq PLY_AKY_ROM
+;Some stored PSG registers. They MUST be consecutive.
+PLY_AKY_PsgRegister6:   .db #0x00
+               .if PLY_CFG_UseHardwareSounds
+PLY_AKY_PsgRegister11:  .db #0x00
+PLY_AKY_PsgRegister12:  .db #0x00
+PLY_AKY_PsgRegister13:  .db #0x00
+               .endif
+       .endif
+
+;RET table for the Read RegisterBlock code to know where to return.
+PLY_AKY_RetTable_ReadRegisterBlock:
+                .dw PLY_AKY_Channel1_RegisterBlock_Return
+                .dw PLY_AKY_Channel2_RegisterBlock_Return
+                .dw PLY_AKY_Channel3_RegisterBlock_Return
+
+        
+        
+;Buffer used for the ROM player. This part needs to be set to RAM.
+       .if PLY_AKY_ROM
+        ;Bytes first.
+.equ PLY_AKY_ROM_BufferSize , 0
+.equ PLY_AKY_Channel1_WaitBeforeNextRegisterBlock     , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_Channel2_WaitBeforeNextRegisterBlock     , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_Channel3_WaitBeforeNextRegisterBlock     , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+
+.equ PLY_AKY_Channel1_RegisterBlockLineState_Opcode   , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_Channel2_RegisterBlockLineState_Opcode   , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_Channel3_RegisterBlockLineState_Opcode   , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+
+;Some stored PSG registers. They MUST be consecutive (assertion don't work in this case...).
+.equ PLY_AKY_PsgRegister6                             , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+               .if PLY_CFG_UseHardwareSounds
+.equ PLY_AKY_PsgRegister11                            , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_PsgRegister12                            , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_PsgRegister13                            , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+.equ PLY_AKY_PsgRegister13_Retrig                     , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 1
+               .endif
+        ;Words.
+.equ PLY_AKY_PtLinker                                 , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_SaveSp                                   , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_PatternFrameCounter                      , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel1_PtTrack                         , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel2_PtTrack                         , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel3_PtTrack                         , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel1_PtRegisterBlock                 , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel2_PtRegisterBlock                 , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+.equ PLY_AKY_Channel3_PtRegisterBlock                 , PLY_AKY_ROM_Buffer + PLY_AKY_ROM_BufferSize   PLY_AKY_ROM_BufferSize = PLY_AKY_ROM_BufferSize + 2
+
+       .endif
+
+; =============================================================================
+ .if PLY_AKY_HARDWARE_ENTERPRISE
+  .ifeq NO_ENVELOPE_IRQ
+
+envelopeInterrupt:
+
+    .if ENABLE_1000HZ_IRQ 
+        ld    a, #0x13
+        out   (#0xb4), a
+    .endif
+        push  hl
+        push  bc
+envelopeInterrupt.l1:    ld    hl,#0x0000                 ; * envelope counter
+      .if ENABLE_1000HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #500) / #1000)
+      .else
+        .if ENABLE_300HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #150) / #300)
+        .else
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #25) / #50)
+        .endif
+      .endif
+        add   hl, bc
+envelopeInterrupt.l2:    jr    c, envelopeInterrupt.l19                   ; * JR if envelope is stopped
+envelopeInterrupt.l3:    ld    bc, #0xffff               ; * envelope frequency
+envelopeInterrupt.l4:    ld    a,#0x00                   ; * envelope state (0 to 15)
+envelopeInterrupt.l5:    dec   a                         ; * envelope direction (INC A or DEC A)
+        add   hl, bc
+        jr    nc, envelopeInterrupt.l5
+        ld    (envelopeInterrupt.l1 + 1), hl
+        cp    #0x10
+envelopeInterrupt.l6:    jr    nc, envelopeInterrupt.l21                  ; * envelope mode
+envelopeInterrupt.l7:    ld    (envelopeInterrupt.l4 + 1), a
+envelopeInterrupt.l8:    add   a,#<ayVolumeTable
+        ld    l, a
+        adc   a, #>ayVolumeTable
+        sub   l
+        ld    h,a
+        or    a
+envelopeInterrupt.l9:
+        ld    a, (hl)
+        pop   bc
+envelopeInterrupt.l10:   jr    envelopeInterrupt.l12                      ; * envelope enable mode
+envelopeInterrupt.l11:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channel A only
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l12:   pop   hl
+        ret
+envelopeInterrupt.l13:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and B
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l14:
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; envelope on channel B only (Carry=0)
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l15:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l16:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channel C only
+        pop   hl
+        ret
+envelopeInterrupt.l17:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A, B, and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l18:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channels B and C
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l19:   ld    (envelopeInterrupt.l1 + 1), hl
+        pop   bc
+        pop   hl
+        ret
+envelopeInterrupt.l20:   ld    l, #<(ayVolumeTable + 15)       ; envelope modes 11 and 13
+        .db  #0x01                      ; = LD BC, nnnn
+envelopeInterrupt.l21:   ld    l, #<ayVolumeTable      ; envelope modes 0 to 7, 9, and 15
+        ld    h, #>ayVolumeTable
+        ld    a, #0x18                  ; = JR +nn
+        ld    (envelopeInterrupt.l2), a                  ; stop envelope
+        jp    envelopeInterrupt.l9
+envelopeInterrupt.l22:   and   #0x0f                     ; envelope modes 8 and 12
+        jp    envelopeInterrupt.l7
+envelopeInterrupt.l23:   jp    m, envelopeInterrupt.l24                   ; envelope modes 10 and 14
+        xor   #0x1f
+        ld    l, a
+        ld    h,#0x3d                   ; set direction to DEC A
+        ld    (envelopeInterrupt.l4 + 1), hl             ; assume .l5 = .l4 + 2
+        jp    envelopeInterrupt.l8
+envelopeInterrupt.l24:   cpl
+        ld    l, a
+        ld    h,#0x3c                   ; set direction to INC A
+        ld    (envelopeInterrupt.l4 + 1), hl
+        jp    envelopeInterrupt.l8
+
+  .endif
+; -----------------------------------------------------------------------------
+
+ayVolumeTable:
+        .db   0,  1,  2,  3,  4,  5,  6,  9
+        .db  12, 17, 22, 28, 36, 44, 53, 63
+
+ayRegisterMaskTable:
+        .db  #0xff,#0x0f,#0xff,#0x0f,#0xff,#0x0f,#0x1f,#0xff
+        .db  #0x1f,#0x1f,#0x1f,#0xff,#0xff,#0x0f,#0xff,#0xff
+
+ayRegisters:
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+
+ayRegWriteTable:
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l7 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l5 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l9 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l10 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l11 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l15 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+
+
+    .ifeq NO_ENVELOPE_IRQ
+
+envelopeModeTable:
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+
+envelopeEnableTable:
+        .db  <(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l11 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l14 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l13 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l16 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l15 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l18 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l17 - envelopeInterrupt.l11)
+
+    .endif
+
+setChannelAmplitude:
+        cp    #0x10
+        jr    c, setChannelAmplitude.l1
+    .ifeq NO_ENVELOPE_IRQ
+        res   3, b
+        ld    a, (envelopeInterrupt.l4 + 1)
+    .else
+        xor   a
+    .endif
+setChannelAmplitude.l1:                                    ; HL = ayRegWriteTable + (8 + channel)
+        add     a,#<ayVolumeTable
+        ld      l,a
+        adc     a,#>ayVolumeTable
+        sub     l
+        ld      h,a
+    .ifne ENABLE_STEREO
+        bit     0,c                     ; Z = 0: channel B, Z = 1: channel A, C
+    .endif
+        ld    a, (hl)
+    .ifne ENABLE_STEREO 
+        jr    z, setChannelAmplitude.l2
+        or    a
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (c), a
+        set   2, c
+setChannelAmplitude.l2:    out   (c), a
+    .ifeq NO_ENVELOPE_IRQ
+setChannelAmplitude.l3:    ld      a,#0x00                   ; *
+        ld      c,a
+        or      b
+        cp      #0x08
+        jr      c,setChannelAmplitude.l4
+        xor     b
+setChannelAmplitude.l4:    cp      c
+        jr      z, setChannelAmplitude.l5                    ; envelope enable bit has not changed ?
+        ld      (setChannelAmplitude.l3+1), a
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeEnableTable
+        add     hl,bc
+        ld      a,(hl)
+        ld      (envelopeInterrupt.l10+1),a
+    .endif
+setChannelAmplitude.l5:    pop   bc
+;        pop   af
+        ret
+
+setChannelAFreq:
+        ld    c, #0xa0 + (ayDaveChnA * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters)
+    .if toneAndNoiseModeAtone
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+        and   #0x04
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeAnoise
+        bit   3, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeAtnns
+        and   #0x09
+        jr    z, setToneGenAAsNoise     ; tone + noise generator enabled ?
+        cp    #0x08
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnA * 2)), a
+        out   (#0xa1 + (ayDaveChnA * 2)), a
+        ret
+
+setChannelBFreq:
+        ld    c, #0xa0 + (ayDaveChnB * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 2)
+    .if toneAndNoiseModeBtone
+        bit   1, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x10
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeBnoise
+        bit   4, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x02
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeBtnns
+        and   #0x12
+        jr    z, setToneGenBAsNoise     ; tone + noise generator enabled ?
+        cp    #0x10
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnB * 2)), a
+        out   (#0xa1 + (ayDaveChnB * 2)), a
+        ret
+
+setChannelCFreq:
+        ld    c, #0xa0 + (ayDaveChnC * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 4)
+    .if toneAndNoiseModeCtone
+        bit   2, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x20
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeCnoise
+        bit   5, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x04
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeCtnns
+        and   #0x24
+        jr    z, setToneGenCAsNoise     ; tone + noise generator enabled ?
+        cp    #0x20
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnC * 2)), a
+        out   (#0xa1 + (ayDaveChnC * 2)), a
+        ret
+
+    .if toneAndNoiseModeAtnns
+setToneGenAAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeBtnns
+setToneGenBAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeCtnns
+setToneGenCAsNoise:
+        ld    a,#0x30
+        .db   #0xfe                      ; = CP nn
+    .endif
+
+setToneGenFrequency:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        xor   a
+    .endif
+
+setToneGenFrequency_:
+        add   hl, hl
+        dec   hl
+        bit   4, h
+        jr    nz, setToneGenFrequency_.l2                   ; overflow ?
+setToneGenFrequency_.l1:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        or    h                         ; non-zero for tone + noise
+    .endif
+        out   (c), l
+        inc   c
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        out   (c), a
+    .else
+        out   (c), h
+    .endif
+        ret
+setToneGenFrequency_.l2:    ld    l,#0x01
+        inc   h
+        jr    z, setToneGenFrequency_.l1
+        ld    hl,#0x0fff
+        jp    setToneGenFrequency_.l1
+
+    .if (toneAndNoiseModeAtnns * toneAndNoiseModeAnoise)
+setToneGenAAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeBtnns * toneAndNoiseModeBnoise)
+setToneGenBAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeCtnns * toneAndNoiseModeCnoise)
+setToneGenCAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+setNoiseGenFreq:
+        ld    h,#0x30
+
+setNoiseGenFreq_:
+        ld    a, (ayRegisters + 6)
+        add   a, a
+        add   a, a
+        jr    nz, setNoiseGenFreq_.l1
+        ld    a,#0x04
+setNoiseGenFreq_.l1:    dec   a
+        out   (c), a
+        inc   c
+        out   (c), h
+        ret
+; -----------------------------------------------------------------------------
+; reset AY-3-8912 emulation
+
+ayReset:
+;        di
+        ld    hl, #ayRegisters - 1
+        ld    bc, #0x10af
+        xor   a
+ayReset.l1:    inc   hl
+        out   (c), a
+        ld    (hl), a
+        dec   c
+        djnz  ayReset.l1
+        res   3, l                      ; register 7
+        ld    (hl), #0x3f
+    .ifeq NO_ENVELOPE_IRQ
+        ld    (envelopeInterrupt.l4 + 1), a
+        ld    a, #0x18                    ; = JR +nn
+        ld    (envelopeInterrupt.l2), a
+        ld    hl, #MIN_ENV_FREQVAL
+        ld    (envelopeInterrupt.l3 + 1), hl
+        ld    a, #<(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        ld    (envelopeInterrupt.l10 + 1), a
+        xor     a
+        ld    (setChannelAmplitude.l3 + 1), a
+    .endif
+        ld    a, #0x04
+        out   (#0xbf), a
+        ld    c, b
+        call  ayReset.l2
+        ld    l, b
+        call  ayReset.l2                       ; L = 1 kHz interrupts per video frame
+        ld    a, #25
+        cp    l
+        ld    a, #0x03
+        rla
+        rla
+        out   (#0xbf), a                 ; Z80 <= 5 MHz: 04h, > 5 MHz: 06h
+        ld    a, #0x10                    ; use 17-bit noise generator
+        out   (#0xa6), a
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, #0x33
+    .else
+        ld    a, #0x30
+    .endif
+        out   (#0xb4), a                 ; enable 1 kHz and video interrupts
+        ret
+ayReset.l2:    in    a, (#0xb4)
+        and   #0x11
+        or    c
+        rlca
+        and   #0x66
+        ld    c, a                      ; -ON--ON-
+        rlca                            ; ON--ON--
+        xor   c                         ; OXN-OXN-
+        bit   2, a
+        jr    z, ayReset.l3
+        inc   l                         ; 1 kHz interrupt
+ayReset.l3:    cp    #0xc0
+        jr    c, ayReset.l2                    ; not 50 Hz interrupt ?
+        ret
+
+;; read AY-3-8912 register A, returning the value in A
+;
+;ayRegisterRead:
+;        and   0fh
+;        or    <ayRegisters
+;        ld    l, a
+;        ld    h, >ayRegisters
+;        ld    a, (hl)
+;        or    a
+;        ret
+
+; write C to AY-3-8912 register A
+; NOTE: interrupts may be enabled on return
+ayRegisterWrite:
+        ld      b,#0x00
+        ld      hl,#ayRegisterMaskTable
+        add     hl,bc
+        inc     c
+        and     (hl)
+        push    bc
+        ld      c,#0x10
+        add     hl,bc                   ;ayRegisters
+        cp      (hl)
+        jr      z,ayRegisterWrite.l2                   ; register not changed ?
+        ld      (hl),a
+        add     hl,bc                   ;ayRegWriteTable
+        ld      a,(hl)
+        ld      (ayRegisterWrite.l1+1),a
+ayRegisterWrite.l1:    jr      ayRegisterWrite.l8                     ; *
+ayRegisterWrite.l2:    
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, l
+        xor   #<(ayRegisters + 13)
+        jr    z, ayRegisterWrite.l16                   ; envelope restart ?
+    .endif
+        pop     bc
+;        pop   af
+        ret
+ayRegisterWrite.l3:    call  setChannelAFreq           ; tone generator A frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l4:    call  setChannelBFreq           ; tone generator B frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l5:    call  setChannelAFreq           ; mixer
+        call  setChannelBFreq
+ayRegisterWrite.l6:    call  setChannelCFreq           ; tone generator C frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l7:    ld    a, (ayRegisters + 7)      ; noise generator frequency
+    .if toneAndNoiseModeAnoise
+        ld    b, a
+        and   #0x08
+    .else
+        xor   #0x07
+        ld    b, a
+        and   #0x09
+    .endif
+        call  z, setChannelAFreq
+    .if toneAndNoiseModeBnoise
+        bit   4, b
+    .else
+        ld    a, b
+        and   #0x12
+    .endif
+        call  z, setChannelBFreq
+    .if toneAndNoiseModeCnoise
+        bit   5, b
+    .else
+        ld    a, b
+        and   #0x24
+    .endif
+        call  z, setChannelCFreq
+ayRegisterWrite.l8:    pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l9:    ld    a, (ayRegisters + 8)      ; channel A amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x09a8 + ayDaveChnA
+    .else
+        ld    c,#0xa8 + ayDaveChnA
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l10:   ld    a, (ayRegisters + 9)      ; channel B amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0aa8 + ayDaveChnB
+    .else
+        ld    c,#0xa8 + ayDaveChnB
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l11:   ld    a, (ayRegisters + 10)     ; channel C amplitude / envelope enable
+    .ifeq ENABLE_STEREO
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0ca8 + ayDaveChnC
+      .else
+        ld    c,#0xa8 + ayDaveChnC
+      .endif
+    .else
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0cac + ayDaveChnC
+      .else
+        ld    c,#0xac + ayDaveChnC
+      .endif
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l12:
+    .ifeq NO_ENVELOPE_IRQ
+        ld    hl, (ayRegisters + 11)    ; envelope generator frequency
+        ld    a, h
+        or    a
+        jr    nz, ayRegisterWrite.l13
+        ld    a, #MIN_ENV_FREQVAL
+        cp    l
+        jr    c, ayRegisterWrite.l13
+        ld    l, a                      ; limit envelope frequency
+ayRegisterWrite.l13:   ld    (envelopeInterrupt.l3 + 1), hl
+        pop   bc
+;        pop   af
+        ret
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+ayRegisterWrite.l15:                                   ; envelope generator mode / restart
+    .ifeq NO_ENVELOPE_IRQ
+ayRegisterWrite.l16:   ld      hl,(envelopeInterrupt.l3+1)
+        ld      (envelopeInterrupt.l1+1),hl
+        ld      a,#0x38                     ; = JR C, +nn
+        ld      (envelopeInterrupt.l2),a    ; enable envelope
+        ld      a,(ayRegisters+13)
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeModeTable
+        add     hl,bc
+        and     #0x04
+        ld    a, (hl)
+        ld    (envelopeInterrupt.l6 + 1), a
+        ld    hl,#0x3c00                    ; INC A, state = 0
+        ld    a, l
+        jr    nz, ayRegisterWrite.l17                      ; attack ?
+        ld    hl,#0x3d0f                    ; DEC A, state = 15
+        ld    a,#0x3f
+ayRegisterWrite.l17:   ld    (envelopeInterrupt.l4 + 1), hl    ; assume eInt.l5 = eInt.l4 + 2
+        call  ayRegisterWrite.l18
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l18:   call  envelopeInterrupt.l10     ; NOTE: this will pop return address
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+
+ .endif
+; =============================================================================
+ 
+   ;PLY_UseEnterprise_End 
+ 
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAky_var.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAky_var.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerAky_var.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerAky_var.src	2025-01-11 16:57:38
@@ -0,0 +1,55 @@
+    .if HARDWARE_ENTERPRISE
+.equ PLY_AKY_HARDWARE_ENTERPRISE  , 1
+    .else
+.equ PLY_AKY_HARDWARE_ENTERPRISE  , 0
+    .endif
+    .if HARDWARE_CPC
+.equ PLY_AKY_HARDWARE_CPC         , 1
+    .else
+.equ PLY_AKY_HARDWARE_CPC         , 0
+    .endif
+
+.equ PLY_AKY_HARDWARE_MSX         , 0
+.equ PLY_AKY_HARDWARE_SPECTRUM    , 0
+.equ PLY_AKY_HARDWARE_PENTAGON    , 0
+
+.equ PLY_AKY_UseHooks            ,   1       ;Use hooks for external calls? 0 if the Init/Play methods are directly called, will save a few bytes.
+
+.equ PLY_CFG_UseHardwareSounds   ,   1
+.equ PLY_CFG_UseRetrig           ,   1
+.equ PLY_CFG_NoSoftNoHard        ,   1
+.equ PLY_CFG_NoSoftNoHard_Noise  ,   1
+.equ PLY_CFG_SoftOnly            ,   1
+.equ PLY_CFG_SoftOnly_Noise      ,   1
+.equ PLY_CFG_SoftToHard          ,   1
+.equ PLY_CFG_SoftToHard_Noise    ,   1
+.equ PLY_CFG_SoftToHard_Retrig   ,   1
+.equ PLY_CFG_HardOnly            ,   1
+.equ PLY_CFG_HardToSoft          ,   1
+.equ PLY_CFG_HardToSoft_Noise    ,   1
+.equ PLY_CFG_HardOnly_Noise      ,   1
+.equ PLY_CFG_HardOnly_Retrig     ,   1
+.equ PLY_CFG_SoftAndHard         ,   1
+.equ PLY_CFG_SoftAndHard_Noise   ,   1
+.equ PLY_CFG_SoftAndHard_Retrig  ,   1
+
+        ;Agglomerates the hardware sound configuration flags, because they are treated the same in this player.
+        ;-------------------------------------------------------
+        .IF PLY_CFG_SoftToHard + PLY_CFG_SoftAndHard + PLY_CFG_HardToSoft
+.equ PLY_AKY_USE_SoftAndHard_Agglomerated , 1
+        .else
+.equ PLY_AKY_USE_SoftAndHard_Agglomerated , 0
+        .ENDIF
+        
+        .IF PLY_CFG_SoftToHard_Noise + PLY_CFG_SoftAndHard_Noise + PLY_CFG_HardToSoft_Noise
+.equ PLY_AKY_USE_SoftAndHard_Noise_Agglomerated , 1
+        .else
+.equ PLY_AKY_USE_SoftAndHard_Noise_Agglomerated , 0
+        .ENDIF
+        
+        ;Any noise?
+        .IF PLY_AKY_USE_SoftAndHard_Noise_Agglomerated + PLY_CFG_NoSoftNoHard_Noise + PLY_CFG_SoftOnly_Noise
+.equ PLY_AKY_USE_Noise , 1
+        .else
+.equ PLY_AKY_USE_Noise , 0
+        .ENDIF
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW.s cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW.s
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW.s	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW.s	2025-01-11 16:57:38
@@ -0,0 +1,2495 @@
+;;-----------------------------LICENSE NOTICE------------------------------------
+;;  This file is part of CPCtelera: An Amstrad CPC Game Engine 
+;;  Copyright (C) 2009 Targhan / Arkos
+;;  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+;;
+;;  This program is free software: you can redistribute it and/or modify
+;;  it under the terms of the GNU Lesser General Public License as published by
+;;  the Free Software Foundation, either version 3 of the License, or
+;;  (at your option) any later version.
+;;
+;;  This program is distributed in the hope that it will be useful,
+;;  but WITHOUT ANY WArraNTY; without even the implied warranty of
+;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;  GNU Lesser General Public License for more details.
+;;
+;;  You should have received a copy of the GNU Lesser General Public License
+;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+;;-------------------------------------------------------------------------------
+.module cpct_audio
+        .include "../../CPCteleraHW.src"
+        .include "arkostrackerLW_var.src"
+
+;       Arkos Tracker 2 Lightweight player (format V1 (used by AT2 since alpha4)).
+
+;       ** This player has been superseded by the AKM format, more compact but also more powerful. Please use it instead. **
+
+;       This compiles with RASM. Check the compatibility page on the Arkos Tracker 2 website, it contains a source converter to any Z80 assembler!
+
+;   	This is a generic player, but much simpler and using only the most used features, so that the music and players are both
+;   	lightweight. The player supports sound effects.
+
+;       Though the player is optimized in speed, it is much slower than the generic one or the AKY player.
+;       With effects used at the same time, it may reach 35 scanlines on a CPC, plus some few more if you are using sound effects.
+
+;       The player uses the stack for optimizations. Make sure the interruptions are disabled before it is called.
+;       The stack pointer is saved at the beginning and restored at the end.
+
+;       Target harware:
+;       ---------------
+;       This code can target Amstrad CPC, MSX, Spectrum and Pentagon. By default, it targets Amstrad CPC.
+;       Simply use one of the follow line (BEFORE this player):
+;       PLY_LW_HARDWARE_CPC = 1
+;       PLY_LW_HARDWARE_MSX = 1
+;       PLY_LW_HARDWARE_SPECTRUM = 1
+;       PLY_LW_HARDWARE_PENTAGON = 1
+;       PLY_LW_HARDWARE_ENTERPRISE = 1
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+;
+;       Some severe optimizations of CPU/memory can be performed:
+;       ---------------------------------------------------------
+;       - Use the Player Configuration of Arkos Tracker 2 to generate a configuration file to be included at the beginning of this player.
+;         It will disable useless features according to your songs! Check the manual for more details, or more simply the testers.
+;
+;       Sound effects:
+;       --------------
+;       Sound effects are disabled by default. Declare PLY_LW_MANAGE_SOUND_EFFECTS to enable it:
+;       PLY_LW_MANAGE_SOUND_EFFECTS = 1
+;       Check the sound effect tester to see how it enables it.
+;       Note that the PRESENCE of this variable is tested, NOT its value.
+;
+;       ROM
+;       ----------------------
+;       No ROM player is available for this player. I suggest you try the AKM player, which is more powerful and more compact (albeit a bit slower).
+;
+;       -------------------------------------------------------
+
+PLY_LW_Start:
+
+.equ PLY_LW_HardwareCounter      , PLY_LW_HARDWARE_CPC + PLY_LW_HARDWARE_MSX + PLY_LW_HARDWARE_SPECTRUM + PLY_LW_HARDWARE_PENTAGON + PLY_LW_HARDWARE_ENTERPRISE
+        .ifeq PLY_LW_HardwareCounter
+.equ PLY_LW_HARDWARE_ENTERPRISE  , 1
+       .endif
+       .ifgt PLY_LW_HardwareCounter-1
+                FAIL 'Only one hardware must be selected!'
+       .endif
+
+        ;Agglomerates some flags, because they are treated the same way by this player.
+        ;--------------------------------------------------
+        ;Creates a flag for pitch in instrument, and also pitch in hardware.
+       .if PLY_CFG_SoftOnly_SoftwarePitch + PLY_CFG_SoftToHard_SoftwarePitch + PLY_CFG_SoftAndHard_SoftwarePitch
+.equ PLY_LW_PitchInInstrument , 1
+       .else
+.equ PLY_LW_PitchInInstrument , 0
+       .endif
+       .if PLY_CFG_SoftToHard_SoftwarePitch + PLY_CFG_SoftAndHard_SoftwarePitch
+.equ PLY_LW_PitchInHardwareInstrument , 1
+       .else
+.equ PLY_LW_PitchInHardwareInstrument , 0
+       .endif
+        ;A flag for Arpeggios in Instrument, both in software and hardware.
+       .if PLY_CFG_SoftOnly_SoftwareArpeggio + PLY_CFG_SoftToHard_SoftwareArpeggio + PLY_CFG_SoftAndHard_SoftwareArpeggio
+.equ PLY_LW_ArpeggioInSoftwareOrHardwareInstrument , 1
+       .else
+.equ PLY_LW_ArpeggioInSoftwareOrHardwareInstrument , 0
+       .endif
+
+       .if PLY_CFG_SoftToHard_SoftwareArpeggio + PLY_CFG_SoftAndHard_SoftwareArpeggio
+.equ PLY_LW_ArpeggioInHardwareInstrument , 1
+       .else
+.equ PLY_LW_ArpeggioInHardwareInstrument , 0
+       .endif
+
+        ;A flag if noise is used (noise in hardware not tested, not present in this format).
+       .if PLY_CFG_NoSoftNoHard_Noise + PLY_CFG_SoftOnly_Noise
+.equ PLY_LW_USE_Noise , 1
+        ;The noise is managed? Then the noise register access must be compiled.
+.equ PLY_LW_USE_NoiseRegister , 1
+       .else
+.equ PLY_LW_USE_Noise , 0
+.equ PLY_LW_USE_NoiseRegister , 0
+       .endif
+        
+        ;Mixing Pitch up/down effects.
+       .if PLY_CFG_UseEffect_PitchUp + PLY_CFG_UseEffect_PitchDown + PLY_CFG_UseEffect_SetVolume
+.equ PLY_LW_USE_EffectPitchUpDown , 1
+       .else
+.equ PLY_LW_USE_EffectPitchUpDown , 0
+       .endif
+
+        ;Volume and Pitch up/down dual effects (if one exists, the other one too).
+       .if PLY_CFG_UseEffect_SetVolume + PLY_LW_USE_EffectPitchUpDown
+.equ PLY_LW_USE_Volume_And_PitchUpDown_Effects , 1
+       .else
+.equ PLY_LW_USE_Volume_And_PitchUpDown_Effects , 0
+       .endif
+
+      .ifeq PLY_CFG_UseEffect_SetVolume
+       .if PLY_LW_USE_EffectPitchUpDown
+                FAIL " plase set: PLY_CFG_UseEffect_SetVolume = 1"
+       .endif
+      .endif
+        ;Volume and Arpeggio Table dual effect (if one exists, the other one too).
+       .if PLY_CFG_UseEffect_SetVolume + PLY_CFG_UseEffect_ArpeggioTable
+.equ PLY_LW_USE_Volume_And_ArpeggioTable_Effects , 1
+           .ifeq PLY_CFG_UseEffect_ArpeggioTable
+                FAIL " plase set: PLY_CFG_UseEffect_ArpeggioTable = 1"
+           .endif
+           .ifeq PLY_CFG_UseEffect_SetVolume
+                FAIL " please set: PLY_CFG_UseEffect_SetVolume = 1"
+           .endif
+       .else
+.equ PLY_LW_USE_Volume_And_ArpeggioTable_Effects , 0
+       .endif
+
+        ;Reset and Arpeggio Table dual effect (if one exists, the other one too).
+       .if PLY_CFG_UseEffect_Reset + PLY_CFG_UseEffect_ArpeggioTable
+.equ PLY_LW_USE_Reset_And_ArpeggioTable_Effects , 1
+           .ifeq PLY_CFG_UseEffect_ArpeggioTable
+                FAIL " plase set: PLY_CFG_UseEffect_ArpeggioTable = 1"
+           .endif
+           .ifeq PLY_CFG_UseEffect_Reset
+                FAIL " plase set: PLY_CFG_UseEffect_Reset = 1"
+           .endif
+       .else
+.equ PLY_LW_USE_Reset_And_ArpeggioTable_Effects , 0
+       .endif
+        
+        ;Hooks for external calls. Can be removed if not needed.
+       .if PLY_LW_USE_HOOKS
+;		assert PLY_LW_Start == $		;Makes sure no extra byte were inserted before the hooks.
+                jp PLY_LW_Init          ;Player + 0.
+                jp PLY_LW_Play          ;Player + 3.
+               .if PLY_LW_STOP_SOUNDS
+                jp PLY_LW_Stop          ;Player + 6.
+               .endif
+       .endif
+        
+        ;Includes the sound effects player, if wanted. Important to do it as soon as possible, so that
+        ;its code can react to the Player Configuration and possibly alter it.
+       .if PLY_LW_MANAGE_SOUND_EFFECTS
+		.include "arkostrackerLW_SoundEffects.src"
+       .endif
+        ;[[INSERT_SOUND_EFFECT_SOURCE]]                 ;A tag for test units. Don't touch or you're dead.
+
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpLW_musicInit
+;;
+;;    Sets up a music into Arkos Tracker Player to be played later on with
+;; <cpct_akpLW_musicPlay>.
+;;
+;; C Definition:
+;;    void <cpct_akpLW_musicInit> (void* *songdata*, song number)
+;;
+;; Input Parameters (2 bytes):
+;;    (2B HL) songdata - Pointer to the start of the array containing song's data in AKS binary format
+;;    (1B A) song number
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpLW_musicInit_asm
+;;
+;; Parameter Restrictions:
+;;    * *songdata* must be an array containing dong's data in AKS binary format.
+;; Take into account that AKS binary format enforces a concrete start location in
+;; memory. Therefore, song must have been created in Arkos Tracker and exported 
+;; to the same memory location that *songdata* points to. If you fail to 
+;; locate the song at the same memory location it was exported for in Arkos 
+;; Tracker, unexpected results will happen (Typically, noise will be played but,
+;; occasionally your program may hang or crash).
+;;
+;; Known limitations:
+;;    * *songdata* must be the same memory address that the one given to Arkos
+;; Tracker when exporting song's binary. Arkos Tracker songs are created to
+;; be at a concrete memory location, due to optimization constraints. Therefore,
+;; this must be taken into account. If you wanted to change the memory location
+;; of the song, you should first open the song into Arkos Tracker and export
+;; it again with the new desired memory location.
+;;    * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function should be called fist to initialize the song that is to be 
+;; played. The function reads the song header and sets up the player to start 
+;; playing it. Once this process is done, <cpct_akp_musicPlay> should be called
+;; at the required frequency to continuously play the song.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    ? bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpLW_musicInit::
+   ld   hl, #2    ;; [10] Retrieve parameters from stack
+   add  hl, sp    ;; [11]
+   ld    e, (hl)  ;; [ 7] DE = Pointer to the start of music
+   inc  hl        ;; [ 6]
+   ld    d, (hl)  ;; [ 7]
+   inc  hl
+   ld    c, (hl)
+   ex   de,hl
+cpct_akpLW_musicInit_asm::   ;; Entry point for assembly calls using registers for parameter passing
+   ;; First, set song loop times to 0 when we start
+   xor   a                          ;; A = 0
+   ld (_cpct_akpLW_songLoopTimes), a  ;; _cpct_akpLW_songLoopTimes = 0
+   ld    a,c
+
+;Initializes the song. MUST be called before actually playing the song.
+;IN:    HL = Address of the song.
+;       A = Index of the subsong to play (>=0).
+PLY_LW_InitDisarkGenerateExternalLabel:
+PLY_LW_Init:
+        ;Reads the Song data.
+        ;Skips the tag and format number.
+;dknr3:  
+        ld de,#0x05
+        add hl,de
+
+        ;Reads the pointers to the various index tables.
+        ld de,#PLY_LW_PtInstruments + 1
+        ldi
+        ldi
+                       .if PLY_CFG_UseEffects                           ;CONFIG SPECIFIC
+                               .if PLY_CFG_UseEffect_ArpeggioTable      ;CONFIG SPECIFIC
+        ld de,#PLY_LW_PtArpeggios + 1
+        ldi
+        ldi
+                               .else
+                                inc hl
+                                inc hl
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                               .if PLY_CFG_UseEffect_PitchTable         ;CONFIG SPECIFIC
+        ld de,#PLY_LW_PtPitches + 1
+        ldi
+        ldi
+                               .else
+                                inc hl
+                                inc hl
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+                       .else
+;dknr3:  
+        ld de,#0x0004
+        add hl,de
+                       .endif ;PLY_CFG_UseEffects
+
+        ;Finds the address of the Subsong.
+        ;HL points on the table, adds A * 2.
+        ;Possible optimization: possible to set the Subsong directly.
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        add hl,de
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        
+        ;Reads the header of the Subsong.
+        ld a,(de)       ;Gets the speed.
+        inc de
+        ld (PLY_LW_Linker + 1),de
+        ld (PLY_LW_Speed + 1),a
+        ;Forces a new line.
+        dec a
+        ld (PLY_LW_TickCounter + 1),a
+
+        ;Can be removed if there is no need to reset the song.
+        xor a
+        ld (PLY_LW_PatternRemainingHeight + 1),a
+
+        ;A big LDIR to erase all the data blocks. Optimization: can be removed if there is no need to reset the song.
+        ld hl,#PLY_LW_Track1_Data
+        ld de,#PLY_LW_Track1_Data + 1
+;dknr3:  
+        ld bc,#PLY_LW_Track3_Data_End - PLY_LW_Track3_Data - 1
+        ld (hl),#0x00
+        ldir
+
+        ;Reads the first instrument, the empty one, and set-ups the pointers to the instrument to read.
+        ;Optimization: needed if the song doesn't start with an instrument on all the channels. Else, it can be removed.
+        ld hl,(PLY_LW_PtInstruments + 1)
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        inc de          ;Skips the header.
+        ld (PLY_LW_Track1_PtInstrument),de
+        ld (PLY_LW_Track2_PtInstrument),de
+        ld (PLY_LW_Track3_PtInstrument),de
+   .if HARDWARE_ENTERPRISE
+        jp     ayReset
+   .else
+        ret
+   .endif
+
+
+;Cuts the channels, stopping all sounds.
+       .if PLY_LW_STOP_SOUNDS
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpLW_stop
+;;
+;;    Stops playing musing and sound effects on all 3 channels.
+;;
+;; C Definition:
+;;    void <cpct_akpLW_stop> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpLW_stop_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function stops the music and sound effects playing in the 3 channels. 
+;; It can be later continued again calling <cpct_akp_musicPlay>. Please, take
+;; into account that sound effects cannot be played while music is stopped, as
+;; code for sound effects and music play is integrated.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;Stop the music, cut the channels.
+_cpct_akpLW_stop::
+cpct_akpLW_stop_asm::  ;; Entry point for assembly calls 
+
+PLY_LW_StopDisarkGenerateExternalLabel:
+PLY_LW_Stop:
+       .ifeq PLY_LW_HARDWARE_ENTERPRISE
+        ld (PLY_LW_SaveSP + 1),sp
+       .endif
+
+        xor a
+        ld (PLY_LW_Track1_Volume),a
+        ld (PLY_LW_Track2_Volume),a
+        ld (PLY_LW_Track3_Volume),a
+       .if PLY_LW_HARDWARE_MSX
+                ld a,#0b10111111          ;Bit 7/6 must be 10 on MSX!
+       .else
+                ld a,#0b00111111          ;On CPC, bit 6 must be 0! Other platforms don't care.
+       .endif
+        ld (PLY_LW_MixerRegister),a
+        jp PLY_LW_SendPsg
+       .endif ;PLY_LW_STOP_SOUNDS
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;
+;; Function: cpct_akpLW_musicPlay
+;;
+;;    Plays next music cycle of the present song with Arkos Tracker Player. Song 
+;; has had to be previously established with <cpct_akp_musicInit>.
+;;
+;; C Definition:
+;;    void <cpct_akpLW_musicPlay> ()
+;;
+;; Assembly call (Input parameters on registers):
+;;    > call cpct_akpLW_musicPlay_asm
+;;
+;; Known limitations:
+;;  * This function *will not work from ROM*, as it uses self-modifying code.
+;;
+;; Details:
+;;    This function is to be called to start and continue playing the presently 
+;; selected song with Arkos Tracker Player. Depending on the frequency at which 
+;; the song were created, this function should be called 12, 25, 50, 100, 200 
+;; or 300 times per second. 
+;;
+;;    Each time you call the function, it plays 1/frequency seconds. This means
+;; that you have to manually synchronize your calls to this function to have
+;; a stable music playing. If you call too fast or too slow you will either 
+;; interrupt sound or have sound valleys. Therefore, you are responsible for
+;; calling this function with the most accurate timing possible, to get best 
+;; sound results.
+;;
+;; Destroyed Register values: 
+;;    AF, AF', BC, DE, HL, IX, IY
+;;
+;; Required memory:
+;;    xxxx bytes 
+;;
+;;    However, take into account that all of Arkos Tracker Player's
+;; functions are linked and included, because they depend on each other. Total
+;; memory requirement is around xxx bytes.
+;;
+;; Time Measures:
+;; (start code)
+;;    To be done
+;; (end code)
+;;
+;; Credits:
+;;    This is a modification of the original <Arkos Tracker Player at
+;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+;; contributed to this source.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+_cpct_akpLW_musicPlay::
+cpct_akpLW_musicPlay_asm::   ;; Entry point for assembly calls 
+  .if HARDWARE_ENTERPRISE
+   .ifeq NO_ENVELOPE_IRQ
+    .if ENABLE_1000HZ_IRQ
+        in      a,(#0xb4)
+        and     #0x02
+        jp      nz,envelopeInterrupt
+        ld      a,#0x31
+        out     (#0xb4),a
+    .else
+     .if ENABLE_300HZ_IRQ
+cntr    ld      a,#0x06
+        dec     a
+        ld      (cntr+1),a
+        jp      nz,envelopeInterrupt
+        ld      a,#0x06
+        ld      (cntr+1),a
+     .else
+        call    envelopeInterrupt
+     .endif
+    .endif
+   .endif
+  .endif
+
+;Plays one frame of the song. It MUST have been initialized before.
+;The stack is saved and restored, but is diverted, so watch out for the interruptions.
+PLY_LW_PlayDisarkGenerateExternalLabel:
+PLY_LW_Play:
+       .ifeq PLY_LW_HARDWARE_ENTERPRISE
+        ld (PLY_LW_SaveSP + 1),sp
+       .endif
+
+        ;Reads a new line?
+PLY_LW_TickCounter: ld a,#0x00
+        inc a
+PLY_LW_Speed: cp #0x01                       ;Speed (>0).
+        jp nz,PLY_LW_TickCounterManaged
+
+        ;A new line must be read. But have we reached the end of the Pattern?
+PLY_LW_PatternRemainingHeight: ld a,#0x00              ;Height. If 0, end of the pattern.
+        sub #0x01
+        jr c,PLY_LW_Linker
+        ;Pattern not ended. No need to read the Linker.
+        ld (PLY_LW_PatternRemainingHeight + 1),a
+        jr PLY_LW_ReadLine
+
+        ;New pattern. Reads the Linker.
+;dknr3:
+PLY_LW_Linker: ld hl,#0x0000
+PLY_LW_LinkerPostPt:
+        ;Resets the possible empty cell counter of each Track.
+        xor a
+        ld (PLY_LW_Track1_WaitEmptyCell),a
+        ld (PLY_LW_Track2_WaitEmptyCell),a
+        ld (PLY_LW_Track3_WaitEmptyCell),a
+
+        ;Reads the state byte of the pattern.
+        ld a,(hl)
+        inc hl
+        rra
+        jr c,PLY_LW_LinkerNotEndOfSongOk
+   ;; Increment song loop times
+   ld    a, (_cpct_akpLW_songLoopTimes)
+   inc   a
+   ld (_cpct_akpLW_songLoopTimes), a
+
+        ;End of song.
+        ld a,(hl)               ;Reads where to loop in the Linker.
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jr PLY_LW_LinkerPostPt
+
+;; Loop times
+;;    Read here to know the number of times a song has looped
+_cpct_akpLW_songLoopTimes:: .db 0
+
+PLY_LW_LinkerNotEndOfSongOk:
+        rra
+        ld b,a
+                       .if PLY_CFG_UseSpeedTracks            ;CONFIG SPECIFIC        
+        ;New speed?
+        jr nc,PLY_LW_LinkerAfterSpeed
+        ld a,(hl)
+        inc hl
+        ld (PLY_LW_Speed + 1),a
+PLY_LW_LinkerAfterSpeed:
+                       .endif ;PLY_CFG_UseSpeedTracks
+
+        ;New height?
+        rr b
+        jr nc,PLY_LW_LinkerUsePreviousHeight
+        ld a,(hl)
+        inc hl
+        ld (PLY_LW_LinkerPreviousRemainingHeight + 1),a
+        jr PLY_LW_LinkerSetRemainingHeight
+        ;The same height is used. It was stored before.
+PLY_LW_LinkerUsePreviousHeight:
+PLY_LW_LinkerPreviousRemainingHeight: ld a,#0x00
+PLY_LW_LinkerSetRemainingHeight:
+        ld (PLY_LW_PatternRemainingHeight + 1),a
+
+        ;New transpositions?
+        rr b
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        jr nc,PLY_LW_LinkerAfterNewTranspositions
+        ;New transpositions.
+        ld de,#PLY_LW_Track1_Transposition
+        ldi
+        ld de,#PLY_LW_Track2_Transposition
+        ldi
+        ld de,#PLY_LW_Track3_Transposition
+        ldi
+PLY_LW_LinkerAfterNewTranspositions:
+                       .endif ;PLY_CFG_UseTranspositions
+
+        ;Reads the 3 track pointers.
+        ld de,#PLY_LW_Track1_PtTrack
+        ldi
+        ldi
+        ld de,#PLY_LW_Track2_PtTrack
+        ldi
+        ldi
+        ld de,#PLY_LW_Track3_PtTrack
+        ldi
+        ldi
+        ld (PLY_LW_Linker + 1),hl
+
+;Reads the Tracks.
+;---------------------------------
+PLY_LW_ReadLine:
+;dknr3:
+PLY_LW_PtInstruments:   ld de,#0x0000
+        exx
+        ld ix,#PLY_LW_Track1_Data
+        call PLY_LW_ReadTrack
+        ld ix,#PLY_LW_Track2_Data
+        call PLY_LW_ReadTrack
+        ld ix,#PLY_LW_Track3_Data
+        call PLY_LW_ReadTrack
+
+        xor a
+PLY_LW_TickCounterManaged:
+        ld (PLY_LW_TickCounter + 1),a
+
+
+
+;Plays the sound stream.
+;---------------------------------
+                ld de,#PLY_LW_PeriodTable
+        exx
+
+        ld c,#0b11100000          ;Register 7, shifted of 2 to the left. Bits 2 and 5 will be possibly changed by each iteration.
+
+        ld ix,#PLY_LW_Track1_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_LW_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_LW_Track1_Registers
+        call PLY_LW_PlaySoundStream
+
+        srl c                   ;Not RR, because we have to make sure the b6 is 0, else no more keyboard (on CPC)!
+                                ;Also, on MSX? bit 6 must be 0.
+        ld ix,#PLY_LW_Track2_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_LW_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_LW_Track2_Registers
+        call PLY_LW_PlaySoundStream
+
+       .if PLY_LW_HARDWARE_MSX
+                scf             ;On MSX, bit 7 must be 1.
+                rr c
+       .else
+                rr c            ;On other platforms, we don't care about b7.
+       .endif
+        ld ix,#PLY_LW_Track3_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        call PLY_LW_ManageEffects
+                       .endif ;PLY_CFG_UseEffects
+        ld iy,#PLY_LW_Track3_Registers
+        call PLY_LW_PlaySoundStream
+
+        ld a,c
+
+;Plays the sound effects, if desired.
+;-------------------------------------------
+       .if PLY_LW_MANAGE_SOUND_EFFECTS
+                        call PLY_LW_PlaySoundEffectsStream
+       .else
+                        ld (PLY_LW_MixerRegister),a
+       .endif ;PLY_LW_MANAGE_SOUND_EFFECTS
+
+
+
+;Sends the values to the PSG.
+;---------------------------------
+PLY_LW_SendPsg:
+      .IF PLY_LW_HARDWARE_ENTERPRISE
+        ld      de,#PLY_LW_Registers_RetTable
+        call    ayRegisterWriteDE   ;reg 8
+        call    ayRegisterWriteDE   ;reg 0
+        call    ayRegisterWriteDE   ;reg 1
+        call    ayRegisterWriteDE   ;reg 9
+        call    ayRegisterWriteDE   ;reg 2
+        call    ayRegisterWriteDE   ;reg 3
+        call    ayRegisterWriteDE   ;reg 10
+        call    ayRegisterWriteDE   ;reg 4
+        call    ayRegisterWriteDE   ;reg 5
+       .if PLY_LW_USE_NoiseRegister + PLY_LW_USE_NoiseRegisterS         ;CONFIG SPECIFIC
+        call    ayRegisterWriteDE   ;reg 6
+       .endif
+       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        call    ayRegisterWriteDE   ;reg 7
+        call    ayRegisterWriteDE   ;reg 11
+        call    ayRegisterWriteDE   ;reg 12
+PLY_LW_SendPsgRegisterR13:
+PLY_LW_SetReg13: 
+        ld      a,#0x00
+PLY_LW_SetReg13Old: 
+        cp      #0x00
+        ret     z
+        ;Different. R13 must be played. Updates the old R13 value.
+        ld      (PLY_LW_SetReg13Old + 1),a
+        ld      c,#0x0d
+        jp      ayRegisterWrite     ;reg 13
+       .else
+        jp      ayRegisterWriteDE   ;reg 7
+       .endif
+PLY_LW_SendPsgRegister:
+PLY_LW_SendPsgRegisterAfterPop:
+PLY_LW_SendPsgRegisterEnd:
+      .else
+
+        ld sp,#PLY_LW_Registers_RetTable
+
+       .if PLY_LW_HARDWARE_CPC
+;dknr3:  
+        ld bc,#0xf680
+        ld a,#0xc0
+;dknr3:  
+        ld de,#0xf4f6
+        out (c),a	;#f6c0          ;Madram's trick requires to start with this. out (c),b works, but will activate K7's relay! Not clean.
+       .endif
+
+       .if PLY_LW_HARDWARE_SPECTRUM
+;dknr3:  
+        ld de,#0xbfff
+;dknr3:  
+        ld bc,#0xfffd
+       .endif
+
+       .if PLY_LW_HARDWARE_PENTAGON
+;dknr3:  
+        ld de,#0xbfff
+;dknr3:  
+        ld bc,#0xfffd
+       .endif
+
+PLY_LW_SendPsgRegister:
+        pop hl          ;H = value, L = register.
+PLY_LW_SendPsgRegisterAfterPop:
+
+       .if PLY_LW_HARDWARE_CPC
+        ld b,d
+        out (c),l       ;#f400 + register.
+        ld b,e
+    .db #0xed,#0x71     ;out (c),#0x00   ;#f600
+        ld b,d
+        out (c),h       ;#f400 + value.
+        ld b,e
+        out (c),c       ;#f680
+        out (c),a       ;#f6c0
+       .endif
+
+       .if PLY_LW_HARDWARE_SPECTRUM + PLY_LW_HARDWARE_PENTAGON
+        out (c),l       ;#fffd + register.
+        ld b,d
+        out (c),h       ;#bffd + value
+        ld b,e
+       .endif
+
+       .if PLY_LW_HARDWARE_MSX
+        ld a,l          ;Register.
+        out (#0xa0),a
+        ld a,h          ;Value.
+        out (#0xa1),a
+       .endif
+
+        ret
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+PLY_LW_SendPsgRegisterR13:
+
+        ;Should the R13 be played? Yes only if different. No "force retrig" is managed by this player.
+PLY_LW_SetReg13: ld a,#0x00
+PLY_LW_SetReg13Old: cp #0x00
+        jr z,PLY_LW_SendPsgRegisterEnd
+        ;Different. R13 must be played. Updates the old R13 value.
+        ld (PLY_LW_SetReg13Old + 1),a
+
+        ld h,a
+        ld l,#0x0d
+       .if PLY_LW_HARDWARE_CPC
+                ld a,#0xc0
+       .endif
+        ret                     ;Sends the 13th registers.
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+PLY_LW_SendPsgRegisterEnd:
+
+;dknr3:
+PLY_LW_SaveSP: ld sp,#0x0000
+        ret
+       .endif
+
+
+
+
+
+
+
+
+
+;Reads a Track.
+;IN:    IX = Data block of the Track.
+;       DE'= Instrument table. Do not modify!
+PLY_LW_ReadTrack:
+        ;Are there any empty lines to wait?
+        ld a, PLY_LW_Data_OffsetWaitEmptyCell (ix)
+        sub #0x01
+        jr c,PLY_LW_RT_NoEmptyCell
+        ;Wait!
+        ld PLY_LW_Data_OffsetWaitEmptyCell (ix) ,a
+        ret
+
+PLY_LW_RT_NoEmptyCell:
+        ;Reads the Track pointer.
+        ld l, PLY_LW_Data_OffsetPtTrack + 0 (ix)
+        ld h, PLY_LW_Data_OffsetPtTrack + 1 (ix)
+        ld a,(hl)
+        inc hl
+        ld b,a
+        and #0b111111     ;Keeps only the note.
+        sub #0x3c
+        jr c,PLY_LW_RT_NoteMaybeEffect
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        jr z,PLY_LW_RT_ReadEffect       ;No note, but effect.
+                       .endif ;PLY_CFG_UseEffects
+        dec a
+        jr z,PLY_LW_RT_WaitLong
+        dec a
+        jr z,PLY_LW_RT_WaitShort
+        ;63: Escape code for a note, because octave <2 or >5.
+        ;Reads the note.
+        ld a,(hl)
+        inc hl
+        ;The rest is exactly as the "note maybe effect", as B contains the flag to know about the possible
+        ;New Instrument and/or Effect?.
+        jr PLY_LW_RT_NMB_AfterOctaveCompensation
+
+PLY_LW_RT_NoteMaybeEffect:
+        ;A is the note from octave 2, and 60 to compensate the sub above.
+        ;Then adds the transposition.
+        add a,#0x0c * #0x02 + #0x3c
+PLY_LW_RT_NMB_AfterOctaveCompensation:
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        add a,PLY_LW_Data_OffsetTransposition (ix)
+                       .endif ;PLY_CFG_UseTranspositions
+        ld PLY_LW_Data_OffsetBaseNote (ix),a
+
+        ;New Instrument?
+        rl b
+        jr c,PLY_LW_RT_NME_NewInstrument
+        ;Same Instrument. Retrieves the address previously stored.
+        ld a,PLY_LW_Data_OffsetPtBaseInstrument + 0 (ix)
+        ld PLY_LW_Data_OffsetPtInstrument + 0 (ix),a
+        ld a,PLY_LW_Data_OffsetPtBaseInstrument + 1 (ix)
+        ld PLY_LW_Data_OffsetPtInstrument + 1 (ix),a
+        jr PLY_LW_RT_NME_AfterInstrument
+
+PLY_LW_RT_NME_NewInstrument:
+        ;New Instrument, reads it.
+        ld a,(hl)
+        inc hl
+        exx
+                ;Gets the address of the Instrument.
+                ld l,a  ;No need to *2, it is already encoded like that.
+                ld h,#0x00
+                add hl,de       ;Adds to the Instrument Table.
+                ld c,(hl)
+                inc hl
+                ld b,(hl)
+                ;Reads the header of the Instrument.
+                ld a,(bc)       ;Speed.
+                ld PLY_LW_Data_OffsetInstrumentSpeed (ix),a
+                inc bc
+                ;Stores the pointer on the data of the Instrument.
+                ld PLY_LW_Data_OffsetPtInstrument + 0 (ix),c
+                ld PLY_LW_Data_OffsetPtInstrument + 1 (ix),b
+                ld PLY_LW_Data_OffsetPtBaseInstrument + 0 (ix),c              ;Useful to store the base Instrument address to retrieve it when
+                ld PLY_LW_Data_OffsetPtBaseInstrument + 1 (ix),b              ;there is a new instrument, without providing its number (optimization).
+        exx
+PLY_LW_RT_NME_AfterInstrument:
+        ;Resets the step on the Instrument.
+        ld PLY_LW_Data_OffsetInstrumentCurrentStep (ix),#0x00
+
+        ;Resets the Track pitch.
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        xor a
+                                       .if PLY_LW_USE_EffectPitchUpDown              ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetIsPitchUpDownUsed (ix),a
+        ld PLY_LW_Data_OffsetTrackPitchInteger + 0 (ix),a
+        ld PLY_LW_Data_OffsetTrackPitchInteger + 1 (ix),a
+                                       .endif ;PLY_LW_USE_EffectPitchUpDown
+        ;ld PLY_LW_Data_OffsetTrackPitchDecimal (ix),a                ;Shouldn't be needed, the difference shouldn't be noticeable.
+        ;Resets the offset on Arpeggio and Pitch tables.
+                                       .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetPtArpeggioOffset (ix),a
+                                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetPtPitchOffset (ix),a
+                                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+                       .endif ;PLY_CFG_UseEffects
+
+        ;Any effect? If no, stop.
+        rl b
+        jr nc,PLY_LW_RT_CellRead
+        ;Effect present.
+        ;jr PLY_LW_RT_ReadEffect
+
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+PLY_LW_RT_ReadEffect:
+        ;Reads effect number and possible data.
+        ld a,(hl)
+        inc hl
+        ld b,a
+        exx
+                rra
+                rra
+                rra
+                rra
+                and #0b1110
+                ld iy,#PLY_LW_EffectTable
+                ld c,a
+                ld b,#0x00
+                add iy,bc
+        exx
+        jp (iy)
+                       .endif ;PLY_CFG_UseEffects
+
+PLY_LW_RT_WaitLong:
+        ;A 8-bit byte is encoded just after.
+        ld a,(hl)
+        inc hl
+        ld PLY_LW_Data_OffsetWaitEmptyCell (ix),a
+        jr PLY_LW_RT_CellRead
+PLY_LW_RT_WaitShort:
+        ;Only a 2-bit value is encoded.
+        ld a,b
+        rla                     ;Transfers the bit 7/6 to 1/0.
+        rla
+        rla
+        and #0b11
+        ;inc a
+        ld PLY_LW_Data_OffsetWaitEmptyCell (ix),a
+        ;jr PLY_LW_RT_CellRead
+;Jumped to after the Cell has been read.
+;IN:    HL = new value of the Track pointer. Must point after the read Cell.
+PLY_LW_RT_CellRead:
+        ld PLY_LW_Data_OffsetPtTrack + 0 (ix),l
+        ld PLY_LW_Data_OffsetPtTrack + 1 (ix),h
+        ret
+
+
+;Manages the effects, if any. For the activated effects, modifies the internal data for the Track which data block is given.
+;IN:    IX = data block of the Track.
+;OUT:   IX, IY = unmodified.
+;       C must NOT be modified!
+;       DE' must NOT be modified!
+                       .if PLY_CFG_UseEffects                ;CONFIG SPECIFIC
+PLY_LW_ManageEffects:
+                       .if PLY_LW_USE_EffectPitchUpDown      ;CONFIG SPECIFIC
+        ;Pitch up/down used?
+        ld a,PLY_LW_Data_OffsetIsPitchUpDownUsed (ix)
+        or a
+        jr z,PLY_LW_ME_PitchUpDownFinished
+
+        ;Adds the LSB of integer part and decimal part, using one 16 bits operation.
+        ld l,PLY_LW_Data_OffsetTrackPitchDecimal (ix)
+        ld h,PLY_LW_Data_OffsetTrackPitchInteger + 0 (ix)
+
+        ld e,PLY_LW_Data_OffsetTrackPitchSpeed + 0 (ix)
+        ld d,PLY_LW_Data_OffsetTrackPitchSpeed + 1 (ix)
+
+        ld a,PLY_LW_Data_OffsetTrackPitchInteger + 1 (ix)
+
+        ;Negative pitch?
+        bit 7,d
+        jr nz,PLY_LW_ME_PitchUpDown_NegativeSpeed
+
+PLY_LW_ME_PitchUpDown_PositiveSpeed:
+        ;Positive speed. Adds it to the LSB of the integer part, and decimal part.
+        add hl,de
+
+        ;Carry? Transmits it to the MSB of the integer part.
+        adc #0x00
+        jr PLY_LW_ME_PitchUpDown_Save
+PLY_LW_ME_PitchUpDown_NegativeSpeed:
+        ;Negative speed. Resets the sign bit. The encoded pitch IS positive.
+        ;Subtracts it to the LSB of the integer part, and decimal part.
+        res 7,d
+
+        or a
+        sbc hl,de
+
+        ;Carry? Transmits it to the MSB of the integer part.
+        sbc #0x00
+
+PLY_LW_ME_PitchUpDown_Save:
+        ld PLY_LW_Data_OffsetTrackPitchInteger + 1 (ix),a
+
+        ld PLY_LW_Data_OffsetTrackPitchDecimal (ix),l
+        ld PLY_LW_Data_OffsetTrackPitchInteger + 0 (ix),h
+
+PLY_LW_ME_PitchUpDownFinished:
+                       .endif   ;PLY_LW_USE_EffectPitchUpDown
+
+
+        ;Manages the Arpeggio Table effect, if any.
+                       .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+        ld a,PLY_LW_Data_OffsetIsArpeggioTableUsed (ix)
+        or a
+        jr z,PLY_LW_ME_ArpeggioTableFinished
+        ;Reads the Arpeggio Table. Adds the Arpeggio base address to an offset.
+        ld e,PLY_LW_Data_OffsetPtArpeggioTable + 0 (ix)
+        ld d,PLY_LW_Data_OffsetPtArpeggioTable + 1 (ix)
+        ld l,PLY_LW_Data_OffsetPtArpeggioOffset (ix)
+PLY_LW_ME_ArpeggioTableReadAgain: ld h,#0x00
+        add hl,de
+        ld a,(hl)
+        ;End of the Arpeggio?
+        sra a
+        jr nc,PLY_LW_ME_ArpeggioTableEndNotReached
+        ;End of the Arpeggio. The loop offset is now in A.
+        ld l,a  ;And read the next value!
+        ld PLY_LW_Data_OffsetPtArpeggioOffset (ix),a
+        jr PLY_LW_ME_ArpeggioTableReadAgain
+
+PLY_LW_ME_ArpeggioTableEndNotReached:
+        ;Not the end. A = arpeggio note.
+        ld PLY_LW_Data_OffsetCurrentArpeggioValue (ix),a
+        ;Increases the offset for next time.
+        inc PLY_LW_Data_OffsetPtArpeggioOffset (ix)
+PLY_LW_ME_ArpeggioTableFinished:
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+
+        ;Manages the Pitch Table effect, if any.
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld a,PLY_LW_Data_OffsetIsPitchTableUsed (ix)
+        or a
+        ret z
+        ;Reads the Pitch Table. Adds the Pitch base address to an offset.
+        ld e,PLY_LW_Data_OffsetPtPitchTable + 0 (ix)
+        ld d,PLY_LW_Data_OffsetPtPitchTable + 1 (ix)
+        ld l,PLY_LW_Data_OffsetPtPitchOffset (ix)
+PLY_LW_ME_PitchTableReadAgain: ld h,#0x00
+        add hl,de
+        ld a,(hl)
+        ;End of the Pitch?
+        sra a
+        jr nc,PLY_LW_ME_PitchTableEndNotReached
+        ;End of the Pitch. The loop offset is now in A.
+        ld l,a  ;And read the next value!
+        ld PLY_LW_Data_OffsetPtPitchOffset (ix),a
+        jr PLY_LW_ME_PitchTableReadAgain
+
+PLY_LW_ME_PitchTableEndNotReached:
+        ;Not the end. A = pitch note. It is converted to 16 bits.
+        ld h,#0x00
+        or a
+        jp p,PLY_LW_ME_PitchTableEndNotReached_Positive
+        dec h
+PLY_LW_ME_PitchTableEndNotReached_Positive:
+        ld PLY_LW_Data_OffsetCurrentPitchTableValue + 0 (ix),a
+        ld PLY_LW_Data_OffsetCurrentPitchTableValue + 1 (ix),h
+        ;Increases the offset for next time.
+        inc PLY_LW_Data_OffsetPtPitchOffset (ix)
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+        ret
+
+                       .endif ;PLY_CFG_UseEffects
+
+
+
+
+
+
+
+;---------------------------------------------------------------------
+;Sound stream.
+;---------------------------------------------------------------------
+
+;Plays the sound stream, filling the PSG registers table (but not playing it).
+;The Instrument pointer must be updated as it evolves inside the Instrument.
+;IN:    IX = Data block of the Track.
+;       IY = Points at the beginning of the register structure related to the channel.
+;       C = R7. Only bit 2 (sound) must be *set* to cut the sound if needed, and bit 5 (noise) must be *reset* if there is noise.
+;       DE' = Period table. Must not be modified.
+PLY_LW_PlaySoundStream:
+        ;Gets the pointer on the Instrument, from its base address and the offset.
+        ld l,PLY_LW_Data_OffsetPtInstrument + 0 (ix)
+        ld h,PLY_LW_Data_OffsetPtInstrument + 1 (ix)
+
+        ;Reads the first byte of the cell of the Instrument. What type?
+PLY_LW_PSS_ReadFirstByte:
+        ld a,(hl)
+        ld b,a
+        inc hl
+        rra
+        jr c,PLY_LW_PSS_SoftOrSoftAndHard
+
+        ;NoSoftNoHard or SoftwareToHardware
+        rra
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        jr c,PLY_LW_PSS_SoftwareToHardware
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+        ;No software no hardware, or end of sound (loop)!
+        ;End of sound?
+        rra
+        jr nc,PLY_LW_PSS_NSNH_NotEndOfSound
+        ;The sound loops/ends. Where?
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        ;As a sound always has at least one cell, we should safely be able to read its bytes without storing the instrument pointer.
+        ;However, we do it anyway to remove the overhead of the Speed management: if looping, the same last line will be read,
+        ;if several channels do so, it will be costly. So...
+        ld PLY_LW_Data_OffsetPtInstrument + 0 (ix),l
+        ld PLY_LW_Data_OffsetPtInstrument + 1 (ix),h
+        jr PLY_LW_PSS_ReadFirstByte
+
+PLY_LW_PSS_NSNH_NotEndOfSound:
+        ;No software, no hardware.
+        ;-------------------------
+        ;Stops the sound.
+        set 2,c
+
+        ;Volume. A now contains the volume on b0-3.
+        call PLY_LW_PSS_Shared_AdjustVolume
+        ld PLY_LW_Registers_OffsetVolume (iy),a
+
+        ;Read noise?
+        rl b
+                       .if PLY_CFG_NoSoftNoHard_Noise        ;CONFIG SPECIFIC
+        call c,PLY_LW_PSS_ReadNoise
+                       .endif ;PLY_CFG_NoSoftNoHard_Noise
+        jr PLY_LW_PSS_Shared_StoreInstrumentPointer
+
+        ;Software sound, or Software and Hardware?
+PLY_LW_PSS_SoftOrSoftAndHard:
+        rra
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        jr c,PLY_LW_PSS_SoftAndHard
+                       .endif ;PLY_CFG_UseHardwareSounds
+
+        ;Software sound.
+        ;-----------------
+        ;A is the volume. Already shifted twice, so it can be used directly.
+        call PLY_LW_PSS_Shared_AdjustVolume
+        ld PLY_LW_Registers_OffsetVolume (iy),a
+
+        ;Arp and/or noise?
+        ld d,#0x00          ;Default arpeggio.
+        rl b
+        jr nc,PLY_LW_PSS_S_AfterArpAndOrNoise
+        ld a,(hl)
+        inc hl
+        ;Noise?
+        sra a
+        ;A is now the signed Arpeggio. It must be kept.
+        ld d,a
+        ;Now takes care of the noise, if there is a Carry.
+                       .if PLY_LW_USE_Noise          ;CONFIG SPECIFIC
+        call c,PLY_LW_PSS_ReadNoise
+                       .endif ;PLY_LW_USE_Noise
+PLY_LW_PSS_S_AfterArpAndOrNoise:
+
+        ld a,d          ;Gets the instrument arpeggio, if any.
+        call PLY_LW_CalculatePeriodForBaseNote
+
+        ;Read pitch?
+        rl b
+                       .if PLY_CFG_SoftOnly_SoftwarePitch    ;CONFIG SPECIFIC
+        call c,PLY_LW_ReadPitchAndAddToPeriod
+                       .endif ;PLY_CFG_SoftOnly_SoftwarePitch
+
+        ;Stores the new period of this channel.
+        exx
+                ld PLY_LW_Registers_OffsetSoftwarePeriodLSB (iy),l
+                ld PLY_LW_Registers_OffsetSoftwarePeriodMSB (iy),h
+        exx
+
+        ;The code below is mutualized!
+        ;Stores the new instrument pointer, if Speed allows it.
+        ;--------------------------------------------------
+PLY_LW_PSS_Shared_StoreInstrumentPointer:
+        ;Checks the Instrument speed, and only stores the Instrument new pointer if the speed is reached.
+        ld a,PLY_LW_Data_OffsetInstrumentCurrentStep (ix)
+        cp PLY_LW_Data_OffsetInstrumentSpeed (ix)
+        jr z,PLY_LW_PSS_S_SpeedReached
+        ;Increases the current step.
+        inc PLY_LW_Data_OffsetInstrumentCurrentStep (ix)
+        ret
+PLY_LW_PSS_S_SpeedReached:
+        ;Stores the Instrument new pointer, resets the speed counter.
+        ld PLY_LW_Data_OffsetPtInstrument + 0 (ix),l
+        ld PLY_LW_Data_OffsetPtInstrument + 1 (ix),h
+        ld PLY_LW_Data_OffsetInstrumentCurrentStep (ix),#0x00
+        ret
+
+
+                       .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+
+        ;Software and Hardware.
+        ;----------------------------
+PLY_LW_PSS_SoftAndHard:
+        ;Reads the envelope bit, the possible pitch, and sets the software period accordingly.
+        call PLY_LW_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv
+        ;Reads the hardware period.
+        ld a,(hl)
+        ld (PLY_LW_Reg11),a
+        inc hl
+        ld a,(hl)
+        ld (PLY_LW_Reg12),a
+        inc hl
+
+        jr PLY_LW_PSS_Shared_StoreInstrumentPointer
+
+
+        ;Software to Hardware.
+        ;-------------------------
+PLY_LW_PSS_SoftwareToHardware:
+        call PLY_LW_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv
+
+        ;Now we can calculate the hardware period thanks to the ratio.
+        ld a,b
+        rra
+        rra
+        and #0b11100
+        ld (PLY_LW_PSS_STH_Jump + 1),a
+        exx
+PLY_LW_PSS_STH_Jump: 
+                jr . + 2           ;Automodified by the line above to jump to the right place.
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                srl h
+                rr l
+                jr nc,PLY_LW_PSS_STH_RatioEnd
+                inc hl
+PLY_LW_PSS_STH_RatioEnd:
+                ld a,l
+                ld (PLY_LW_Reg11),a
+                ld a,h
+                ld (PLY_LW_Reg12),a
+        exx
+
+        jr PLY_LW_PSS_Shared_StoreInstrumentPointer
+
+;A shared code for hardware sound.
+;Reads the envelope bit in bit 1, arpeggio in bit 7 pitch in bit 2 from A. If pitch present, adds it to BC'.
+;Converts the note to period, adds the instrument pitch, sets the software period of the channel.
+;Also sets the hardware volume, and sets the hardware curve.
+PLY_LW_PSS_Shared_ReadEnvBitPitchArp_SoftPeriod_HardVol_HardEnv:
+        ;Envelope bit? R13 = 8 + 2 * (envelope bit?). Allows to have hardware envelope to 8 or 0xa.
+        ;Shifted by 2 to the right, bit 1 is now envelope bit, which is perfect for us.
+        and #0b10
+        add a,#0x08
+        ld (PLY_LW_SetReg13 + 1),a
+
+        ;Volume to 16 to trigger the hardware envelope.
+        ld PLY_LW_Registers_OffsetVolume (iy),#0x10
+
+        ;Arpeggio?
+        xor a                   ;Default arpeggio.
+                       .if PLY_LW_ArpeggioInHardwareInstrument  ;CONFIG SPECIFIC
+        bit 7,b                 ;Not shifted yet.
+        jr z,PLY_LW_PSS_Shared_REnvBAP_AfterArpeggio
+        ;Reads the Arpeggio.
+        ld a,(hl)
+        inc hl
+PLY_LW_PSS_Shared_REnvBAP_AfterArpeggio:
+                       .endif ;PLY_LW_ArpeggioInHardwareInstrument
+        ;Calculates the software period.
+        call PLY_LW_CalculatePeriodForBaseNote
+
+        ;Pitch?
+                       .if PLY_LW_PitchInHardwareInstrument  ;CONFIG SPECIFIC
+        bit 2,b         ;Not shifted yet.
+        call nz,PLY_LW_ReadPitchAndAddToPeriod
+                       .endif ;PLY_LW_PitchInHardwareInstrument
+
+        ;Stores the new period of this channel.
+        exx
+                ld PLY_LW_Registers_OffsetSoftwarePeriodLSB (iy),l
+                ld PLY_LW_Registers_OffsetSoftwarePeriodMSB (iy),h
+        exx
+        ret
+
+                       .endif ;PLY_CFG_UseHardwareSounds
+                
+;Decreases the given volume (encoded in possibly more then 4 bits). If <0, forced to 0.
+;IN:    A = volume, not ANDed.
+;OUT:   A = new volume.
+PLY_LW_PSS_Shared_AdjustVolume:
+        and #0b1111
+        sub PLY_LW_Data_OffsetTrackInvertedVolume (ix)
+        ret nc
+        xor a
+        ret
+
+;Reads and stores the noise pointed by HL, opens the noise channel.
+;IN:    HL = instrument data where the noise is.
+;OUT:   HL = HL++.
+;MOD:   A.
+               .if PLY_LW_USE_Noise          ;CONFIG SPECIFIC
+PLY_LW_PSS_ReadNoise:
+        ld a,(hl)
+        inc hl
+        ld (PLY_LW_NoiseRegister),a
+        res 5,c                 ;Opens the noise channel.
+        ret
+               .endif ;PLY_LW_USE_Noise
+
+;Calculates the period according to the base note and put it in BC'. Used by both software and hardware codes.
+;IN:    DE' = period table.
+;       A = instrument arpeggio (0 if not used).
+;OUT:   HL' = period.
+;MOD:   A
+PLY_LW_CalculatePeriodForBaseNote:
+        ;Gets the period from the current note.
+        exx
+                ld h,#0x00
+                add a,PLY_LW_Data_OffsetBaseNote (ix)                        ;Adds the instrument Arp to the base note (including the transposition).
+                               .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+                add PLY_LW_Data_OffsetCurrentArpeggioValue (ix)               ;Adds the Arpeggio Table effect.
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                ld l,a
+                sla l                   ;Note encoded on 7 bits, so should be fine.
+                add hl,de
+                ld a,(hl)
+                inc hl
+                ld h,(hl)
+                ld l,a                  ;HL' = period.
+
+                ;Adds the Pitch Table value, if used.
+                               .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+                ld a,PLY_LW_Data_OffsetIsPitchTableUsed (ix)
+                or a
+                jr z,PLY_LW_CalculatePeriodForBaseNote_NoPitchTable
+                ld c,PLY_LW_Data_OffsetCurrentPitchTableValue + 0 (ix)
+                ld b,PLY_LW_Data_OffsetCurrentPitchTableValue + 1 (ix)
+                add hl,bc
+PLY_LW_CalculatePeriodForBaseNote_NoPitchTable:
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+                ;Adds the Track Pitch.
+                               .if PLY_LW_USE_EffectPitchUpDown
+                ld c,PLY_LW_Data_OffsetTrackPitchInteger + 0 (ix)
+                ld b,PLY_LW_Data_OffsetTrackPitchInteger + 1 (ix)
+                add hl,bc
+                               .endif ;PLY_LW_USE_EffectPitchUpDown
+        exx
+        ret
+
+                       .if PLY_LW_PitchInInstrument  ;CONFIG SPECIFIC
+;Reads the pitch in the Instruments (16 bits) and adds it to HL', which should contain the software period.
+;IN:    HL = points on the pitch value.
+;OUT:   HL = points after the pitch.
+;MOD:   A, BC', HL' updated.
+PLY_LW_ReadPitchAndAddToPeriod:
+        ;Reads 2 * 8 bits for the pitch. Slow...
+        ld a,(hl)
+        inc hl
+        exx
+                ld c,a                  ;Adds the read pitch to the note period.
+        exx
+        ld a,(hl)
+        inc hl
+        exx
+                ld b,a
+                add hl,bc
+        exx
+        ret
+                       .endif ;PLY_LW_PitchInInstrument
+
+
+
+
+
+
+
+
+
+
+
+
+
+;---------------------------------------------------------------------
+;Effect management.
+;---------------------------------------------------------------------
+
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+
+;IN:    HL = points after the first byte.
+;               B = data of the first byte on bits 0-4 (will probably needed to be ANDed, as bits 5-7 are undetermined).
+;               DE'= Instrument Table (not useful here). Do not modify!
+;               IX = data block of the Track.
+;OUT:   HL = points after the data of the effect (maybe nothing to do).
+;               Each effect must jump to PLY_LW_RT_CellRead.
+
+;Clears all the effects (volume, pitch table, arpeggio table).
+                       .if PLY_CFG_UseEffect_Reset           ;CONFIG SPECIFIC.
+PLY_LW_EffectReset:
+        ;Inverted volume.
+        call PLY_LW_ReadInvertedVolumeFromB
+
+        xor a
+        ;The inverted volume is managed above, so don't change it.
+                               .if PLY_LW_USE_EffectPitchUpDown              ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetIsPitchUpDownUsed (ix),a
+                               .endif ;PLY_LW_USE_EffectPitchUpDown
+                               .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetIsArpeggioTableUsed (ix),a
+        ld PLY_LW_Data_OffsetCurrentArpeggioValue (ix),a      ;Contrary to the Pitch, the value must be reset.
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                               .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        ld PLY_LW_Data_OffsetIsPitchTableUsed (ix),a
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+        jp PLY_LW_RT_CellRead
+                       .endif ;PLY_CFG_UseEffect_Reset
+
+;Changes the volume. Possibly changes the Track pitch.
+                       .if PLY_LW_USE_Volume_And_PitchUpDown_Effects           ;CONFIG SPECIFIC.
+PLY_LW_EffectVolumeAndPitchUpDown:
+        ;Stores the new inverted volume.
+        call PLY_LW_ReadInvertedVolumeFromB
+
+        ;Pitch? Warning, the code below is shared with the PitchUp/Down effect.
+        bit 4,b
+        jp z,PLY_LW_RT_CellRead
+        ;Pitch present. Reads and stores its 16 bits value (integer/decimal).
+PLY_LW_EffectPitchUpDown_Activated:
+        ;Code shared with the effect above.
+        ;Activates the effect.
+        ld PLY_LW_Data_OffsetIsPitchUpDownUsed (ix),#0xff
+        ld a,(hl)
+        inc hl
+        ld PLY_LW_Data_OffsetTrackPitchSpeed + 0 (ix),a
+        ld a,(hl)
+        inc hl
+        ld PLY_LW_Data_OffsetTrackPitchSpeed + 1 (ix),a
+
+        jp PLY_LW_RT_CellRead
+                       .endif ;PLY_LW_USE_Volume_And_PitchUpDown_Effects
+
+
+;Effect table. Each entry jumps to an effect management code.
+;Put after the code above so that the JR are within bound.
+PLY_LW_EffectTable:
+                       .if PLY_CFG_UseEffects * PLY_CFG_UseEffect_Reset ;CONFIG SPECIFIC
+        jr PLY_LW_EffectReset                                   ;000
+                       .else
+                        jr .
+                       .endif
+                        
+                       .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+        jr PLY_LW_EffectArpeggioTable                           ;001
+                       .else
+                        jr .
+                       .endif
+                
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+        jr PLY_LW_EffectPitchTable                              ;010
+                       .else
+                        jr .
+                       .endif
+                        
+                       .if PLY_LW_USE_EffectPitchUpDown              ;CONFIG SPECIFIC
+        jr PLY_LW_EffectPitchUpDown                             ;011
+                       .else
+                        jr .
+                       .endif
+                        
+                       .if PLY_LW_USE_Volume_And_PitchUpDown_Effects         ;CONFIG SPECIFIC
+        jr PLY_LW_EffectVolumeAndPitchUpDown                    ;100
+                       .else
+                        jr .
+                       .endif
+                        
+                       .if PLY_LW_USE_Volume_And_ArpeggioTable_Effects       ;CONFIG SPECIFIC
+        jr PLY_LW_EffectVolumeArpeggioTable                     ;101
+                       .else
+                        jr .
+                       .endif
+                        
+                       .if PLY_LW_USE_Reset_And_ArpeggioTable_Effects        ;CONFIG SPECIFIC
+        jr PLY_LW_EffectResetArpeggioTable                      ;110
+                       .else
+                        jr .
+                       .endif
+        
+        ;111 Unused.
+
+
+
+;Pitch up/down effect, activation or stop.
+                       .if PLY_LW_USE_EffectPitchUpDown              ;CONFIG SPECIFIC
+PLY_LW_EffectPitchUpDown:
+        rr b    ;Pitch present or pitch stop?
+        jr c,PLY_LW_EffectPitchUpDown_Activated
+        ;Pitch stop.
+        ld PLY_LW_Data_OffsetIsPitchUpDownUsed (ix),#0x00
+        jp PLY_LW_RT_CellRead
+                       .endif ;PLY_LW_USE_EffectPitchUpDown
+
+;Arpeggio table effect, activation or stop.
+                       .if PLY_CFG_UseEffect_ArpeggioTable           ;CONFIG SPECIFIC
+PLY_LW_EffectArpeggioTable:
+        ld a,b
+        and #0b11111
+PLY_LW_EffectArpeggioTable_AfterMask:
+        ld PLY_LW_Data_OffsetIsArpeggioTableUsed (ix),a       ;Sets to 0 if the Arpeggio is stopped, or any other value if it starts.
+        jr z,PLY_LW_EffectArpeggioTable_Stop
+
+        ;Gets the Arpeggio address.
+        add a,a
+        exx
+                ld l,a
+                ld h,#0x00
+;dknr3:
+PLY_LW_PtArpeggios: ld bc,#0x0000
+                add hl,bc
+                ld a,(hl)
+                inc hl
+                ld PLY_LW_Data_OffsetPtArpeggioTable + 0 (ix),a
+                ld a,(hl)
+                ld PLY_LW_Data_OffsetPtArpeggioTable + 1 (ix),a
+        exx
+
+        ;Resets the offset of the Arpeggio, to force a restart.
+        xor a
+        ld PLY_LW_Data_OffsetPtArpeggioOffset (ix),a
+        jp PLY_LW_RT_CellRead
+PLY_LW_EffectArpeggioTable_Stop:
+        ;Contrary to the Pitch, the Arpeggio must also be set to 0 when stopped.
+        ld PLY_LW_Data_OffsetCurrentArpeggioValue (ix),a
+        jp PLY_LW_RT_CellRead
+                       .endif ;PLY_CFG_UseEffect_ArpeggioTable
+
+;Pitch table effect, activation or stop.
+;This is exactly the same code as for the Arpeggio, but I can't find a way to share it...
+                       .if PLY_CFG_UseEffect_PitchTable              ;CONFIG SPECIFIC
+PLY_LW_EffectPitchTable:
+        ld a,b
+        and #0b11111
+PLY_LW_EffectPitchTable_AfterMask:
+        ld PLY_LW_Data_OffsetIsPitchTableUsed (ix),a  ;Sets to 0 if the Pitch is stopped, or any other value if it starts.
+        jp z,PLY_LW_RT_CellRead
+
+        ;Gets the Pitch address.
+        add a,a
+        exx
+                ld l,a
+                ld h,#0x00
+;dknr3:
+PLY_LW_PtPitches: ld bc,#0x0000
+                add hl,bc
+                ld a,(hl)
+                inc hl
+                ld PLY_LW_Data_OffsetPtPitchTable + 0 (ix),a
+                ld a,(hl)
+                inc hl
+                ld PLY_LW_Data_OffsetPtPitchTable + 1 (ix),a
+        exx
+
+        ;Resets the offset of the Pitch, to force a restart.
+        xor a
+        ld PLY_LW_Data_OffsetPtPitchOffset (ix),a
+
+        jp PLY_LW_RT_CellRead
+                       .endif ;PLY_CFG_UseEffect_PitchTable
+
+
+
+;Volume, and Arpeggio Table, activation or stop.
+                       .if PLY_LW_USE_Volume_And_ArpeggioTable_Effects       ;CONFIG SPECIFIC
+PLY_LW_EffectVolumeArpeggioTable:
+        ;Stores the new inverted volume.
+        call PLY_LW_ReadInvertedVolumeFromB
+
+        ;Manages the Arpeggio, encoded just after.
+        ld a,(hl)
+        inc hl
+        or a            ;Required, else a volume of 0 will disturb the flag test after the jump!
+        jr PLY_LW_EffectArpeggioTable_AfterMask
+                       .endif ;PLY_LW_USE_Volume_And_ArpeggioTable_Effects
+
+;Reset, and Arpeggio Table (activation only).
+                       .if PLY_LW_USE_Reset_And_ArpeggioTable_Effects        ;CONFIG SPECIFIC
+PLY_LW_EffectResetArpeggioTable:
+        ;Resets effects and read volume.
+        ;A bit of loss of CPU because we're going to set the Arpeggio just after, AND the effect pointer is stored!
+        ;Oh well, less memory taken this way.
+        call PLY_LW_EffectReset
+
+        ;Reads the Arpeggio.
+        ld a,(hl)
+        inc hl
+        or a            ;Required, else a volume of 0 will disturb the flag test after the jump!
+        jp PLY_LW_EffectArpeggioTable_AfterMask         ;No need to use the mask, the value is clean.
+                       .endif ;PLY_LW_USE_Reset_And_ArpeggioTable_Effects
+
+
+;Reads the inverted volume from B, stored it after masking the bits in A.
+PLY_LW_ReadInvertedVolumeFromB:
+        ld a,b
+        and #0b1111
+        ld PLY_LW_Data_OffsetTrackInvertedVolume (ix),a
+        ret
+
+                       .endif ;PLY_CFG_UseEffects
+
+
+
+
+
+
+
+
+;---------------------------------------------------------------------
+;Data blocks for the three channels. Make sure NOTHING is added between, as the init clears everything!
+;---------------------------------------------------------------------
+
+;Data block for channel 1.
+PLY_LW_Track1_Data:
+;dkbs:
+PLY_LW_Track1_WaitEmptyCell: .db #0x00                       ;How many empty cells have to be waited. 0 = none.
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+PLY_LW_Track1_Transposition: .db 0
+                       .endif ;PLY_CFG_UseTranspositions
+PLY_LW_Track1_BaseNote: .db #0x00                            ;Base note, such as the note played. The transposition IS included.
+PLY_LW_Track1_InstrumentCurrentStep: .db #0x00               ;The current step on the Instrument (>=0, till it reaches the Speed).
+PLY_LW_Track1_InstrumentSpeed: .db #0x00                     ;The Instrument speed (>=0).
+PLY_LW_Track1_TrackInvertedVolume: .db 0
+;dkbe:
+;dkws:
+PLY_LW_Track1_PtTrack: .dw #0x0000                             ;Points on the next Cell of the Track to read. Evolves.
+PLY_LW_Track1_PtInstrument: .dw #0x0000                        ;Points on the Instrument, evolves.
+PLY_LW_Track1_PtBaseInstrument: .dw #0x0000                    ;Points on the base of the Instrument, does not evolve.
+;dkwe:
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+;dkbs:
+PLY_LW_Track1_IsPitchUpDownUsed: .db #0x00                   ;>0 if a Pitch Up/Down is currently in use.
+PLY_LW_Track1_TrackPitchDecimal: .db #0x00                   ;The decimal part of the Track pitch. Evolves as the pitch goes up/down.
+dkbe:
+dkws:
+PLY_LW_Track1_TrackPitchSpeed: .dw #0x0000                     ;The integer and decimal part of the Track pitch speed. Is added to the Track Pitch every frame.
+PLY_LW_Track1_TrackPitchInteger: .dw #0x0000                   ;The integer part of the Track pitch. Evolves as the pitch goes up/down.
+dkwe:
+;dkbs:
+PLY_LW_Track1_IsArpeggioTableUsed: .db #0x00                 ;>0 if an Arpeggio Table is currently in use.
+PLY_LW_Track1_PtArpeggioOffset: .db #0x00                    ;Increases over the Arpeggio.
+PLY_LW_Track1_CurrentArpeggioValue: .db #0x00                ;Value from the Arpeggio to add to the base note. Read even if the Arpeggio effect is deactivated.
+;dkbe:
+;dkws:
+PLY_LW_Track1_PtArpeggioTable: .dw #0x0000                     ;Point on the base of the Arpeggio table, does not evolve.
+;dkwe:
+;dkbs:
+PLY_LW_Track1_IsPitchTableUsed: .db #0x00                    ;>0 if a Pitch Table is currently in use.
+PLY_LW_Track1_PtPitchOffset: .db #0x00                       ;Increases over the Pitch.
+;dkbe:
+;dkws:
+PLY_LW_Track1_CurrentPitchTableValue: .dw #0x0000              ;16 bit value from the Pitch to add to the base note. Not read if the Pitch effect is deactivated.
+PLY_LW_Track1_PtPitchTable: .dw #0x0000                        ;Points on the base of the Pitch table, does not evolve.
+;dkwe:
+                       .endif ;PLY_CFG_UseEffects
+PLY_LW_Track1_Data_End:
+
+.equ PLY_LW_Track1_Data_Size  , PLY_LW_Track1_Data_End - PLY_LW_Track1_Data
+
+.equ PLY_LW_Data_OffsetWaitEmptyCell                , PLY_LW_Track1_WaitEmptyCell - PLY_LW_Track1_Data
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+.equ PLY_LW_Data_OffsetTransposition                , PLY_LW_Track1_Transposition - PLY_LW_Track1_Data
+                       .endif ;PLY_CFG_UseTranspositions
+
+.equ PLY_LW_Data_OffsetPtTrack                      , PLY_LW_Track1_PtTrack - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetBaseNote                     , PLY_LW_Track1_BaseNote - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtInstrument                 , PLY_LW_Track1_PtInstrument - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtBaseInstrument             , PLY_LW_Track1_PtBaseInstrument - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetInstrumentCurrentStep        , PLY_LW_Track1_InstrumentCurrentStep - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetInstrumentSpeed              , PLY_LW_Track1_InstrumentSpeed - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetTrackInvertedVolume          , PLY_LW_Track1_TrackInvertedVolume - PLY_LW_Track1_Data
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+                               .if PLY_LW_USE_EffectPitchUpDown      ;CONFIG SPECIFIC
+.equ PLY_LW_Data_OffsetIsPitchUpDownUsed            , PLY_LW_Track1_IsPitchUpDownUsed - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetTrackPitchInteger            , PLY_LW_Track1_TrackPitchInteger - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetTrackPitchDecimal            , PLY_LW_Track1_TrackPitchDecimal - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetTrackPitchSpeed              , PLY_LW_Track1_TrackPitchSpeed - PLY_LW_Track1_Data
+                               .endif ;PLY_LW_USE_EffectPitchUpDown
+                               .if PLY_CFG_UseEffect_ArpeggioTable ;CONFIG SPECIFIC
+.equ PLY_LW_Data_OffsetIsArpeggioTableUsed          , PLY_LW_Track1_IsArpeggioTableUsed - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtArpeggioTable              , PLY_LW_Track1_PtArpeggioTable - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtArpeggioOffset             , PLY_LW_Track1_PtArpeggioOffset - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetCurrentArpeggioValue         , PLY_LW_Track1_CurrentArpeggioValue - PLY_LW_Track1_Data
+                               .endif ;PLY_CFG_UseEffect_ArpeggioTable
+                               .if PLY_CFG_UseEffect_PitchTable        ;CONFIG SPECIFIC
+.equ PLY_LW_Data_OffsetIsPitchTableUsed             , PLY_LW_Track1_IsPitchTableUsed - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtPitchTable                 , PLY_LW_Track1_PtPitchTable - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetCurrentPitchTableValue       , PLY_LW_Track1_CurrentPitchTableValue - PLY_LW_Track1_Data
+.equ PLY_LW_Data_OffsetPtPitchOffset                , PLY_LW_Track1_PtPitchOffset - PLY_LW_Track1_Data
+                               .endif ;PLY_CFG_UseEffect_PitchTable
+                       .endif ;PLY_CFG_UseEffects
+
+;Data block for channel 2.
+PLY_LW_Track2_Data:
+;       .ds PLY_LW_Track1_Data_Size
+
+        .db 0
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        .db 0
+                       .endif ;PLY_CFG_UseTranspositions
+        .db 0,0,0,0,0,0,0,0,0,0
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+                       .endif ;PLY_CFG_UseEffects
+
+PLY_LW_Track2_Data_End:
+.equ PLY_LW_Track2_WaitEmptyCell  , PLY_LW_Track2_Data + PLY_LW_Data_OffsetWaitEmptyCell
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+.equ PLY_LW_Track2_Transposition  , PLY_LW_Track2_Data + PLY_LW_Data_OffsetTransposition
+                       .endif ;PLY_CFG_UseTranspositions
+
+.equ PLY_LW_Track2_PtTrack  , PLY_LW_Track2_Data + PLY_LW_Data_OffsetPtTrack
+.equ PLY_LW_Track2_PtInstrument  , PLY_LW_Track2_Data + PLY_LW_Data_OffsetPtInstrument
+
+;Data block for channel 3.
+PLY_LW_Track3_Data:
+;       .ds PLY_LW_Track1_Data_Size
+        .db 0
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+        .db 0
+                       .endif ;PLY_CFG_UseTranspositions
+        .db 0,0,0,0,0,0,0,0,0,0
+                       .if PLY_CFG_UseEffects        ;CONFIG SPECIFIC
+        .db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+                       .endif ;PLY_CFG_UseEffects
+PLY_LW_Track3_Data_End:
+.equ PLY_LW_Track3_WaitEmptyCell  , PLY_LW_Track3_Data + PLY_LW_Data_OffsetWaitEmptyCell
+                       .if PLY_CFG_UseTranspositions         ;CONFIG SPECIFIC
+.equ PLY_LW_Track3_Transposition  , PLY_LW_Track3_Data + PLY_LW_Data_OffsetTransposition
+                       .endif ;PLY_CFG_UseTranspositions
+.equ PLY_LW_Track3_PtTrack  , PLY_LW_Track3_Data + PLY_LW_Data_OffsetPtTrack
+.equ PLY_LW_Track3_PtInstrument  , PLY_LW_Track3_Data + PLY_LW_Data_OffsetPtInstrument
+
+;        ;Makes sure the structure all have the same size!
+;        ASSERT (PLY_LW_Track1_Data_End - PLY_LW_Track1_Data) == (PLY_LW_Track2_Data_End - PLY_LW_Track2_Data)
+;        ASSERT (PLY_LW_Track1_Data_End - PLY_LW_Track1_Data) == (PLY_LW_Track3_Data_End - PLY_LW_Track3_Data)
+;        ;No holes between the blocks, the init makes a LDIR to clear everything!
+;        ASSERT PLY_LW_Track1_Data_End == PLY_LW_Track2_Data
+;        ASSERT PLY_LW_Track2_Data_End == PLY_LW_Track3_Data
+
+
+
+;---------------------------------------------------------------------
+;Register block for all the channels. They are "polluted" with pointers to code because all this
+;is actually a RET table!
+;---------------------------------------------------------------------
+;DB register, DB value then.dw code to jump to once the value is read.
+PLY_LW_Registers_RetTable:
+PLY_LW_Track1_Registers:
+       .db 8
+PLY_LW_Track1_Volume: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 0
+PLY_LW_Track1_SoftwarePeriodLSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 1
+PLY_LW_Track1_SoftwarePeriodMSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+
+PLY_LW_Track2_Registers:
+       .db 9
+PLY_LW_Track2_Volume: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 2
+PLY_LW_Track2_SoftwarePeriodLSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 3
+PLY_LW_Track2_SoftwarePeriodMSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+
+PLY_LW_Track3_Registers:
+       .db 10
+PLY_LW_Track3_Volume: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 4
+PLY_LW_Track3_SoftwarePeriodLSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 5
+PLY_LW_Track3_SoftwarePeriodMSB: .db 0
+       .dw PLY_LW_SendPsgRegister
+
+;Generic registers.
+                       .if PLY_LW_USE_NoiseRegister + PLY_LW_USE_NoiseRegisterS         ;CONFIG SPECIFIC
+       .db 6
+PLY_LW_NoiseRegister: .db 0
+       .dw PLY_LW_SendPsgRegister
+                       .endif ;PLY_LW_USE_NoiseRegister
+
+       .db 7
+PLY_LW_MixerRegister: .db 0
+    .if PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+       .dw PLY_LW_SendPsgRegister
+       .db 11
+PLY_LW_Reg11:  .db 0
+       .dw PLY_LW_SendPsgRegister
+       .db 12
+PLY_LW_Reg12:  .db 0
+       .dw PLY_LW_SendPsgRegisterR13
+        ;This one is a trick to send the register after R13 is managed.
+       .dw PLY_LW_SendPsgRegisterAfterPop
+
+       .dw PLY_LW_SendPsgRegisterEnd
+    .else
+       .dw PLY_LW_SendPsgRegisterEnd
+    .endif ;PLY_CFG_UseHardwareSounds
+
+
+
+.equ PLY_LW_Registers_OffsetVolume             , PLY_LW_Track1_Volume - PLY_LW_Track1_Registers
+.equ PLY_LW_Registers_OffsetSoftwarePeriodLSB  , PLY_LW_Track1_SoftwarePeriodLSB - PLY_LW_Track1_Registers
+.equ PLY_LW_Registers_OffsetSoftwarePeriodMSB  , PLY_LW_Track1_SoftwarePeriodMSB - PLY_LW_Track1_Registers
+
+;The period table for each note (from 0 to 127 included).
+PLY_LW_PeriodTable:
+;dkws
+       .if PLY_LW_HARDWARE_CPC + PLY_LW_HARDWARE_ENTERPRISE
+        ;PSG running to 1000000 Hz.
+       .dw 3822,3608,3405,3214,3034,2863,2703,2551,2408,2273,2145,2025          ;0
+       .dw 1911,1804,1703,1607,1517,1432,1351,1276,1204,1136,1073,1012          ;12
+       .dw 956,902,851,804,758,716,676,638,602,568,536,506                      ;24
+       .dw 478,451,426,402,379,358,338,319,301,284,268,253                      ;36
+       .dw 239,225,213,201,190,179,169,159,150,142,134,127                      ;48
+       .dw 119,113,106,100,95,89,84,80,75,71,67,63                              ;60
+       .dw 60,56,53,50,47,45,42,40,38,36,34,32                                  ;72
+       .dw 30,28,27,25,24,22,21,20,19,18,17,16                                  ;84
+       .dw 15,14,13,13,12,11,11,10,9,9,8,8                                      ;96
+       .dw 7,7,7,6,6,6,5,5,5,4,4,4                                              ;108
+       .dw 4,4,3,3,3,3,3,2 ;,2,2,2,2                                            ;120 -> 127
+       .endif
+
+       .if PLY_LW_HARDWARE_SPECTRUM + PLY_LW_HARDWARE_MSX
+        ;PSG running to 1773400 Hz.
+       .dw 6778, 6398, 6039, 5700, 5380, 5078, 4793, 4524, 4270, 4030, 3804, 3591	; Octave 0
+       .dw 3389, 3199, 3019, 2850, 2690, 2539, 2397, 2262, 2135, 2015, 1902, 1795	; Octave 1
+       .dw 1695, 1599, 1510, 1425, 1345, 1270, 1198, 1131, 1068, 1008, 951, 898	; Octave 2
+       .dw 847, 800, 755, 712, 673, 635, 599, 566, 534, 504, 476, 449	; Octave 3
+       .dw 424, 400, 377, 356, 336, 317, 300, 283, 267, 252, 238, 224	; Octave 4
+       .dw 212, 200, 189, 178, 168, 159, 150, 141, 133, 126, 119, 112	; Octave 5
+       .dw 106, 100, 94, 89, 84, 79, 75, 71, 67, 63, 59, 56	; Octave 6
+       .dw 53, 50, 47, 45, 42, 40, 37, 35, 33, 31, 30, 28	; Octave 7
+       .dw 26, 25, 24, 22, 21, 20, 19, 18, 17, 16, 15, 14	; Octave 8
+       .dw 13, 12, 12, 11, 11, 10, 9, 9, 8, 8, 7, 7	; Octave 9
+       .dw 7, 6, 6, 6, 5, 5, 5, 4	; Octave 10
+       .endif
+
+       .if PLY_LW_HARDWARE_PENTAGON
+        ;PSG running to 1750000 Hz.
+       .dw 6689, 6314, 5959, 5625, 5309, 5011, 4730, 4464, 4214, 3977, 3754, 3543	; Octave 0
+       .dw 3344, 3157, 2980, 2812, 2655, 2506, 2365, 2232, 2107, 1989, 1877, 1772	; Octave 1
+       .dw 1672, 1578, 1490, 1406, 1327, 1253, 1182, 1116, 1053, 994, 939, 886	; Octave 2
+       .dw 836, 789, 745, 703, 664, 626, 591, 558, 527, 497, 469, 443	; Octave 3
+       .dw 418, 395, 372, 352, 332, 313, 296, 279, 263, 249, 235, 221	; Octave 4
+       .dw 209, 197, 186, 176, 166, 157, 148, 140, 132, 124, 117, 111	; Octave 5
+       .dw 105, 99, 93, 88, 83, 78, 74, 70, 66, 62, 59, 55	; Octave 6
+       .dw 52, 49, 47, 44, 41, 39, 37, 35, 33, 31, 29, 28	; Octave 7
+       .dw 26, 25, 23, 22, 21, 20, 18, 17, 16, 16, 15, 14	; Octave 8
+       .dw 13, 12, 12, 11, 10, 10, 9, 9, 8, 8, 7, 7	; Octave 9
+       .dw 7, 6, 6, 5, 5, 5, 5, 4	; Octave 10
+       .endif
+;dkwe
+PLY_LW_End:
+
+
+; =============================================================================
+ .if PLY_LW_HARDWARE_ENTERPRISE
+  .ifeq NO_ENVELOPE_IRQ
+
+envelopeInterrupt:
+
+    .if ENABLE_1000HZ_IRQ 
+        ld    a, #0x13
+        out   (#0xb4), a
+    .endif
+        push  hl
+        push  bc
+envelopeInterrupt.l1:    ld    hl,#0x0000                 ; * envelope counter
+      .if ENABLE_1000HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #500) / #1000)
+      .else
+        .if ENABLE_300HZ_IRQ
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #150) / #300)
+        .else
+        ld    bc, #65536 - (((#62500 * #ENV_SRATE_DIV) + #25) / #50)
+        .endif
+      .endif
+        add   hl, bc
+envelopeInterrupt.l2:    jr    c, envelopeInterrupt.l19                   ; * JR if envelope is stopped
+envelopeInterrupt.l3:    ld    bc, #0xffff               ; * envelope frequency
+envelopeInterrupt.l4:    ld    a,#0x00                   ; * envelope state (0 to 15)
+envelopeInterrupt.l5:    dec   a                         ; * envelope direction (INC A or DEC A)
+        add   hl, bc
+        jr    nc, envelopeInterrupt.l5
+        ld    (envelopeInterrupt.l1 + 1), hl
+        cp    #0x10
+envelopeInterrupt.l6:    jr    nc, envelopeInterrupt.l21                  ; * envelope mode
+envelopeInterrupt.l7:    ld    (envelopeInterrupt.l4 + 1), a
+envelopeInterrupt.l8:    add   a,#<ayVolumeTable
+        ld    l, a
+        adc   a, #>ayVolumeTable
+        sub   l
+        ld    h,a
+        or    a
+envelopeInterrupt.l9:
+        ld    a, (hl)
+        pop   bc
+envelopeInterrupt.l10:   jr    envelopeInterrupt.l12                      ; * envelope enable mode
+envelopeInterrupt.l11:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channel A only
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l12:   pop   hl
+        ret
+envelopeInterrupt.l13:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and B
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l14:
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; envelope on channel B only (Carry=0)
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l15:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l16:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channel C only
+        pop   hl
+        ret
+envelopeInterrupt.l17:   out   (#0xa8 + ayDaveChnA), a    ; envelope on channels A, B, and C
+    .ifeq ENABLE_STEREO
+        out   (#0xac + ayDaveChnA), a
+    .endif
+envelopeInterrupt.l18:
+    .ifeq ENABLE_STEREO
+        out   (#0xa8 + ayDaveChnC), a
+    .endif
+        out   (#0xac + ayDaveChnC), a    ; envelope on channels B and C
+    .ifne ENABLE_STEREO
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (#0xa8 + ayDaveChnB), a
+        out   (#0xac + ayDaveChnB), a
+        pop   hl
+        ret
+envelopeInterrupt.l19:   ld    (envelopeInterrupt.l1 + 1), hl
+        pop   bc
+        pop   hl
+        ret
+envelopeInterrupt.l20:   ld    l, #<(ayVolumeTable + 15)       ; envelope modes 11 and 13
+        .db  #0x01                      ; = LD BC, nnnn
+envelopeInterrupt.l21:   ld    l, #<ayVolumeTable      ; envelope modes 0 to 7, 9, and 15
+        ld    h, #>ayVolumeTable
+        ld    a, #0x18                  ; = JR +nn
+        ld    (envelopeInterrupt.l2), a                  ; stop envelope
+        jp    envelopeInterrupt.l9
+envelopeInterrupt.l22:   and   #0x0f                     ; envelope modes 8 and 12
+        jp    envelopeInterrupt.l7
+envelopeInterrupt.l23:   jp    m, envelopeInterrupt.l24                   ; envelope modes 10 and 14
+        xor   #0x1f
+        ld    l, a
+        ld    h,#0x3d                   ; set direction to DEC A
+        ld    (envelopeInterrupt.l4 + 1), hl             ; assume .l5 = .l4 + 2
+        jp    envelopeInterrupt.l8
+envelopeInterrupt.l24:   cpl
+        ld    l, a
+        ld    h,#0x3c                   ; set direction to INC A
+        ld    (envelopeInterrupt.l4 + 1), hl
+        jp    envelopeInterrupt.l8
+
+  .endif
+; -----------------------------------------------------------------------------
+
+ayVolumeTable:
+        .db   0,  1,  2,  3,  4,  5,  6,  9
+        .db  12, 17, 22, 28, 36, 44, 53, 63
+
+ayRegisterMaskTable:
+        .db  #0xff,#0x0f,#0xff,#0x0f,#0xff,#0x0f,#0x1f,#0xff
+        .db  #0x1f,#0x1f,#0x1f,#0xff,#0xff,#0x0f,#0xff,#0xff
+
+ayRegisters:
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+        .db  #0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00,#0x00
+
+ayRegWriteTable:
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l3 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l4 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l6 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l7 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l5 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l9 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l10 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l11 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l12 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l15 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+        .db  <(ayRegisterWrite.l8 - (ayRegisterWrite.l1 + 2))
+
+
+    .ifeq NO_ENVELOPE_IRQ
+
+envelopeModeTable:
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l22 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l20 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l23 - (envelopeInterrupt.l6 + 2))
+        .db  <(envelopeInterrupt.l21 - (envelopeInterrupt.l6 + 2))
+
+envelopeEnableTable:
+        .db  <(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l11 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l14 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l13 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l16 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l15 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l18 - envelopeInterrupt.l11)
+        .db  <(envelopeInterrupt.l17 - envelopeInterrupt.l11)
+
+    .endif
+
+setChannelAmplitude:
+        cp    #0x10
+        jr    c, setChannelAmplitude.l1
+    .ifeq NO_ENVELOPE_IRQ
+        res   3, b
+        ld    a, (envelopeInterrupt.l4 + 1)
+    .else
+        xor   a
+    .endif
+setChannelAmplitude.l1:                                    ; HL = ayRegWriteTable + (8 + channel)
+        add     a,#<ayVolumeTable
+        ld      l,a
+        adc     a,#>ayVolumeTable
+        sub     l
+        ld      h,a
+    .ifne ENABLE_STEREO
+        bit     0,c                     ; Z = 0: channel B, Z = 1: channel A, C
+    .endif
+        ld    a, (hl)
+    .ifne ENABLE_STEREO 
+        jr    z, setChannelAmplitude.l2
+        or    a
+        ld    l, a                      ; NOTE: Carry is always 0 here
+        rra
+        scf
+        adc   a, l
+        rra
+    .endif
+        out   (c), a
+        set   2, c
+setChannelAmplitude.l2:    out   (c), a
+    .ifeq NO_ENVELOPE_IRQ
+setChannelAmplitude.l3:    ld      a,#0x00                   ; *
+        ld      c,a
+        or      b
+        cp      #0x08
+        jr      c,setChannelAmplitude.l4
+        xor     b
+setChannelAmplitude.l4:    cp      c
+        jr      z, setChannelAmplitude.l5                    ; envelope enable bit has not changed ?
+        ld      (setChannelAmplitude.l3+1), a
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeEnableTable
+        add     hl,bc
+        ld      a,(hl)
+        ld      (envelopeInterrupt.l10+1),a
+    .endif
+setChannelAmplitude.l5:    pop   bc
+;        pop   af
+        ret
+
+setChannelAFreq:
+        ld    c, #0xa0 + (ayDaveChnA * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters)
+    .if toneAndNoiseModeAtone
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+        and   #0x04
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeAnoise
+        bit   3, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        rrca
+        jr    nc, setToneGenFrequency   ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeAtnns
+        and   #0x09
+        jr    z, setToneGenAAsNoise     ; tone + noise generator enabled ?
+        cp    #0x08
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnA * 2)), a
+        out   (#0xa1 + (ayDaveChnA * 2)), a
+        ret
+
+setChannelBFreq:
+        ld    c, #0xa0 + (ayDaveChnB * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 2)
+    .if toneAndNoiseModeBtone
+        bit   1, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x10
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeBnoise
+        bit   4, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x02
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeBtnns
+        and   #0x12
+        jr    z, setToneGenBAsNoise     ; tone + noise generator enabled ?
+        cp    #0x10
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnB * 2)), a
+        out   (#0xa1 + (ayDaveChnB * 2)), a
+        ret
+
+setChannelCFreq:
+        ld    c, #0xa0 + (ayDaveChnC * 2)
+        ld    a, (ayRegisters + 7)
+        ld    hl, (ayRegisters + 4)
+    .if toneAndNoiseModeCtone
+        bit   2, a
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+        and   #0x20
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+    .endif
+    .if toneAndNoiseModeCnoise
+        bit   5, a
+        jr    z, setNoiseGenFreq        ; noise generator enabled ?
+        and   #0x04
+        jr    z, setToneGenFrequency    ; tone generator enabled ?
+    .endif
+    .if toneAndNoiseModeCtnns
+        and   #0x24
+        jr    z, setToneGenCAsNoise     ; tone + noise generator enabled ?
+        cp    #0x20
+        jr    z, setToneGenFrequency    ; tone generator only ?
+        jr    c, setNoiseGenFreq        ; noise generator only ?
+    .endif
+        xor   a                         ; channel disabled
+        out   (#0xa0 + (ayDaveChnC * 2)), a
+        out   (#0xa1 + (ayDaveChnC * 2)), a
+        ret
+
+    .if toneAndNoiseModeAtnns
+setToneGenAAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeBtnns
+setToneGenBAsNoise:
+        ld    a,#0x30
+        jp    setToneGenFrequency_
+    .endif
+
+    .if toneAndNoiseModeCtnns
+setToneGenCAsNoise:
+        ld    a,#0x30
+        .db   #0xfe                      ; = CP nn
+    .endif
+
+setToneGenFrequency:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        xor   a
+    .endif
+
+setToneGenFrequency_:
+        add   hl, hl
+        dec   hl
+        bit   4, h
+        jr    nz, setToneGenFrequency_.l2                   ; overflow ?
+setToneGenFrequency_.l1:
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        or    h                         ; non-zero for tone + noise
+    .endif
+        out   (c), l
+        inc   c
+    .if toneAndNoiseModeAtnns + toneAndNoiseModeAtnns + toneAndNoiseModeAtnns
+        out   (c), a
+    .else
+        out   (c), h
+    .endif
+        ret
+setToneGenFrequency_.l2:    ld    l,#0x01
+        inc   h
+        jr    z, setToneGenFrequency_.l1
+        ld    hl,#0x0fff
+        jp    setToneGenFrequency_.l1
+
+    .if (toneAndNoiseModeAtnns * toneAndNoiseModeAnoise)
+setToneGenAAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeBtnns * toneAndNoiseModeBnoise)
+setToneGenBAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+    .if (toneAndNoiseModeCtnns * toneAndNoiseModeCnoise)
+setToneGenCAsNoise:
+        ld    h,#0x30
+        jp    setNoiseGenFreq_
+    .endif
+
+setNoiseGenFreq:
+        ld    h,#0x30
+
+setNoiseGenFreq_:
+        ld    a, (ayRegisters + 6)
+        add   a, a
+        add   a, a
+        jr    nz, setNoiseGenFreq_.l1
+        ld    a,#0x04
+setNoiseGenFreq_.l1:    dec   a
+        out   (c), a
+        inc   c
+        out   (c), h
+        ret
+; -----------------------------------------------------------------------------
+; reset AY-3-8912 emulation
+
+ayReset:
+;        di
+        ld    hl, #ayRegisters - 1
+        ld    bc, #0x10af
+        xor   a
+ayReset.l1:    inc   hl
+        out   (c), a
+        ld    (hl), a
+        dec   c
+        djnz  ayReset.l1
+        res   3, l                      ; register 7
+        ld    (hl), #0x3f
+    .ifeq NO_ENVELOPE_IRQ
+        ld    (envelopeInterrupt.l4 + 1), a
+        ld    a, #0x18                    ; = JR +nn
+        ld    (envelopeInterrupt.l2), a
+        ld    hl, #MIN_ENV_FREQVAL
+        ld    (envelopeInterrupt.l3 + 1), hl
+        ld    a, #<(envelopeInterrupt.l12 - envelopeInterrupt.l11)
+        ld    (envelopeInterrupt.l10 + 1), a
+        xor     a
+        ld    (setChannelAmplitude.l3 + 1), a
+    .endif
+        ld    a, #0x04
+        out   (#0xbf), a
+        ld    c, b
+        call  ayReset.l2
+        ld    l, b
+        call  ayReset.l2                       ; L = 1 kHz interrupts per video frame
+        ld    a, #25
+        cp    l
+        ld    a, #0x03
+        rla
+        rla
+        out   (#0xbf), a                 ; Z80 <= 5 MHz: 04h, > 5 MHz: 06h
+        ld    a, #0x10                    ; use 17-bit noise generator
+        out   (#0xa6), a
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, #0x33
+    .else
+        ld    a, #0x30
+    .endif
+        out   (#0xb4), a                 ; enable 1 kHz and video interrupts
+        ret
+ayReset.l2:    in    a, (#0xb4)
+        and   #0x11
+        or    c
+        rlca
+        and   #0x66
+        ld    c, a                      ; -ON--ON-
+        rlca                            ; ON--ON--
+        xor   c                         ; OXN-OXN-
+        bit   2, a
+        jr    z, ayReset.l3
+        inc   l                         ; 1 kHz interrupt
+ayReset.l3:    cp    #0xc0
+        jr    c, ayReset.l2                    ; not 50 Hz interrupt ?
+        ret
+
+;; read AY-3-8912 register A, returning the value in A
+;
+;ayRegisterRead:
+;        and   0fh
+;        or    <ayRegisters
+;        ld    l, a
+;        ld    h, >ayRegisters
+;        ld    a, (hl)
+;        or    a
+;        ret
+
+; write C to AY-3-8912 register A
+; NOTE: interrupts may be enabled on return
+ayRegisterWriteDE:
+        ld      a,(de)
+        ld      c,a
+        inc     de
+        ld      a,(de)
+        inc     de
+        inc     de
+        inc     de
+
+ayRegisterWrite:
+        ld      b,#0x00
+        ld      hl,#ayRegisterMaskTable
+        add     hl,bc
+        inc     c
+        and     (hl)
+        push    bc
+        ld      c,#0x10
+        add     hl,bc                   ;ayRegisters
+        cp      (hl)
+        jr      z,ayRegisterWrite.l2                   ; register not changed ?
+        ld      (hl),a
+        add     hl,bc                   ;ayRegWriteTable
+        ld      a,(hl)
+        ld      (ayRegisterWrite.l1+1),a
+ayRegisterWrite.l1:    jr      ayRegisterWrite.l8                     ; *
+ayRegisterWrite.l2:    
+    .ifeq NO_ENVELOPE_IRQ
+        ld    a, l
+        xor   #<(ayRegisters + 13)
+        jr    z, ayRegisterWrite.l16                   ; envelope restart ?
+    .endif
+        pop     bc
+;        pop   af
+        ret
+ayRegisterWrite.l3:    call  setChannelAFreq           ; tone generator A frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l4:    call  setChannelBFreq           ; tone generator B frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l5:    call  setChannelAFreq           ; mixer
+        call  setChannelBFreq
+ayRegisterWrite.l6:    call  setChannelCFreq           ; tone generator C frequency
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l7:    ld    a, (ayRegisters + 7)      ; noise generator frequency
+    .if toneAndNoiseModeAnoise
+        ld    b, a
+        and   #0x08
+    .else
+        xor   #0x07
+        ld    b, a
+        and   #0x09
+    .endif
+        call  z, setChannelAFreq
+    .if toneAndNoiseModeBnoise
+        bit   4, b
+    .else
+        ld    a, b
+        and   #0x12
+    .endif
+        call  z, setChannelBFreq
+    .if toneAndNoiseModeCnoise
+        bit   5, b
+    .else
+        ld    a, b
+        and   #0x24
+    .endif
+        call  z, setChannelCFreq
+ayRegisterWrite.l8:    pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l9:    ld    a, (ayRegisters + 8)      ; channel A amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x09a8 + ayDaveChnA
+    .else
+        ld    c,#0xa8 + ayDaveChnA
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l10:   ld    a, (ayRegisters + 9)      ; channel B amplitude / envelope enable
+    .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0aa8 + ayDaveChnB
+    .else
+        ld    c,#0xa8 + ayDaveChnB
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l11:   ld    a, (ayRegisters + 10)     ; channel C amplitude / envelope enable
+    .ifeq ENABLE_STEREO
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0ca8 + ayDaveChnC
+      .else
+        ld    c,#0xa8 + ayDaveChnC
+      .endif
+    .else
+      .ifeq NO_ENVELOPE_IRQ
+        ld    bc,#0x0cac + ayDaveChnC
+      .else
+        ld    c,#0xac + ayDaveChnC
+      .endif
+    .endif
+        jp    setChannelAmplitude
+ayRegisterWrite.l12:
+    .ifeq NO_ENVELOPE_IRQ
+        ld    hl, (ayRegisters + 11)    ; envelope generator frequency
+        ld    a, h
+        or    a
+        jr    nz, ayRegisterWrite.l13
+        ld    a, #MIN_ENV_FREQVAL
+        cp    l
+        jr    c, ayRegisterWrite.l13
+        ld    l, a                      ; limit envelope frequency
+ayRegisterWrite.l13:   ld    (envelopeInterrupt.l3 + 1), hl
+        pop   bc
+;        pop   af
+        ret
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+ayRegisterWrite.l15:                                   ; envelope generator mode / restart
+    .ifeq NO_ENVELOPE_IRQ
+ayRegisterWrite.l16:   ld      hl,(envelopeInterrupt.l3+1)
+        ld      (envelopeInterrupt.l1+1),hl
+        ld      a,#0x38                     ; = JR C, +nn
+        ld      (envelopeInterrupt.l2),a    ; enable envelope
+        ld      a,(ayRegisters+13)
+        ld      c,a
+        ld      b,#0x00
+        ld      hl,#envelopeModeTable
+        add     hl,bc
+        and     #0x04
+        ld    a, (hl)
+        ld    (envelopeInterrupt.l6 + 1), a
+        ld    hl,#0x3c00                    ; INC A, state = 0
+        ld    a, l
+        jr    nz, ayRegisterWrite.l17                      ; attack ?
+        ld    hl,#0x3d0f                    ; DEC A, state = 15
+        ld    a,#0x3f
+ayRegisterWrite.l17:   ld    (envelopeInterrupt.l4 + 1), hl    ; assume eInt.l5 = eInt.l4 + 2
+        call  ayRegisterWrite.l18
+        pop   bc
+;        pop   af
+        ret
+ayRegisterWrite.l18:   call  envelopeInterrupt.l10     ; NOTE: this will pop return address
+    .else
+        jr    ayRegisterWrite.l8
+    .endif
+
+ .endif
+; =============================================================================
+
+
+   ;PLY_UseEnterprise_End 
+
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW_SoundEffects.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW_SoundEffects.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW_SoundEffects.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW_SoundEffects.src	2025-01-11 16:57:38
@@ -0,0 +1,593 @@
+;       Player of sound effects, for the Lightweight player.
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpLW_SFXInit
+   ;;
+   ;;    Initializes sound effect instruments to be able to play sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpLW_SFXInit> (void* *sfx_song_data*)
+   ;;
+   ;; Input Parameters (2 bytes):
+   ;;  (2B DE) sfx_song_data - Pointer to the start of a song file containing instrument data for SFX
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpLW_SFXInit_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *sfx_song_data* must be a song in binary AKS format. However, this song 
+   ;; only needs to have instruments defined (there is not need for an actual "song"
+   ;; as a list of notes, patterns and others). Instruments will be set up for 
+   ;; playing SFX later on with functions like <cpct_akp_SFXPlay>.
+   ;;
+   ;; Details:
+   ;;    This function initializes instruments that will be used later on to play 
+   ;; FX sounds at will using <cpct_akp_SFXPlay>. In order for the instruments to
+   ;; be initialized, *sfx_song_data* must point to a song defined in AKS format.
+   ;; For the purpose of this function, the song only requires to have instruments
+   ;; defined in it, as patterns, notes and other information is not used for FX
+   ;; sounds. 
+   ;;
+   ;;    You may use instruments from another song or a specific song containing
+   ;; instrument data only. Any song with instruments defined in it is valid to
+   ;; set up SFX with Arkos Tracker Player.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, DE, HL
+   ;;
+   ;; Required memory:
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;;    Any     |  146   |  36.50
+   ;; --------------------------------
+   ;; Asm saving |  -41   | -10.25
+   ;; -------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   PLY_SFX_Init:
+   _cpct_akpLW_SFXInit::
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  e, (hl)                                  ;; [ 7]
+      inc hl                                       ;; [ 6]
+      ld  d, (hl)                                  ;; [ 7] HL = Pointer to the SFX "Song"
+      ex  de, hl
+
+   cpct_akpLW_SFXInit_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Initializes the sound effects. It MUST be called at any times before a first sound effect is triggered.
+;It doesn't matter whether the song is playing or not, or if it has been initialized or not.
+;IN:    HL = Address to the sound effects data.
+PLY_LW_InitSoundEffectsDisarkGenerateExternalLabel:
+PLY_LW_InitSoundEffects:
+        ld (PLY_LW_SE_PtSoundEffectTable + 1),hl
+        ret
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpLW_SFXPlay
+   ;;
+   ;;    Plays a concrete sound effect, using the instruments of the "SFX song" 
+   ;; given to <cpct_akpLW_SFXInit> when initializing sound effects.
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpLW_SFXPlay> (<u8> *sfx_num*, <u8> *channel_bitmask*, <u8> *volume*,)
+   ;;
+   ;; Input Parameters (3 bytes):
+   ;;  (1B A ) sfx_num         - Number of the instrument in the SFX Song (>0), same as the number given to the 
+   ;; instrument in Arkos Tracker.
+   ;;  (1B C ) channel
+   ;;  (1B B ) inv vol
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpLW_SFXPlay_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Details:
+   ;;    Plays a given sound effect, along with the music, in a concrete channel 
+   ;; and with some parameters (Volume, Note, Speed, Inverted Pitch). This lets
+   ;; you create lots of different (and potentially complex) sound effects 
+   ;; from a set of instruments. In fact, you could play a song made of sound
+   ;; effect calls. 
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, BC, DE, HL,
+   ;;
+   ;; Required memory:
+   ;;    95 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2089 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;;    Case    | Cycles  | microSecs (us)
+   ;; --------------------------------------
+   ;;    Any     |     To be done
+   ;; --------------------------------------
+   ;; Asm saving |  -141   |  -45.25
+   ;; --------------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpLW_SFXPlay::
+   PLY_SFX_Play:
+      ld  hl, #2                                   ;; [10] Get Parameter from Stack
+      add hl, sp                                   ;; [11]
+      ld  a, (hl)                                  ;; [ 7] sfx
+      inc hl                                       ;; [ 6]
+      ld  c, (hl)                                  ;; [ 7] channel
+      inc hl                                       ;; [ 6]
+      ld  b, (hl)                                  ;; [ 7] vol
+
+      cpct_akpLW_SFXPlay_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Plays a sound effect. If a previous one was already playing on the same channel, it is replaced.
+;This does not actually plays the sound effect, but programs its playing.
+;The music player, when called, will call the PLY_LW_PlaySoundEffectsStream method below.
+;IN:    A = Sound effect number (>0!).
+;       C = The channel where to play the sound effect (0, 1, 2).
+;       B = Inverted volume (0 = full volume, 16 = no sound). Hardware sounds are also lowered.
+PLY_LW_PlaySoundEffectDisarkGenerateExternalLabel:
+PLY_LW_PlaySoundEffect:
+        ;Gets the address to the sound effect.
+        dec a                   ;The 0th is not encoded.
+dknr3:
+PLY_LW_SE_PtSoundEffectTable: ld hl,#0x000
+        ld e,a
+        ld d,#0x00
+        add hl,de
+        add hl,de
+        ld e,(hl)
+        inc hl
+        ld d,(hl)
+        ;Reads the header of the sound effect to get the speed.
+        ld a,(de)
+        inc de
+        ex af,af'
+
+        ld a,b
+
+        ;Finds the pointer to the sound effect of the desired channel.
+        ld hl,#PLY_LW_Channel1_SoundEffectData
+        ld b,#0x00
+        sla c
+        sla c
+        sla c
+        add hl,bc
+        ld (hl),e
+        inc hl
+        ld (hl),d
+        inc hl        
+        
+        ;Now stores the inverted volume.
+        ld (hl),a
+        inc hl
+        
+        ;Resets the current speed, stores the instrument speed.
+        ld (hl),#0x00
+        inc hl
+        ex af,af'
+        ld (hl),a
+        
+        ret
+
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+   ;;
+   ;; Function: cpct_akpLW_SFXStop
+   ;;
+   ;;    Stops the reproduction sound FX on given channels
+   ;;
+   ;; C Definition:
+   ;;    void <cpct_akpLW_SFXStop> (<u8> *stop_bitmask*)
+   ;;
+   ;; Input Parameters (1 byte):
+   ;;  (1B A) stop_bitmask - A value where the 3 Least Significant Bits represent which channels to stop 
+   ;; (bits enabled = channels to stop)
+   ;;
+   ;; Assembly call (Input parameters on registers):
+   ;;    > call cpct_akpLW_SFXStop_asm
+   ;;
+   ;; Known limitations:
+   ;;  * This function *will not work from ROM*, as it uses self-modifying code.
+   ;;
+   ;; Parameter Restrictions:
+   ;;    * *stop_bitmask* must be a value that operates as a set of enabled / 
+   ;; disabled bits (a bitmask). Concretely, the 3 Least Significant bits, 2, 1 
+   ;; and 0 (xxxxx210) refer to Channels C, B and A respectively. Rest of the 
+   ;; bits are ignored. Bits set to 1 mean that those channels will be stopped. 
+   ;; Bits set to 0 mean that those channels are to be left as they are.
+   ;;
+   ;; Details:
+   ;;    This function lets you selectively stop sound FX reproduction on one, two
+   ;; or the 3 available channels. A *stop_bitmask* is given as parameter containing
+   ;; the information about what channels shall be stopped.
+   ;;
+   ;; Destroyed Register values: 
+   ;;    AF, HL
+   ;;
+   ;; Required memory:
+   ;;    30 bytes 
+   ;;
+   ;;    However, take into account that all of Arkos Tracker Player's
+   ;; functions are linked and included, because they depend on each other. Total
+   ;; memory requirement is around 2082 bytes.
+   ;;
+   ;; Time Measures:
+   ;; (start code)
+   ;; Case       | Cycles | microSecs (us)
+   ;; --------------------------------
+   ;; Best (0)   |  101   |  25.25 
+   ;; --------------------------------
+   ;; Best (1)   |  149   |  37.25 
+   ;; --------------------------------
+   ;; Asm saving |  -28   |  -7.00
+   ;; --------------------------------
+   ;; (end code)
+   ;;
+   ;; Credits:
+   ;;    This is a modification of the original <Arkos Tracker Player at
+   ;; http://www.grimware.org/doku.php/documentations/software/arkos.tracker/start> 
+   ;; code from Targhan / Arkos. Madram / Overlander and Grim / Arkos have also 
+   ;; contributed to this source.
+   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+   _cpct_akpLW_SFXStop::
+   PLY_SFX_Stop:
+      ld   hl, #2                             ;; [10] Get Parameter from Stack
+      add  hl, sp                             ;; [11]
+      ld    a, (hl)                           ;; [ 7] A = Channel number to be stopped
+
+   cpct_akpLW_SFXStop_asm::     ;; Entry point for assembly calls using registers for parameter passing
+
+;Stops a sound effect. Nothing happens if there was no sound effect.
+;IN:    A = The channel where to stop the sound effect (0, 1, 2).
+PLY_LW_StopSoundEffectFromChannelDisarkGenerateExternalLabel:
+PLY_LW_StopSoundEffectFromChannel:
+        ;Puts 0 to the pointer of the sound effect.
+        add a,a
+        add a,a
+        add a,a
+        ld e,a
+        ld d,#0x00
+        ld hl,#PLY_LW_Channel1_SoundEffectData
+        add hl,de
+        ld (hl),d               ;0 means "no sound".
+        inc hl
+        ld (hl),d
+        ret
+
+;Plays the sound effects, if any has been triggered by the user.
+;This does not actually send registers to the PSG, it only overwrite the required values of the registers of the player.
+;The sound effects initialization method must have been called before!
+;As R7 is required, this must be called after the music has been played, but BEFORE the registers are sent to the PSG.
+;IN:    A = R7.
+PLY_LW_PlaySoundEffectsStream:
+        ;Shifts the R7 to the left twice, so that bit 2 and 5 only can be set for each track, below.
+        rla
+        rla
+
+        ;Plays the sound effects on every track.
+        ld ix,#PLY_LW_Channel1_SoundEffectData
+        ld iy,#PLY_LW_Track1_Registers
+        ld c,a
+        call PLY_LW_PSES_Play
+        ld ix,#PLY_LW_Channel2_SoundEffectData
+        ld iy,#PLY_LW_Track2_Registers
+        srl c                   ;Not RR, because we have to make sure the b6 is 0,.ELSE no more keyboard (on CPC)!
+                                ;Also, on MSX, bit 6 must be 0.
+        call PLY_LW_PSES_Play
+        ld ix,#PLY_LW_Channel3_SoundEffectData
+        ld iy,#PLY_LW_Track3_Registers
+       .IF PLY_LW_HARDWARE_MSX
+                scf             ;On MSX, bit 7 must be 1.
+                rr c
+       .ELSE
+                rr c            ;On other platforms, we don't care about b7.
+       .ENDIF
+        call PLY_LW_PSES_Play
+
+        ld a,c
+        ld (PLY_LW_MixerRegister),a
+        ret
+
+
+;Plays the sound stream from the given pointer to the sound effect. If 0, no sound is played.
+;The given R7 is given shift twice to the left, so that this code MUST set/reset the bit 2 (sound), and maybe reset bit 5 (noise).
+;This code MUST overwrite these bits because sound effects have priority over the music.
+;IN:    IX = Points on the sound effect pointer. If the sound effect pointer is 0, nothing must be played.
+;       IY = Points at the beginning of the register structure related to the channel.
+;       C = R7, shifted twice to the left.
+;OUT:   The pointed pointer by IX may be modified as the sound advances.
+;       C = R7, MUST be modified if there is a sound effect.
+PLY_LW_PSES_Play:
+        ;Reads the pointer pointed by IX.
+        ld l,0 (ix)
+        ld h,1 (ix)
+        ld a,l
+        or h
+        ret z           ;No sound to be played? Returns immediately.
+
+        ;Reads the first byte. What type of sound is it?
+PLY_LW_PSES_ReadFirstByte:
+        ld a,(hl)
+        inc hl
+        ld b,a
+        rra
+        jr c,PLY_LW_PSES_SoftwareOrSoftwareAndHardware
+        rra
+                       .IF PLY_CFG_SFX_HardOnly              ;CONFIG SPECIFIC
+        jr c,PLY_LW_PSES_HardwareOnly
+                       .ENDIF ;PLY_CFG_SFX_HardOnly
+
+        ;No software, no hardware, or end/loop.
+        ;-------------------------------------------
+        ;End or loop?
+        rra
+                       .IF PLY_CFG_SFX_NoSoftNoHard         ;CONFIG SPECIFIC. If not present, the jump is not needed, the method is just below.
+        jr c,PLY_LW_PSES_S_EndOrLoop
+                        
+        ;No software, no hardware.
+        ;-------------------------------------------
+        ;Gets the volume.
+        call PLY_LW_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+                               .IF PLY_CFG_SFX_NoSoftNoHard_Noise                ;CONFIG SPECIFIC
+        rl b
+        call c,PLY_LW_PSES_ReadNoiseAndOpenNoiseChannel
+                               .ENDIF ;PLY_CFG_SFX_NoSoftNoHard_Noise
+
+        jr PLY_LW_PSES_SavePointerAndExit
+                       .ENDIF ;PLY_CFG_SFX_NoSoftNoHard
+
+        ;**Warning!** Do not put any instruction between EndOrLoop and NoSoftNoHard.
+
+PLY_LW_PSES_S_EndOrLoop:
+                       .IF PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC. If no "loop to", the sounds always end, no need to test.
+        ;Is it an end?
+        rra
+        jr c,PLY_LW_PSES_S_Loop
+                       .ENDIF ;PLY_CFG_SFX_LoopTo
+        ;End of the sound. Marks the sound pointer with 0, meaning "no sound".
+        xor a
+        ld 0 (ix),a
+        ld 1 (ix),a
+        ret
+                       .IF PLY_CFG_SFX_LoopTo                ;CONFIG SPECIFIC.
+PLY_LW_PSES_S_Loop:
+        ;Loops. Reads the pointer and directly uses it.
+        ld a,(hl)
+        inc hl
+        ld h,(hl)
+        ld l,a
+        jr PLY_LW_PSES_ReadFirstByte
+                       .ENDIF ;PLY_CFG_SFX_LoopTo
+
+
+;Saves HL into IX, and exits. This must be called at the end of each Cell.
+;If the speed has not been reached, it is not saved.
+PLY_LW_PSES_SavePointerAndExit:
+        ;Speed reached?
+        ld a,PLY_LW_SoundEffectData_OffsetCurrentStep (ix)
+        cp PLY_LW_SoundEffectData_OffsetSpeed (ix)
+        jr c,PLY_LW_PSES_NotReached
+        ;The speed has been reached, so resets it and saves the pointer to the next cell to read.
+        ld PLY_LW_SoundEffectData_OffsetCurrentStep (ix),#0x00
+        ld 0 (ix),l
+        ld 1 (ix),h
+        ret
+PLY_LW_PSES_NotReached:
+        ;Speed not reached. Increases it, that's all. The same cell will be read next time.
+        inc PLY_LW_SoundEffectData_OffsetCurrentStep (ix)
+        ret
+
+                       .IF PLY_CFG_SFX_HardOnly         ;CONFIG SPECIFIC
+        ;Hardware only.
+        ;-------------------------------------------
+PLY_LW_PSES_HardwareOnly:
+        ;Calls the shared code that manages everything.
+        call PLY_LW_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+        ;Cuts the sound.
+        set 2,c
+
+        jr PLY_LW_PSES_SavePointerAndExit
+                       .ENDIF ;PLY_CFG_SFX_HardOnly
+
+
+
+PLY_LW_PSES_SoftwareOrSoftwareAndHardware:
+        ;Software only?
+        rra
+                       .IF PLY_CFG_SFX_SoftAndHard         ;CONFIG SPECIFIC
+        jr c,PLY_LW_PSES_SoftwareAndHardware
+                       .ENDIF ;PLY_CFG_SFX_SoftAndHard
+
+        ;Software.
+        ;-------------------------------------------
+                       .IF PLY_CFG_SFX_SoftOnly          ;CONFIG SPECIFIC
+        ;Volume.
+        call PLY_LW_PSES_ManageVolumeFromA_Filter4Bits
+
+        ;Noise?
+        rl b
+                               .IF PLY_CFG_SFX_SoftOnly_Noise                ;CONFIG SPECIFIC
+        call c,PLY_LW_PSES_ReadNoiseAndOpenNoiseChannel
+                               .ENDIF ;PLY_CFG_SFX_SoftOnly_Noise
+
+        ;Opens the "sound" channel.
+        res 2,c
+
+        ;Reads the software period.
+        call PLY_LW_PSES_ReadSoftwarePeriod
+
+        jr PLY_LW_PSES_SavePointerAndExit
+                       .ENDIF ;PLY_CFG_SFX_SoftOnly
+
+
+        ;Software and Hardware.
+        ;-------------------------------------------
+                       .IF PLY_LW_SE_HardwareSounds         ;CONFIG SPECIFIC
+PLY_LW_PSES_SoftwareAndHardware:
+        ;Calls the shared code that manages everything.
+        call PLY_LW_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise
+
+        ;Reads the software period.
+        call PLY_LW_PSES_ReadSoftwarePeriod
+
+        ;Opens the sound.
+        res 2,c
+
+        jr PLY_LW_PSES_SavePointerAndExit
+                       .ENDIF ;PLY_LW_SE_HardwareSounds
+
+
+                       .IF PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+        ;Shared code used by the "hardware only" and "software and hardware" part.
+        ;Reads the Retrig flag, the Hardware Envelope, the possible noise, the hardware period,
+        ;and sets the volume to 16. The R7 sound channel is NOT modified.
+PLY_LW_PSES_Shared_ReadRetrigHardwareEnvPeriodNoise:
+        ;Retrig?
+        rra
+                               .IF PLY_LW_SE_Retrig                  ;CONFIG SPECIFIC
+        jr nc,PLY_LW_PSES_H_AfterRetrig
+        ld d,a
+        ld a,#0xff
+        ld (PLY_LW_SetReg13Old + 1),a
+        ld a,d
+PLY_LW_PSES_H_AfterRetrig:
+                               .ENDIF ;PLY_LW_SE_Retrig
+
+        ;The hardware envelope can be set (8-15).
+        and #0b111
+        add a,#0x08
+        ld (PLY_LW_SetReg13 + 1),a
+
+        ;Noise?
+                               .IF PLY_LW_SE_HardwareNoise           ;CONFIG SPECIFIC. B not needed after, we can put it in the condition too.
+        rl b
+        call c,PLY_LW_PSES_ReadNoiseAndOpenNoiseChannel
+                               .ENDIF ;PLY_LW_SE_HardwareNoise
+
+        ;Reads the hardware period.
+        call PLY_LW_PSES_ReadHardwarePeriod
+
+        ;Sets the volume to "hardware". It still may be decreased.
+        ld a,#0x10
+        jp PLY_LW_PSES_ManageVolumeFromA_Hard
+                       .ENDIF ;PLY_CFG_UseHardwareSounds
+
+
+                       .IF PLY_LW_SE_Noise
+;Reads the noise pointed by HL, increases HL, and opens the noise channel.
+PLY_LW_PSES_ReadNoiseAndOpenNoiseChannel:
+        ;Reads the noise.
+        ld a,(hl)
+        ld (PLY_LW_NoiseRegister),a
+        inc hl
+
+        ;Opens noise channel.
+        res 5,c
+        ret
+                       .ENDIF ;PLY_LW_SE_Noise
+
+                       .IF PLY_CFG_UseHardwareSounds         ;CONFIG SPECIFIC
+;Reads the hardware period from HL and sets the R11/R12 registers. HL is incremented of 2.
+PLY_LW_PSES_ReadHardwarePeriod:
+        ld a,(hl)
+        ld (PLY_LW_Reg11),a
+        inc hl
+        ld a,(hl)
+        ld (PLY_LW_Reg12),a
+        inc hl
+        ret
+                       .ENDIF ;PLY_CFG_UseHardwareSounds
+
+;Reads the software period from HL and sets the period registers thanks to IY. HL is incremented of 2.
+PLY_LW_PSES_ReadSoftwarePeriod:
+        ld a,(hl)
+        ld PLY_LW_Registers_OffsetSoftwarePeriodLSB (iy),a
+        inc hl
+        ld a,(hl)
+        ld PLY_LW_Registers_OffsetSoftwarePeriodMSB (iy),a
+        inc hl
+        ret
+
+                       .IF PLY_LW_SE_VolumeSoft      ;CONFIG SPECIFIC
+;Reads the volume in A, decreases it from the inverted volume of the channel, and sets the volume via IY.
+;IN:    A = volume, from 0 to 15 (no hardware envelope).
+PLY_LW_PSES_ManageVolumeFromA_Filter4Bits:
+        and #0b1111
+                       .ENDIF ;PLY_LW_SE_VolumeSoft
+                       .IF PLY_LW_SE_VolumeSoftOrHard        ;CONFIG SPECIFIC
+;After the filtering. Useful for hardware sound (volume has been forced to 16).
+PLY_LW_PSES_ManageVolumeFromA_Hard:
+        ;Decreases the volume, checks the limit.
+        sub PLY_LW_SoundEffectData_OffsetInvertedVolume (ix)
+        jr nc,PLY_LW_PSES_MVFA_NoOverflow
+        xor a
+PLY_LW_PSES_MVFA_NoOverflow:
+        ld PLY_LW_Registers_OffsetVolume (iy),a
+        ret
+                       .ENDIF ;PLY_LW_SE_VolumeSoftOrHard
+
+
+;The data of the Channels MUST be consecutive.
+PLY_LW_Channel1_SoundEffectData:
+;dkws
+       .dw 0                                            ;Points to the sound effect for the track 1, or 0 if not playing.
+PLY_LW_Channel1_SoundEffectInvertedVolume:
+;dkwe
+;dkbs
+       .db 0                                            ;Inverted volume.
+PLY_LW_Channel1_SoundEffectCurrentStep:
+       .db 0                                            ;Current step (>=0).
+PLY_LW_Channel1_SoundEffectSpeed:
+       .db 0                                            ;Speed (>=0).
+       .db 0,0,0                                        ;Padding.
+
+.equ PLY_LW_Channel_SoundEffectDataSize , . - PLY_LW_Channel1_SoundEffectData
+        
+;dkbs
+PLY_LW_Channel2_SoundEffectData:
+       .db 0,0,0,0,0,0,0,0          ;PLY_LW_Channel_SoundEffectDataSize
+PLY_LW_Channel3_SoundEffectData:
+       .db 0,0,0,0,0,0,0,0          ;PLY_LW_Channel_SoundEffectDataSize
+;dkbe
+
+;Offset from the beginning of the data, to reach the inverted volume.
+.equ PLY_LW_SoundEffectData_OffsetInvertedVolume     , PLY_LW_Channel1_SoundEffectInvertedVolume - PLY_LW_Channel1_SoundEffectData
+.equ PLY_LW_SoundEffectData_OffsetCurrentStep        , PLY_LW_Channel1_SoundEffectCurrentStep - PLY_LW_Channel1_SoundEffectData
+.equ PLY_LW_SoundEffectData_OffsetSpeed              , PLY_LW_Channel1_SoundEffectSpeed - PLY_LW_Channel1_SoundEffectData
+
+        ;;Checks that the pointers are consecutive.
+        ;assert (PLY_LW_Channel1_SoundEffectData + PLY_LW_Channel_SoundEffectDataSize) == PLY_LW_Channel2_SoundEffectData
+        ;assert (PLY_LW_Channel2_SoundEffectData + PLY_LW_Channel_SoundEffectDataSize) == PLY_LW_Channel3_SoundEffectData
+
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW_var.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW_var.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostrackerLW_var.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostrackerLW_var.src	2025-01-11 16:57:38
@@ -0,0 +1,98 @@
+    .if HARDWARE_ENTERPRISE
+.equ PLY_LW_HARDWARE_ENTERPRISE  , 1
+    .else
+.equ PLY_LW_HARDWARE_ENTERPRISE  , 0
+    .endif
+    .if HARDWARE_CPC
+.equ PLY_LW_HARDWARE_CPC         , 1
+    .else
+.equ PLY_LW_HARDWARE_CPC         , 0
+    .endif
+
+.equ PLY_LW_HARDWARE_MSX        , 0
+.equ PLY_LW_HARDWARE_SPECTRUM   , 0
+.equ PLY_LW_HARDWARE_PENTAGON   , 0
+
+;;------------------------------------------------------------------------------------------------------
+;;--- PLAYER CONFIGURATION CONSTANTS
+;;------------------------------------------------------------------------------------------------------
+.equ PLY_LW_USE_HOOKS           , 1         ;Use hooks for external calls? 0 if the Init/Play methods are directly called, will save a few bytes.
+.equ PLY_LW_STOP_SOUNDS         , 1         ;1 to have the "stop sounds" code. Set it to 0 if you never plan on stopping your music.
+
+.equ PLY_CFG_UseTranspositions              ,   1
+.equ PLY_CFG_UseSpeedTracks                 ,   1
+.equ PLY_CFG_UseEffects                     ,   1
+.equ PLY_CFG_UseHardwareSounds              ,   1
+.equ PLY_CFG_NoSoftNoHard_Noise             ,   1
+.equ PLY_CFG_SoftOnly_Noise                 ,   1
+.equ PLY_CFG_SoftOnly_SoftwareArpeggio      ,   1
+.equ PLY_CFG_SoftOnly_SoftwarePitch         ,   1
+.equ PLY_CFG_SoftToHard_SoftwarePitch       ,   1
+.equ PLY_CFG_SoftToHard_SoftwareArpeggio    ,   1
+.equ PLY_CFG_SoftAndHard_SoftwarePitch      ,   1
+.equ PLY_CFG_SoftAndHard_SoftwareArpeggio   ,   1
+.equ PLY_CFG_UseEffect_ArpeggioTable        ,   1
+.equ PLY_CFG_UseEffect_PitchTable           ,   1
+.equ PLY_CFG_UseEffect_PitchUp              ,   1
+.equ PLY_CFG_UseEffect_PitchDown            ,   1
+.equ PLY_CFG_UseEffect_SetVolume            ,   1
+.equ PLY_CFG_UseEffect_Reset                ,   1
+
+.equ PLY_LW_MANAGE_SOUND_EFFECTS            ,   1
+
+;PLY_CFG_UseHardwareSounds                   =  1
+.equ PLY_CFG_SFX_LoopTo                     ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard               ,   1
+.equ PLY_CFG_SFX_NoSoftNoHard_Noise         ,   1
+.equ PLY_CFG_SFX_SoftOnly                   ,   1
+.equ PLY_CFG_SFX_SoftOnly_Noise             ,   1
+.equ PLY_CFG_SFX_HardOnly                   ,   1
+.equ PLY_CFG_SFX_HardOnly_Noise             ,   1
+.equ PLY_CFG_SFX_HardOnly_Retrig            ,   1
+.equ PLY_CFG_SFX_SoftAndHard                ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Noise          ,   1
+.equ PLY_CFG_SFX_SoftAndHard_Retrig         ,   1
+
+;       Agglomerates some Player Configuration flags.
+;       --------------------------------------------
+;       Mixes the Hardware flags into one.
+       .IF PLY_CFG_SFX_HardOnly + PLY_CFG_SFX_SoftAndHard
+.equ PLY_LW_SE_HardwareSounds , 1
+       .else
+.equ PLY_LW_SE_HardwareSounds , 0
+       .ENDIF
+;       Mixes the Hardware Noise flags into one.
+       .IF PLY_CFG_SFX_HardOnly_Noise + PLY_CFG_SFX_SoftAndHard_Noise
+.equ PLY_LW_SE_HardwareNoise , 1
+       .else
+.equ PLY_LW_SE_HardwareNoise , 0        
+       .ENDIF
+;       Mixes the Noise flags into one.
+       .IF PLY_LW_SE_HardwareNoise + PLY_CFG_SFX_NoSoftNoHard_Noise + PLY_CFG_SFX_SoftOnly
+.equ PLY_LW_SE_Noise , 1
+       .else
+.equ PLY_LW_SE_Noise , 0
+       .ENDIF
+;       Noise in Sound Effects? Then noise register code must be compiled.
+       .IF PLY_LW_SE_Noise * PLY_LW_MANAGE_SOUND_EFFECTS
+.equ PLY_LW_USE_NoiseRegisterS , 1
+       .else
+.equ PLY_LW_USE_NoiseRegisterS , 0
+       .ENDIF
+;       Mixes the Software Volume flags into one.
+       .IF PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly + PLY_CFG_UseHardwareSounds
+.equ PLY_LW_SE_VolumeSoftOrHard , 1
+       .else
+.equ PLY_LW_SE_VolumeSoftOrHard , 0
+       .ENDIF
+       .IF PLY_CFG_SFX_NoSoftNoHard + PLY_CFG_SFX_SoftOnly
+.equ PLY_LW_SE_VolumeSoft , 1
+       .else
+.equ PLY_LW_SE_VolumeSoft , 0
+       .ENDIF
+;       Mixes the retrig flags into one.
+       .IF PLY_CFG_SFX_HardOnly_Retrig + PLY_CFG_SFX_SoftAndHard_Retrig
+.equ PLY_LW_SE_Retrig , 1
+       .else
+.equ PLY_LW_SE_Retrig , 0
+       .ENDIF
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/arkostracker_var.src cpctelera-linux-enterprise/cpctelera/src/audio/arkostracker_var.src
--- cpctelera-linux-cpc/cpctelera/src/audio/arkostracker_var.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/arkostracker_var.src	2025-01-11 16:57:38
@@ -0,0 +1,32 @@
+    .if HARDWARE_ENTERPRISE
+.equ PLY_UseEnterprise      ,   1     ;;Enteprise (1)/CPC (0)
+    .else
+.equ PLY_UseEnterprise      ,   0     ;;Enteprise (1)/CPC (0)
+    .endif
+
+;;------------------------------------------------------------------------------------------------------
+;;--- PLAYER CONFIGURATION CONSTANTS
+;;------------------------------------------------------------------------------------------------------
+
+;;
+;; Constants: Arkos Player Compilation Constants
+;;
+;;    Constants used to control which features are enabled / disabled in the Arkos Tracker
+;; Player code. Changing them requires recompiling CPCtelera's library to take effect.
+;;
+;;    PLY_UseSoundEffects - Set to 1 if you want to use Sound Effects in your player. 
+;; Both CPU and memory consuming. It is set to 1 by default in CPCtelera.
+;;    PLY_UseFades        - Set to 1 to allow fades in / out. A little CPU and memory 
+;; consuming. _cpct_akp_setFadeVolume becomes available.
+;;    PLY_SystemFriendly  - Set to 1 if you want to save the Registers used by AMSDOS 
+;; (AF', BC', IX, IY) which allows you to call this player in BASIC. As this option is 
+;; system-friendly, it cuts interruptions, and restores them ONLY IF NECESSARY. It is set
+;; to 0 by default. However, IX and IY registers are always saved.
+;;    PLY_RetrigValue     - Value used to trigger the Re-trig of Register 13. 0xFE 
+;; corresponds to 'CP xx'. Do not change it!
+;;
+.equ PLY_UseSoundEffects    ,   1
+.equ PLY_UseFades           ,   0
+.equ PLY_SystemFriendly     ,   0
+.equ PLY_RetrigValue        ,   #0xFE
+.equ PLY_UseFades           ,   0		;;Set to 1 to allow fades in/out. A little CPU and memory consuming.
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/audioAkg.h cpctelera-linux-enterprise/cpctelera/src/audio/audioAkg.h
--- cpctelera-linux-cpc/cpctelera/src/audio/audioAkg.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/audioAkg.h	2025-01-11 16:57:38
@@ -0,0 +1,73 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2009 Targhan / Arkos
+//  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+//######################################################################
+//### MODULE: Audio                                                  ###
+//######################################################################
+//### This module contains code for music and SFX players and other  ###
+//### audio routines.                                                ###
+//######################################################################
+//
+#ifndef CPCT_AUDIO_H
+#define CPCT_AUDIO_H
+
+//
+// File: Audio Constants&Variables
+//
+
+//
+// Arkos Player: full control version (without interrupts)
+// 
+
+// Arkos Player Music Control Functions
+extern void cpct_akpAKG_musicInit  (void* songdata, u8 sfx_num);
+extern void cpct_akpAKG_musicPlay  ();
+extern void cpct_akpAKG_stop       ();
+
+// Arkos Player Sound FX Control Functions (Only available if SFX is active)
+extern void cpct_akpAKG_SFXInit    (void* sfx_song_data);
+extern void cpct_akpAKG_SFXStop    (u8 stop_bitmask);
+extern void cpct_akpAKG_SFXPlay    (u8 sfx_num, u8 channel_bitmask, u8 volume);
+
+//
+// Variable: cpct_akp_songLoopTimes
+//
+//    This is an internal variable, updated by Arkos Tracker Player, 
+// that contains the number of times the present song has looped. You
+// may use it to know if a song has finished or if it has looped
+// N times.
+//
+//extern volatile  u8 cpct_akpAKG_songLoopTimes;
+
+// 
+// Constants: Audio Channels (bitmasks)
+//
+//    Bitmask constants for referring to audio channels of the
+// AY-3-8912 PSG chip.
+//
+//    AY_CHANNEL_A   - Audio Channel A (also referred as 0)
+//    AY_CHANNEL_B   - Audio Channel B (also referred as 1)
+//    AY_CHANNEL_C   - Audio Channel C (also referred as 2)
+//    AY_CHANNEL_ALL - All audio channels (A, B & C)
+//
+#define AY_CHANNEL_A    0b00000001
+#define AY_CHANNEL_B    0b00000010
+#define AY_CHANNEL_C    0b00000100
+#define AY_CHANNEL_ALL  0b00000111
+
+#endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/audioAkm.h cpctelera-linux-enterprise/cpctelera/src/audio/audioAkm.h
--- cpctelera-linux-cpc/cpctelera/src/audio/audioAkm.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/audioAkm.h	2025-01-11 16:57:38
@@ -0,0 +1,73 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2009 Targhan / Arkos
+//  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+//######################################################################
+//### MODULE: Audio                                                  ###
+//######################################################################
+//### This module contains code for music and SFX players and other  ###
+//### audio routines.                                                ###
+//######################################################################
+//
+#ifndef CPCT_AUDIO_H
+#define CPCT_AUDIO_H
+
+//
+// File: Audio Constants&Variables
+//
+
+//
+// Arkos Player: full control version (without interrupts)
+// 
+
+// Arkos Player Music Control Functions
+extern void cpct_akpAKM_musicInit  (void* songdata, u8 sfx_num);
+extern void cpct_akpAKM_musicPlay  ();
+extern void cpct_akpAKM_stop       ();
+
+// Arkos Player Sound FX Control Functions (Only available if SFX is active)
+extern void cpct_akpAKM_SFXInit    (void* sfx_song_data);
+extern void cpct_akpAKM_SFXStop    (u8 stop_bitmask);
+extern void cpct_akpAKM_SFXPlay    (u8 sfx_num, u8 channel_bitmask, u8 volume);
+
+//
+// Variable: cpct_akp_songLoopTimes
+//
+//    This is an internal variable, updated by Arkos Tracker Player, 
+// that contains the number of times the present song has looped. You
+// may use it to know if a song has finished or if it has looped
+// N times.
+//
+extern volatile  u8 cpct_akpAKM_songLoopTimes;
+
+// 
+// Constants: Audio Channels (bitmasks)
+//
+//    Bitmask constants for referring to audio channels of the
+// AY-3-8912 PSG chip.
+//
+//    AY_CHANNEL_A   - Audio Channel A (also referred as 0)
+//    AY_CHANNEL_B   - Audio Channel B (also referred as 1)
+//    AY_CHANNEL_C   - Audio Channel C (also referred as 2)
+//    AY_CHANNEL_ALL - All audio channels (A, B & C)
+//
+#define AY_CHANNEL_A    0b00000001
+#define AY_CHANNEL_B    0b00000010
+#define AY_CHANNEL_C    0b00000100
+#define AY_CHANNEL_ALL  0b00000111
+
+#endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/audioAky.h cpctelera-linux-enterprise/cpctelera/src/audio/audioAky.h
--- cpctelera-linux-cpc/cpctelera/src/audio/audioAky.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/audioAky.h	2025-01-11 16:57:38
@@ -0,0 +1,67 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2009 Targhan / Arkos
+//  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+//######################################################################
+//### MODULE: Audio                                                  ###
+//######################################################################
+//### This module contains code for music and SFX players and other  ###
+//### audio routines.                                                ###
+//######################################################################
+//
+#ifndef CPCT_AUDIO_H
+#define CPCT_AUDIO_H
+
+//
+// File: Audio Constants&Variables
+//
+
+//
+// Arkos Player: full control version (without interrupts)
+// 
+
+// Arkos Player Music Control Functions
+extern void cpct_akpAKY_musicInit  (void* songdata);
+extern void cpct_akpAKY_musicPlay  ();
+
+//
+// Variable: cpct_akp_songLoopTimes
+//
+//    This is an internal variable, updated by Arkos Tracker Player, 
+// that contains the number of times the present song has looped. You
+// may use it to know if a song has finished or if it has looped
+// N times.
+//
+extern volatile  u8 cpct_akpAKY_songLoopTimes;
+
+// 
+// Constants: Audio Channels (bitmasks)
+//
+//    Bitmask constants for referring to audio channels of the
+// AY-3-8912 PSG chip.
+//
+//    AY_CHANNEL_A   - Audio Channel A (also referred as 0)
+//    AY_CHANNEL_B   - Audio Channel B (also referred as 1)
+//    AY_CHANNEL_C   - Audio Channel C (also referred as 2)
+//    AY_CHANNEL_ALL - All audio channels (A, B & C)
+//
+#define AY_CHANNEL_A    0b00000001
+#define AY_CHANNEL_B    0b00000010
+#define AY_CHANNEL_C    0b00000100
+#define AY_CHANNEL_ALL  0b00000111
+
+#endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/audio/audioLW.h cpctelera-linux-enterprise/cpctelera/src/audio/audioLW.h
--- cpctelera-linux-cpc/cpctelera/src/audio/audioLW.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/audio/audioLW.h	2025-01-11 16:57:38
@@ -0,0 +1,73 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2009 Targhan / Arkos
+//  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+//######################################################################
+//### MODULE: Audio                                                  ###
+//######################################################################
+//### This module contains code for music and SFX players and other  ###
+//### audio routines.                                                ###
+//######################################################################
+//
+#ifndef CPCT_AUDIO_H
+#define CPCT_AUDIO_H
+
+//
+// File: Audio Constants&Variables
+//
+
+//
+// Arkos Player: full control version (without interrupts)
+// 
+
+// Arkos Player Music Control Functions
+extern void cpct_akpLW_musicInit  (void* songdata, u8 sfx_num);
+extern void cpct_akpLW_musicPlay  ();
+extern void cpct_akpLW_stop       ();
+
+// Arkos Player Sound FX Control Functions (Only available if SFX is active)
+extern void cpct_akpLW_SFXInit    (void* sfx_song_data);
+extern void cpct_akpLW_SFXStop    (u8 stop_bitmask);
+extern void cpct_akpLW_SFXPlay    (u8 sfx_num, u8 channel_bitmask, u8 volume);
+
+//
+// Variable: cpct_akp_songLoopTimes
+//
+//    This is an internal variable, updated by Arkos Tracker Player, 
+// that contains the number of times the present song has looped. You
+// may use it to know if a song has finished or if it has looped
+// N times.
+//
+extern volatile  u8 cpct_akpLW_songLoopTimes;
+
+// 
+// Constants: Audio Channels (bitmasks)
+//
+//    Bitmask constants for referring to audio channels of the
+// AY-3-8912 PSG chip.
+//
+//    AY_CHANNEL_A   - Audio Channel A (also referred as 0)
+//    AY_CHANNEL_B   - Audio Channel B (also referred as 1)
+//    AY_CHANNEL_C   - Audio Channel C (also referred as 2)
+//    AY_CHANNEL_ALL - All audio channels (A, B & C)
+//
+#define AY_CHANNEL_A    0b00000001
+#define AY_CHANNEL_B    0b00000010
+#define AY_CHANNEL_C    0b00000100
+#define AY_CHANNEL_ALL  0b00000111
+
+#endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/cpcteleraAkg.h cpctelera-linux-enterprise/cpctelera/src/cpcteleraAkg.h
--- cpctelera-linux-cpc/cpctelera/src/cpcteleraAkg.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/cpcteleraAkg.h	2025-01-11 16:57:38
@@ -0,0 +1,38 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2014-2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+
+#ifndef CPCTELERA_ALL_H
+#define CPCTELERA_ALL_H
+
+#include <types.h>
+#include <firmware/firmware.h>
+#include <memutils/memutils.h>
+#include <keyboard/keyboard.h>
+#include <bitarray/bitarray.h>
+#include <sprites/sprites.h>
+#include <strings/strings.h>
+#include <video/videomode.h>
+#include <audio/audioAkg.h>
+#include <random/random.h>
+#include <macros/allmacros.h>
+#include <easytilemaps/easytilemaps.h>
+#include <compression/compression.h>
+#include <loaders/loaders.h>
+
+
+#endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/cpcteleraAkm.h cpctelera-linux-enterprise/cpctelera/src/cpcteleraAkm.h
--- cpctelera-linux-cpc/cpctelera/src/cpcteleraAkm.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/cpcteleraAkm.h	2025-01-11 16:57:38
@@ -0,0 +1,38 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2014-2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+
+#ifndef CPCTELERA_ALL_H
+#define CPCTELERA_ALL_H
+
+#include <types.h>
+#include <firmware/firmware.h>
+#include <memutils/memutils.h>
+#include <keyboard/keyboard.h>
+#include <bitarray/bitarray.h>
+#include <sprites/sprites.h>
+#include <strings/strings.h>
+#include <video/videomode.h>
+#include <audio/audioAkm.h>
+#include <random/random.h>
+#include <macros/allmacros.h>
+#include <easytilemaps/easytilemaps.h>
+#include <compression/compression.h>
+#include <loaders/loaders.h>
+
+
+#endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/cpcteleraAky.h cpctelera-linux-enterprise/cpctelera/src/cpcteleraAky.h
--- cpctelera-linux-cpc/cpctelera/src/cpcteleraAky.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/cpcteleraAky.h	2025-01-11 16:57:39
@@ -0,0 +1,38 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2014-2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+
+#ifndef CPCTELERA_ALL_H
+#define CPCTELERA_ALL_H
+
+#include <types.h>
+#include <firmware/firmware.h>
+#include <memutils/memutils.h>
+#include <keyboard/keyboard.h>
+#include <bitarray/bitarray.h>
+#include <sprites/sprites.h>
+#include <strings/strings.h>
+#include <video/videomode.h>
+#include <audio/audioAky.h>
+#include <random/random.h>
+#include <macros/allmacros.h>
+#include <easytilemaps/easytilemaps.h>
+#include <compression/compression.h>
+#include <loaders/loaders.h>
+
+
+#endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/cpcteleraLW.h cpctelera-linux-enterprise/cpctelera/src/cpcteleraLW.h
--- cpctelera-linux-cpc/cpctelera/src/cpcteleraLW.h	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/cpctelera/src/cpcteleraLW.h	2025-01-11 16:57:38
@@ -0,0 +1,38 @@
+//-----------------------------LICENSE NOTICE------------------------------------
+//  This file is part of CPCtelera: An Amstrad CPC Game Engine
+//  Copyright (C) 2014-2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU Lesser General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//-------------------------------------------------------------------------------
+
+#ifndef CPCTELERA_ALL_H
+#define CPCTELERA_ALL_H
+
+#include <types.h>
+#include <firmware/firmware.h>
+#include <memutils/memutils.h>
+#include <keyboard/keyboard.h>
+#include <bitarray/bitarray.h>
+#include <sprites/sprites.h>
+#include <strings/strings.h>
+#include <video/videomode.h>
+#include <audio/audioLW.h>
+#include <random/random.h>
+#include <macros/allmacros.h>
+#include <easytilemaps/easytilemaps.h>
+#include <compression/compression.h>
+#include <loaders/loaders.h>
+
+
+#endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/firmware/cpct_enableDisableROMs.s cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_enableDisableROMs.s
--- cpctelera-linux-cpc/cpctelera/src/firmware/cpct_enableDisableROMs.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_enableDisableROMs.s	2025-03-03 16:42:00
@@ -18,7 +18,7 @@
 .module cpct_firmware
 
 .include /firmware.s/
-
+.include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Title: Enabling / disabling ROMs
@@ -97,7 +97,7 @@
 ;; -----------------------------------
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC
 .globl _cpct_mode_rom_status
 
 _cpct_enableLowerROM::
@@ -132,5 +132,24 @@
    ld (hl), a                ;; [2] Save new Mode and ROM status for later use if required
 
    ret                       ;; [3] Return
+    .else
 
+.globl _cpct_mode_rom_status
 
+_cpct_enableLowerROM::
+cpct_enableLowerROM_asm::
+
+_cpct_disableLowerROM::
+cpct_disableLowerROM_asm::
+
+_cpct_enableUpperROM::
+cpct_enableUpperROM_asm::
+
+_cpct_disableUpperROM::
+cpct_disableUpperROM_asm::
+
+mrs_modifyROMstatus:
+
+mrs_operation:
+   ret
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/firmware/cpct_reenableFirmware.s cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_reenableFirmware.s
--- cpctelera-linux-cpc/cpctelera/src/firmware/cpct_reenableFirmware.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_reenableFirmware.s	2025-03-03 16:42:25
@@ -25,7 +25,7 @@
 .module cpct_firmware
 
 .include /firmware.s/
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_reenableFirmware
@@ -74,6 +74,7 @@
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
 .equ JP_opcode, 0xC3
 
 _cpct_reenableFirmware::
@@ -83,4 +84,18 @@
    ld (firmware_RST_jp), a    ;; [4] Put JP instruction at 0x0038, to create a jump to the pointer at 0x0039
    ld (firmware_RST_jp+1), hl ;; [5] HL = previous interrupt handler pointer (firmware ROM pointer)
    ei                         ;; [1] Reenable interrupts and return
+   ret                        ;; [3] Return 
+    .else
+
+.equ JP_opcode, 0xC3
+
+_cpct_reenableFirmware::
+cpct_reenableFirmware_asm::
+   di                         ;; [1] Disable interrupts
+   ld a,#0xf5
+   ld hl, #0x1837               ;; [2] A = 0xC3, opcode for JP instruction
+   ld (firmware_RST_jp), a    ;; [4] Put JP instruction at 0x0038, to create a jump to the pointer at 0x0039
+   ld (firmware_RST_jp+1), hl ;; [5] HL = previous interrupt handler pointer (firmware ROM pointer)
+   ei                         ;; [1] Reenable interrupts and return
    ret                        ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/firmware/cpct_removeInterruptHandler.s cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_removeInterruptHandler.s
--- cpctelera-linux-cpc/cpctelera/src/firmware/cpct_removeInterruptHandler.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_removeInterruptHandler.s	2025-03-03 16:42:59
@@ -18,7 +18,7 @@
 .module cpct_firmware
 
 .include /firmware.s/
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_disableFirmware
@@ -128,7 +128,7 @@
 ;; -------------------------------------
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC
 _cpct_disableFirmware::
 cpct_disableFirmware_asm::
 _cpct_removeInterruptHandler::
@@ -141,7 +141,25 @@
    ld   hl, #0xC9FB               ;; [3] FB C9 (take into account little endian) => EI : RET
 
    ld (firmware_RST_jp), hl       ;; [5] Setup new "null interrupt handler" and enable interrupts again
-   ei                             ;; [1] Reenable interrupts
+   ei                             ;; [1]
    ex   de, hl                    ;; [1] HL = Pointer to previous interrupt handler (return value)
 
-   ret                            ;; [3] Return
\ No newline at end of file
+   ret                            ;; [3] Return
+    .else
+
+_cpct_disableFirmware::
+cpct_disableFirmware_asm::
+_cpct_removeInterruptHandler::
+cpct_removeInterruptHandler_asm::
+   di                             ;; [1] Disable interrupts
+   ex   de, hl                    ;; [1] DE = HL (DE saves present pointer to previous interrupt handler)
+
+   ld a,#0xf5
+   ld hl, #0x1837             ;; [2] A = 0xC3, opcode for JP instruction
+   ld (firmware_RST_jp), a    ;; [4] Put JP instruction at 0x0038, to create a jump to the pointer at 0x0039
+   ld (firmware_RST_jp+1), hl ;; [5] HL = previous interrupt handler pointer (firmware ROM pointer)    
+   ei                             ;; [1]
+   ex   de, hl                    ;; [1] HL = Pointer to previous interrupt handler (return value)
+
+   ret                            ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/firmware/cpct_setInterruptHandler.s cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_setInterruptHandler.s
--- cpctelera-linux-cpc/cpctelera/src/firmware/cpct_setInterruptHandler.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/firmware/cpct_setInterruptHandler.s	2025-03-03 16:43:22
@@ -19,7 +19,7 @@
 .module cpct_firmware
 
 .include /firmware.s/
-
+.include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_setInterruptHandler
@@ -102,6 +102,7 @@
 
    ret                                     ;; [3] Return
 
+.if HARDWARE_CPC
 ;;
 ;; Interrupt Handler Safe Wrapper Code. This is the code that
 ;; will be called at the start of the interrupt, and this code
@@ -128,3 +129,30 @@
    pop  af     ;; [3]
    ei          ;; [1] Reenable interrupts
    reti        ;; [4] Return to main program
+
+.else
+
+cpct_safeInterruptHandlerHook::
+   push af     ;; [4] Save all standard registers on the stack
+   push bc     ;; [4]
+   push de     ;; [4]
+   push hl     ;; [4]
+   push ix     ;; [5]
+   push iy     ;; [5]
+    .ifeq ENABLE_1000HZ_IRQ
+   ld   a,#0x30
+   out  (#0xb4),a
+    .endif
+cpct_safeInterruptHandlerCall:   
+   call #0000  ;; [5] Call Interrupt Handler
+
+   pop  iy     ;; [5] Restore all standard registers
+   pop  ix     ;; [5]
+   pop  hl     ;; [3]
+   pop  de     ;; [3]
+   pop  bc     ;; [3]
+   pop  af     ;; [3]
+   ei          ;; [1] Reenable interrupts
+   ret         ;; [3] Return to main program
+   
+.endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard.s cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard.s
--- cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard.s	2025-03-03 16:44:05
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_keyboard
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_scanKeyboard
@@ -69,6 +69,7 @@
 ;; excluding the 3 microseconds from the ret instruction)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
 ;; Keyboard Status Buffer defined in an external file
 .globl _cpct_keyboardStatusBuffer
 
@@ -123,4 +124,32 @@
 
    ei                       ;; [1] Reenable interrupts
 
+   ret                      ;; [3] Return 
+    .else
+
+;; Keyboard Status Buffer defined in an external file
+.globl _cpct_keyboardStatusBuffer
+
+_cpct_scanKeyboard:: 
+cpct_scanKeyboard_asm::     ;; Assembly entry point
+
+   di                       ;; [1] Disable interrupts
+   ld   hl, #_cpct_keyboardStatusBuffer ;; [3] HL Points to the start of the keyboardBuffer, 
+   ld   b,#0x0a
+read_keyb:
+   ld   a,#0x0a
+   sub  b
+   out  (#0xb5),a
+   in   a,(#0xb5)
+   ld   (hl),a
+   in   a,(#0xb6)
+   rrca
+   jr   c,nojoy
+   res  7,(hl)
+nojoy:
+   inc  hl
+   djnz read_keyb
+   ei                       ;; [1] Reenable interrupts
+
    ret                      ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_f.s cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_f.s
--- cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_f.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_f.s	2025-03-03 16:44:32
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_keyboard
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_scanKeyboard_f
@@ -72,6 +72,7 @@
 ;; of the code is, however, ~60% faster than CPCWiki's.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
 ;; Keyboard Status Buffer defined in an external file
 .globl _cpct_keyboardStatusBuffer
 
@@ -181,4 +182,33 @@
 
    ei                       ;; [1] Re-enable interrupts
 
+   ret                      ;; [3] Return 
+    .else
+
+;; Keyboard Status Buffer defined in an external file
+.globl _cpct_keyboardStatusBuffer
+
+_cpct_scanKeyboard_f:: 
+cpct_scanKeyboard_f_asm::   ;; Assembly entry point
+
+   di                       ;; [1] Disable interrupts
+
+   ld   hl, #_cpct_keyboardStatusBuffer ;; [3] HL Points to the start of the keyboardBuffer, 
+   ld   b,#0x0a
+read_keyb:
+   ld   a,#0x0a
+   sub  b
+   out  (#0xb5),a
+   in   a,(#0xb5)
+   ld   (hl),a
+   in   a,(#0xb6)
+   rrca
+   jr   c,nojoy
+   res  7,(hl)
+nojoy:
+   inc  hl
+   djnz read_keyb
+   ei                       ;; [1] Re-enable interrupts
+
    ret                      ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_i.s cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_i.s
--- cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_i.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_i.s	2025-03-03 16:44:59
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_keyboard
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_scanKeyboard_i
@@ -80,6 +80,7 @@
 ;; excluding the 3 microseconds from the ret instruction)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
 ;; Keyboard Status Buffer defined in an external file
 .globl _cpct_keyboardStatusBuffer
 
@@ -130,4 +131,30 @@
    ld   bc, #0xF782         ;; [3] Put again PPI in Output/Output mode for Ports A/C.
    out (c), c               ;; [4]
 
+   ret                      ;; [3] Return 
+    .else
+
+;; Keyboard Status Buffer defined in an external file
+.globl _cpct_keyboardStatusBuffer
+
+_cpct_scanKeyboard_i:: 
+cpct_scanKeyboard_i_asm::     ;; Assembly entry point
+
+   ld   hl, #_cpct_keyboardStatusBuffer ;; [3] HL Points to the start of the keyboardBuffer, 
+   ld   b,#0x0a
+read_keyb:
+   ld   a,#0x0a
+   sub  b
+   out  (#0xb5),a
+   in   a,(#0xb5)
+   ld   (hl),a
+   in   a,(#0xb6)
+   rrca
+   jr   c,nojoy
+   res  7,(hl)
+nojoy:
+   inc  hl
+   djnz read_keyb
+
    ret                      ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_if.s cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_if.s
--- cpctelera-linux-cpc/cpctelera/src/keyboard/cpct_scanKeyboard_if.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/cpct_scanKeyboard_if.s	2025-03-03 16:45:28
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_keyboard
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_scanKeyboard_if
@@ -84,6 +84,7 @@
 ;; of the code is, however, ~60% faster than CPCWiki's.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
 ;; Keyboard Status Buffer defined in an external file
 .globl _cpct_keyboardStatusBuffer
 
@@ -190,3 +191,29 @@
    out (c), c               ;; [4]
 
    ret                      ;; [3] Return
+    .else
+
+;; Keyboard Status Buffer defined in an external file
+.globl _cpct_keyboardStatusBuffer
+
+_cpct_scanKeyboard_if:: 
+cpct_scanKeyboard_if_asm::   ;; Assembly entry point
+
+   ld   hl, #_cpct_keyboardStatusBuffer ;; [3] HL Points to the start of the keyboardBuffer, 
+   ld   b,#0x0a
+read_keyb:
+   ld   a,#0x0a
+   sub  b
+   out  (#0xb5),a
+   in   a,(#0xb5)
+   ld   (hl),a
+   in   a,(#0xb6)
+   rrca
+   jr   c,nojoy
+   res  7,(hl)
+nojoy:
+   inc  hl
+   djnz read_keyb
+
+   ret                      ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/keyboard.h cpctelera-linux-enterprise/cpctelera/src/keyboard/keyboard.h
--- cpctelera-linux-cpc/cpctelera/src/keyboard/keyboard.h	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/keyboard.h	2025-03-03 16:48:01
@@ -15,6 +15,8 @@
 //  You should have received a copy of the GNU Lesser General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //-------------------------------------------------------------------------------
+#define Enterprise
+//#define CPC
 
 //
 //#####################################################################
@@ -49,7 +51,6 @@
 extern   u8 cpct_isKeyPressed     (cpct_keyID key) __z88dk_fastcall;
 extern   u8 cpct_isAnyKeyPressed  ();
 extern   u8 cpct_isAnyKeyPressed_f();
-extern   u8 cpct_getKeypressedAsASCII();
 
 //
 // Array: cpct_keyboardStatusBuffer
@@ -65,17 +66,6 @@
 extern u8 cpct_keyboardStatusBuffer[10];
 
 //
-// Array: cpct_keyID_to_ASCII_table
-//
-//    80-keys table for converting each <cpct_keyID> to ASCII value. These are only
-// 80 bytes, which are 80 ASCII values, each one for each key, ordered by 8-byte
-// lines (10 total lines) and 8 columns (keys) per line. This is the same order
-// in which <cpct_scanKeyboard> scans the keyboard and fills-in the 
-// <cpct_keyboardStatusBuffer>.
-//
-extern u8 cpct_keyID_to_ASCII_table[80];
-
-//
 // Enum: cpct_keyID
 // 
 //    Enumerated type with symbols for all the 80 possible Key/Joy definitions.
@@ -157,6 +147,7 @@
 //  Table 1. cpct_keyIDs defined for each possible key, ordered by FKCs
 // (end)
 //
+#ifdef CPC
 enum cpct_e_keyID
 {
   // Matrix Line 00h
@@ -266,5 +257,103 @@
   Joy0_Fire3       = (i16)0x4009,
   Key_Del          = (i16)0x8009
 };
+#endif
+#ifdef Enterprise
+enum cpct_e_keyID
+{
+  // Matrix Line 0x00
+  Key_N            = (i16)0x0100,  // Bit 0 (01h) => | 0000 0001 |
+  Key_BackSlash    = (i16)0x0200,  // Bit 1 (02h) => | 0000 0010 |
+  Key_B            = (i16)0x0400,  // Bit 2 (04h) => | 0000 0100 |
+  Key_C            = (i16)0x0800,  // Bit 3 (08h) => | 0000 1000 |
+  Key_V            = (i16)0x1000,  // Bit 4 (10h) => | 0001 0000 |
+  Key_X            = (i16)0x2000,  // Bit 5 (20h) => | 0010 0000 |
+  Key_Z            = (i16)0x4000,  // Bit 6 (40h) => | 0100 0000 |
+  Joy0_Fire1       = (i16)0x8000,  // Bit 7 (80h) => | 1000 0000 |
+  // Matrix Line 0x01
+  Key_H            = (i16)0x0101,
+  Key_CapsLock     = (i16)0x0201,
+  Key_G            = (i16)0x0401,
+  Key_D            = (i16)0x0801,
+  Key_F            = (i16)0x1001,
+  Key_S            = (i16)0x2001,
+  Key_A            = (i16)0x4001,
+  Joy0_Up          = (i16)0x8001,
+  // Matrix Line 0x02
+  Key_U            = (i16)0x0102,
+  Key_Q            = (i16)0x0202,
+  Key_Y            = (i16)0x0402,
+  Key_R            = (i16)0x0802,
+  Key_T            = (i16)0x1002,
+  Key_E            = (i16)0x2002,
+  Key_W            = (i16)0x4002,
+  Key_Tab          = (i16)0x8002,
+  Joy0_Down        = (i16)0x8002,
+  // Matrix Line 0x03
+  Key_7            = (i16)0x0103,
+  Key_1            = (i16)0x0203,
+  Key_6            = (i16)0x0403,
+  Key_4            = (i16)0x0803,
+  Key_5            = (i16)0x1003,
+  Key_3            = (i16)0x2003,
+  Key_2            = (i16)0x4003,
+  Joy0_Left        = (i16)0x8003,
+  // Matrix Line 0x04
+  Key_F4           = (i16)0x0104,
+  Key_F8           = (i16)0x0204,
+  Key_F3           = (i16)0x0404,
+  Key_F6           = (i16)0x0804,
+  Key_F5           = (i16)0x1004,
+  Key_F7           = (i16)0x2004,
+  Key_F2           = (i16)0x4004,
+  Key_F1           = (i16)0x8004,		
+  Joy0_Right       = (i16)0x8004,		
+  // Matrix Line 0x05
+  Key_8            = (i16)0x0105,
+  Key_Un1          = (i16)0x0205,
+  Key_9            = (i16)0x0405,
+  Key_Hyphen       = (i16)0x0805,
+  Key_0            = (i16)0x1005,
+  Key_Caret        = (i16)0x2005,
+  Key_Del          = (i16)0x4005,
+  Joy1_Fire        = (i16)0x8005,		
+  // Matrix Line 0x06
+  Key_J            = (i16)0x0106,
+  Key_Un2          = (i16)0x0206,
+  Key_K            = (i16)0x0406,
+  Key_SemiColon    = (i16)0x0806,
+  Key_L            = (i16)0x1006,
+  Key_Colon        = (i16)0x2006,
+  Key_OpenBracket  = (i16)0x4006,
+  Joy1_Up          = (i16)0x8006,
+  // Matrix Line 0x07
+  Key_Esc          = (i16)0x0107,
+  Key_CursorDown   = (i16)0x0207,
+  Key_CursorRight  = (i16)0x0407,
+  Key_CursorUp     = (i16)0x0807,
+  Key_Control      = (i16)0x1007,
+  Key_CursorLeft   = (i16)0x2007,
+  Key_Enter        = (i16)0x4007,
+  Joy1_Down        = (i16)0x8007,
+  // Matrix Line 0x08
+  Key_M            = (i16)0x0108,
+  Key_Clr          = (i16)0x0208,
+  Key_Comma        = (i16)0x0408,
+  Key_Slash        = (i16)0x0808,
+  Key_Dot          = (i16)0x1008,
+  Key_Shift        = (i16)0x2008,
+  Key_Space        = (i16)0x4008,
+  Joy1_Left        = (i16)0x8008,
+  // Matrix Line 0x09
+  Key_I            = (i16)0x0109,
+  Key_Un3          = (i16)0x0209,
+  Key_O            = (i16)0x0409,
+  Key_At           = (i16)0x0809,
+  Key_P            = (i16)0x1009,
+  Key_CloseBracket = (i16)0x2009,
+  Key_Un4          = (i16)0x4009,
+  Joy1_Right       = (i16)0x8009
+};
 
-#endif
+#endif
+#endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/keyboard/keyboard.h.s cpctelera-linux-enterprise/cpctelera/src/keyboard/keyboard.h.s
--- cpctelera-linux-cpc/cpctelera/src/keyboard/keyboard.h.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/keyboard/keyboard.h.s	2025-03-03 16:48:30
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_keyboard
-
+ .include "../CPCteleraHW.src"
 ;;
 ;; Constant: Key Definitions (asm)
 ;;
@@ -72,7 +72,7 @@
 ;;  Table 1. KeyCodes defined for each possible key, ordered by KeyCode
 ;; (end)
 ;;
-
+    .if HARDWARE_CPC 
 ;; Matrix Line 0x00
 Key_CursorUp     = #0x0100  ;; Bit 0 (01h) => | 0000 0001 |
 Key_CursorRight  = #0x0200  ;; Bit 1 (02h) => | 0000 0010 |
@@ -169,4 +169,99 @@
 Joy0_Fire1       = #0x1009
 Joy0_Fire2       = #0x2009
 Joy0_Fire3       = #0x4009
-Key_Del          = #0x8009
\ No newline at end of file
+Key_Del          = #0x8009
+
+    .else
+;; Matrix Line 0x00
+Key_N            = #0x0100  ;; Bit 0 (01h) => | 0000 0001 |
+Key_BackSlash    = #0x0200  ;; Bit 1 (02h) => | 0000 0010 |
+Key_B            = #0x0400  ;; Bit 2 (04h) => | 0000 0100 |
+Key_C            = #0x0800  ;; Bit 3 (08h) => | 0000 1000 |
+Key_V            = #0x1000  ;; Bit 4 (10h) => | 0001 0000 |
+Key_X            = #0x2000  ;; Bit 5 (20h) => | 0010 0000 |
+Key_Z            = #0x4000  ;; Bit 6 (40h) => | 0100 0000 |
+Joy0_Fire1       = #0x8000  ;; Bit 7 (80h) => | 1000 0000 |
+;; Matrix Line 0x01
+Key_H            = #0x0101
+Key_CapsLock     = #0x0201
+Key_G            = #0x0401
+Key_D            = #0x0801
+Key_F            = #0x1001
+Key_S            = #0x2001
+Key_A            = #0x4001
+Joy0_Up          = #0x8001
+;; Matrix Line 0x02
+Key_U            = #0x0102		        
+Key_Q            = #0x0202      
+Key_Y            = #0x0402     
+Key_R            = #0x0802      
+Key_T            = #0x1002
+Key_E            = #0x2002             
+Key_W            = #0x4002
+Key_Tab          = #0x8002
+Joy0_Down        = #0x8002		
+;; Matrix Line 0x03
+Key_7            = #0x0103		     
+Key_1            = #0x0203        
+Key_6            = #0x0403                
+Key_4            = #0x0803
+Key_5            = #0x1003         
+Key_3            = #0x2003             
+Key_2            = #0x4003             
+Joy0_Left        = #0x8003		
+;; Matrix Line 0x04
+Key_F4           = #0x0104
+Key_F8           = #0x0204
+Key_F3           = #0x0404
+Key_F6           = #0x0804
+Key_F5           = #0x1004
+Key_F7           = #0x2004
+Key_F2           = #0x4004
+Key_F1           = #0x8004		
+Joy0_Right       = #0x8004		
+;; Matrix Line 0x05
+Key_8            = #0x0105
+Key_Un1          = #0x0205
+Key_9            = #0x0405
+Key_Hyphen       = #0x0805
+Key_0            = #0x1005
+Key_Caret        = #0x2005
+Key_Del          = #0x4005
+Joy1_Fire        = #0x8005		
+;; Matrix Line 0x06
+Key_J            = #0x0106
+Key_Un2          = #0x0206
+Key_K            = #0x0406
+Key_SemiColon    = #0x0806
+Key_L            = #0x1006
+Key_Colon        = #0x2006
+Key_OpenBracket  = #0x4006
+Joy1_Up          = #0x8006
+;; Matrix Line 0x07
+Key_Esc          = #0x0107
+Key_CursorDown   = #0x0207
+Key_CursorRight  = #0x0407
+Key_CursorUp     = #0x0807
+Key_Control      = #0x1007
+Key_CursorLeft   = #0x2007
+Key_Enter        = #0x4007
+Joy1_Down        = #0x8007
+;; Matrix Line 0x08
+Key_M            = #0x0108
+Key_Clr          = #0x0208
+Key_Comma        = #0x0408
+Key_Slash        = #0x0808
+Key_Dot          = #0x1008
+Key_Shift        = #0x2008
+Key_Space        = #0x4008
+Joy1_Left        = #0x8008
+;; Matrix Line 0x09
+Key_I            = #0x0109
+Key_Un3          = #0x0209
+Key_O            = #0x0409
+Key_At           = #0x0809
+Key_P            = #0x1009
+Key_CloseBracket = #0x2009
+Key_Un4          = #0x4009
+Joy1_Right       = #0x8009		
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/loaders/cpct_miniload.asm cpctelera-linux-enterprise/cpctelera/src/loaders/cpct_miniload.asm
--- cpctelera-linux-cpc/cpctelera/src/loaders/cpct_miniload.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/loaders/cpct_miniload.asm	2025-03-03 16:48:52
@@ -163,7 +163,8 @@
 ;; created on 2018/08/20 by <CNGSoft at http://cngsoft.no-ip.org/index.htm>.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+ .include "../../CPCteleraHW.src" 
+    .if HARDWARE_CPC 
 ; IX=^OFFSET,DE=LENGTH; IX+++,DE---,H=$FF?,ABCLF!,CF=OK?
    di                ;; Disable interrupts before starting
 
@@ -276,3 +277,4 @@
    ei                ;; Enable interrupts again
    
 ;; Return instruction provided by bindings
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/memutils/cpct_pageMemory.asm cpctelera-linux-enterprise/cpctelera/src/memutils/cpct_pageMemory.asm
--- cpctelera-linux-cpc/cpctelera/src/memutils/cpct_pageMemory.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/memutils/cpct_pageMemory.asm	2025-03-03 16:49:27
@@ -17,7 +17,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_memutils
-
+.include "../../CPCteleraHW.src" 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_pageMemory
@@ -95,11 +95,53 @@
 ;; (end code)
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+.if HARDWARE_CPC
 pageMemory:
   or   #0xC0		    ;; [2] Use Gate Array function 3: Ram Banking (0b11-------).
                     ;;     Rest of A register holds our desired memory bank configuration
   ld   bc, #0x7F00  ;; [3] We are going to use port 0x7F (Gate Array, for memory configuration)
   out  (c), a       ;; [4] Submit this order to Gate Array
   
-  ret               ;; [3] Then Return
\ No newline at end of file
+  ret               ;; [3] Then Return
+.else
+pageMemory:
+    and     #0x07
+    push    hl
+    add     a,a
+    add     a,a
+    add     a,#<cpcbank
+    ld      l,a
+    adc     a,#>cpcbank
+    sub     l
+    ld      h,a
+    ld      b,#0x00
+    ld      c,(hl)
+    di
+    ld      a,(bc)
+    out     (#0xb0),a
+    inc     hl
+    ld      c,(hl)
+    ld      a,(bc)
+    out     (#0xb1),a
+    inc     hl
+    ld      c,(hl)
+    ld      a,(bc)
+    out     (#0xb2),a
+    inc     hl
+    ld      c,(hl)
+    ld      a,(bc)
+    ei
+    out     (#0xb3),a
+    pop     hl
+    ret
+
+cpcbank:
+    .db #0x00,#0x01,#0x02,#0x03
+    .db #0x00,#0x01,#0x02,#0x07
+    .db #0x04,#0x05,#0x06,#0x07
+    .db #0x00,#0x03,#0x02,#0x07
+    .db #0x00,#0x04,#0x02,#0x03
+    .db #0x00,#0x05,#0x02,#0x03
+    .db #0x00,#0x06,#0x02,#0x03
+    .db #0x00,#0x07,#0x02,#0x03
+.endif
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM0.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM0.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM0.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM0.asm	2025-03-03 16:49:57
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawCharM0
@@ -108,7 +108,7 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM0_inner_asm
-
+    .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status)  ;; [4] A = mode_rom_status (present value)
@@ -128,4 +128,20 @@
    out   (c), a                      ;; [3] GA Command: Set Video Mode and ROM status (100)
    ei                                ;; [1] Enable interrupts
 
-;; Restore IX and Return provided by bindings
\ No newline at end of file
+;; Restore IX and Return provided by bindings
+    .else
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a
+        
+        ld      a, e                       ;; [1] A = ASCII Value of the character
+        push    iy
+        call    cpct_drawCharM0_inner_asm  ;; [828/837] Does the actual drawing to screen
+        pop     iy
+endDraw:
+        pop     af
+        ei
+        out     (#0xb0),a
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM0_inner.s cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM0_inner.s
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM0_inner.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM0_inner.s	2025-03-03 16:50:19
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;
 ;; Include constants and general values
 ;;
@@ -84,7 +84,7 @@
 ;; -------------------------------------
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC 
 cpct_drawCharM0_inner_asm::
    ;; Calculate the memory address where the 8 bytes defining the character appearance 
    ;; ... start (IX = 0x3800 + 8*ASCII value). char0_ROM_address = 0x3800
@@ -151,4 +151,71 @@
 ;; possible combinations with 2 pixels and 2 colours: (00, 01, 10, 11 == BG-BG, BG-FG, FG-BG, FG-FG)
 ;; We reserve here 4 bytes that will be filled in by <cpct_setDrawCharM0>
 ;;
-dc_2pxtableM0:: .db 0x00, 0x40, 0x80, 0xC0   ;; Default colours BG=0, FG=1
\ No newline at end of file
+dc_2pxtableM0:: .db 0x00, 0x40, 0x80, 0xC0   ;; Default colours BG=0, FG=1
+    .else
+
+cpct_drawCharM0_inner_asm::
+   ;; Calculate the memory address where the 8 bytes defining the character appearance 
+   ;; ... start (IX = 0x3800 + 8*ASCII value). char0_ROM_address = 0x3800
+        ld      e, a     ;; [1] \ That will be the final memory address where the definition starts
+        ld      a,(#0x0016)
+        or      e
+        ld__ixl_a      ;; [2] and save it to IXL = |edcba|000|
+        ld      a,(#0x0017)
+        ld__ixh_a      ;; [2] Save it to IXH = |00111hgf|
+   ;; Now IX = |edcba|000||00111hgf| = 0x3800 + 8*ASCII
+        ld__iyh    #0x08
+        ld    bc, #dc_2pxtableM0    ;; [3] BC points to the 2 1-bit pixels to 2 4-bit pixels conversion table
+
+   ;; Draw next line from the character to the screen
+nextline:
+        ex    de, hl      ;; [1] Put Destination pointer into DE (it is in HL)
+        ld     a, (ix)    ;; [5] A = Next Character pixel line definition 
+                     ;; .... (8 bits defining 0 = background colour, 1 = foreground)
+   ;; Copy the 4 bytes that compose the complete pixel line
+   ;; repeating the code for each pair of pixels to maximize speed
+.rept 4
+        ;; Convert next 2-bits into 1 byte with 2 pixels in screen pixel format
+        ;; and copy it to (DE) which is next screen location
+        ld    hl, #0      ;; [3] HL = 0
+        rlca              ;; [1] /    Put the 2 leftmost bits of A into the two 
+        rl    l           ;; [2] | ...rightmost bits of L. This is the combination for the
+        rlca              ;; [1] | ...next 2 pixels (BG-BG, BG-FG, FG-BG, FG-FG). We use it
+        rl    l           ;; [2] \ ...as index for the dc_2pxtableM0 which gets the actual pixel values.
+        add   hl, bc      ;; [3] HL = BC + L (2pxtableM0 + Index = HL Points to the converted pixel values)
+        ldi               ;; [5] Copy 2 pixels to the screen, incrementing DE at the same time
+        inc   bc          ;; [2] BC is decremented by LDI but we want it to keep pointing to the table, so we add 1 again
+.endm
+
+endpixelline:
+    
+   ;; Move to next pixel-line definition of the character
+        ex      de,hl
+        ld      de,#0x0080
+        add     ix,de   ;; [2] Next pixel Line (characters are 8-byte-aligned in memory, 
+        ex      de,hl
+        dec__iyh
+        ret   z           ;; [2/4] If L % 8 == 0, we have finished drawing the character, else, proceed to next line
+
+   ;; Prepare to copy next line 
+   ;;  -- Move DE pointer to the next pixel line on the video memory
+   ;; (We save new calculations on HL, because it will be exchanged with DE at the start of nextline: loop)
+   ld    hl, #0x800-4      ;; [3] | Next pixel line is 0x800 bytes away in standard video modes
+   add   hl, de            ;; [3] | ..but DE has already being incremented 4 times. So add 0x800-4 to
+                           ;;       ..DE to make it point to the start of the next pixel line in video memory
+   ;; Check if new address has crossed character boundaries (every 8 pixel lines)
+   ld     a, h             ;; [1] A = H (top 8 bits of video memory address)
+   and   #0x38             ;; [2] We check if we have crossed memory boundary (every 8 pixel lines)
+   jr    nz, nextline      ;; [2/3]  by checking the 4 bits that identify present memory line. 
+                           ;; .... If 0, we have crossed boundaries
+boundary_crossed:
+   ld    de, #0xC050       ;; [3] | HL = HL + 0xC050: Relocate DE pointer to the start of the next pixel line in video memory
+   add   hl, de            ;; [3] \ (Remember that HL and DE will be exchanged at the start of nextline:)
+   jr    nextline          ;; [3] Jump to continue with next pixel line
+
+;; Conversion table from 2 1-bit pixels to mode 0 2 4-bit pixels. Essentially, there are 4
+;; possible combinations with 2 pixels and 2 colours: (00, 01, 10, 11 == BG-BG, BG-FG, FG-BG, FG-FG)
+;; We reserve here 4 bytes that will be filled in by <cpct_setDrawCharM0>
+;;
+dc_2pxtableM0:: .db 0x00, 0x40, 0x80, 0xC0   ;; Default colours BG=0, FG=1
+        .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1.asm	2025-03-03 16:50:39
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawCharM1
@@ -116,7 +116,7 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM1_inner_asm
-
+    .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status)  ;; [4] A = mode_rom_status (present value)
@@ -136,4 +136,20 @@
    out   (c), a                      ;; [3] GA Command: Set Video Mode and ROM status (100)
    ei                                ;; [1] Enable interrupts
 
-;; Restore IX and Return provided by bindings
\ No newline at end of file
+;; Restore IX and Return provided by bindings
+    .else
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a
+
+        push    iy
+        ld      a, e                       ;; [1] A = ASCII Value of the character
+        call    cpct_drawCharM1_inner_asm  ;; [828/837] Does the actual drawing to screen
+        pop     iy
+endDraw:
+        pop     af
+        ei
+        out     (#0xb0),a
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1_f.s cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1_f.s
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1_f.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1_f.s	2025-03-03 16:51:25
@@ -27,7 +27,7 @@
 ;; Include constants and general values
 ;;
 .include /strings.s/
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawCharM1_f
@@ -379,6 +379,7 @@
 
    ;; Make HL point to the starting byte of the desired character,
    ;; That is ==> HL = 8*(ASCII code) + char0_ROM_address 
+    .if HARDWARE_CPC
 dcm1f_asciiHL:
    xor   a                     ;; [ 4] A = 0
    or    #0                    ;; [ 7] A = ASCII Value and Resetting carry flag (#0 is a placeholder 
@@ -401,7 +402,21 @@
    ld    b, #GA_port_byte      ;; [ 7] B = Gate Array Port (0x7F)
    di                          ;; [ 4] Disable interrupts to prevent firmware from taking control while Lower ROM is enabled
    out (c), a                  ;; [12] GA Command: Set Video Mode and ROM status (100)
-
+    .else
+.include "macros/cpct_undocumentedOpcodes.h.s"
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a 
+        ld      hl,(#0x0016) 
+dcm1f_asciiHL:
+        ld      a,l
+        or      #0x00
+        ld      l,a
+        push    iy
+        ld__iyh    #0x08 
+    .endif
    ;;
    ;; Transform character definition into colour values for video memory and copy
    ;; them to the video position given at DE. Each character definition has 8 pixel-lines (8 bytes)
@@ -474,6 +489,7 @@
    or    b                     ;; [ 4] Mix background and foreground colour values into A
    ld (de), a                  ;; [ 7] Store final calculated colour values into present video memory byte
 
+    .if HARDWARE_CPC
    ;; We have finished with this pixel-line, check if there are
    ;; more pixel-lines to continue or end drawing
    inc   l                     ;; [ 4] Next pixel Line (characters are 8-byte-aligned in memory, 
@@ -481,6 +497,11 @@
    ld    a, l                  ;; [ 4] IF next pixel line corresponds to a new character 
                                ;; .... (this is, we have finished drawing our character),
    and   #0x07                 ;; [ 7] ... then L % 8 == 0, as it is 8-byte-aligned. 
+    .else
+        ld      bc,#0x0080
+        add     hl,de
+        dec__iyh
+    .endif
    jp    z, dcm1f_end_printing ;; [10] IF L%8 = 0, we have finished drawing the character, else, proceed to next line
 
    ;; Prepare to copy next line 
@@ -502,10 +523,16 @@
    jp  dcm1f_nextPixelLine     ;; [10] Jump to continue with next pixel line
 
 dcm1f_end_printing:
+    .if HARDWARE_CPC
    ;; After finishing character printing, restore previous ROM and Interrupts status
    ld    a, (_cpct_mode_rom_status);; [13] A = mode_rom_status (present saved value)
    ld    b, #GA_port_byte      ;; [ 7] B = Gate Array Port (0x7F)
    out (c), a                  ;; [12] GA Command: Set Video Mode and ROM status (100)
    ei                          ;; [ 4] Enable interrupts
-
+    .else
+        pop     iy
+        pop     af
+        ei
+        out     (#0xb0),a 
+    .endif
    ret                         ;; [10] Return
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1_inner.s cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1_inner.s
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM1_inner.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM1_inner.s	2025-03-03 16:51:55
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"    
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawCharM1_inner_asm
@@ -79,7 +79,7 @@
 ;; -------------------------------------
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC 
 cpct_drawCharM1_inner_asm::
    ;; Calculate the memory address where the 8 bytes defining the character appearance 
    ;; ... start (BC = 0x3800 + 8*ASCII value). char0_ROM_address = 0x3800. 
@@ -159,3 +159,82 @@
 ;; to actual pixel values and then render them to screen
 cpct_char2pxM1:: .ds 16
 char2px = cpct_char2pxM1   ;; Alias for brevity
+        .else
+
+    .include "macros/cpct_undocumentedOpcodes.h.s"
+cpct_drawCharM1_inner_asm::
+   ;; Calculate the memory address where the 8 bytes defining the character appearance 
+   ;; ... start (BC = 0x3800 + 8*ASCII value). char0_ROM_address = 0x3800. 
+   ;; ASCII value is in A=|hgfedcba|
+        ld      bc,(#0x0016)
+        or      c
+        ld      c, a        ;; [1] C = A, so that BC points to the start of the character definition in ROM memory
+   ;; Now BC = |edcba|000||00111hgf| = 0x3800 + 8*ASCII
+        ld__iyh    #0x08
+
+nextrow:
+   ;; HL holds destination video memory address where to draw next
+   ;; Lets put it on DE and use HL to point to the conversion table
+   ex    de, hl       ;; [1] DE points to video memory, HL is free
+
+   ;; Draw first 4 pixels (1st byte) of the row to the screen
+   ld    hl, #char2px ;; [3] HL points to char2pixels conversion table
+   ld     a, (bc)     ;; [2] Get current row definition to extract the high nibble, which defines first 4 pixels
+   rrca               ;; [1] / Switch both nibbles of A. We want to use the high nibble (4 highest bits)
+   rrca               ;; [1] | as a value to be added to the base address of the char2px table (now in HL)
+   rrca               ;; [1] | to find the actual conversion to pixels.
+   rrca               ;; [1] \ A = |abcdefgh| >>> A' = |efghabcd| 
+   and  #0x0F         ;; [2] A'' = |0000abcd| (Leave only the 4 highest bits of A as a 0-15 number)
+   add    l           ;; [1] /
+   ld     l, a        ;; [1] | HL' = HL + A  
+   adc    h           ;; [1] | We add the highest nibble of A to HL to get the first 4 pixel values to be
+   sub    l           ;; [1] | drawn to the screen (the first of two bytes to be written)
+   ld     h, a        ;; [1] \
+   ld     a, (hl)     ;; [2] / Write first 4 pixels to the screen and increment destination pointer to leave
+   ld  (de), a        ;; [2] | it ready for the next 4 pixels.
+   inc   de           ;; [2] \ (DE) <- (HL) : DE++
+
+   ;; Draw second 4 pixels (2nd byte) of the row to the screen
+   ld    hl, #char2px ;; [3] HL points to char2pixels conversion table again
+   ld     a, (bc)     ;; [2] Get current row definition again, but this time to extract low nibble, defining next 4 pixels
+   and  #0x0F         ;; [2] A = |abcdefgh| >>> A' = |0000efgh| (Leave only lowest nibble as a 0-15 value)
+   add    l           ;; [1] / 
+   ld     l, a        ;; [1] | HL' = HL + A  
+   adc    h           ;; [1] | We add the lowest nibble of A to HL to get the next 4 pixel values to be
+   sub    l           ;; [1] | drawn to the screen (the second of two bytes to be written)
+   ld     h, a        ;; [1] \
+   ld     a, (hl)     ;; [2] / Write next 4 pixels to the screen 
+   ld  (de), a        ;; [2] \ (DE) <- (HL)
+
+endpixelline:
+   ;; Move to next pixel-line definition of the character
+        ld      hl,#0x0080
+        add     hl,bc
+        ld      b,h
+        ld      c,l
+        dec__iyh        
+        ret   z            ;; [2/4] If C % 8 == 0, we have finished drawing the character, else, proceed to next line
+
+   ;; Prepare to copy next line 
+   ;;  -- Move DE pointer to the next pixel line on the video memory
+   ;; (We save new calculations on HL, because it will be exchanged with DE at the start of nextrow: loop)
+   ld    hl, #0x800-1 ;; [3] | Next pixel line is 0x800 bytes away in standard video modes
+   add   hl, de       ;; [3] | ..but DE has already being incremented by 1. So add 0x800-1 to
+                      ;;       ..DE to make it point to the start of the next pixel line in video memory
+   ;; Check if new address has crossed character boundaries (every 8 pixel lines)
+   ld     a, h        ;; [1] A = H (top 8 bits of video memory address)
+   and   #0x38        ;; [2] We check if we have crossed memory boundary (every 8 pixel lines)
+   jr    nz, nextrow  ;; [2/3]  by checking the 4 bits that identify present memory line. 
+                      ;; .... If 0, we have crossed boundaries
+boundary_crossed:
+   ld    de, #0xC050  ;; [3] | HL = HL + 0xC050: Relocate DE pointer to the start of the next pixel line in video memory
+   add   hl, de       ;; [3] \ (Remember that HL and DE will be exchanged at the start of nextrow:)
+   jr    nextrow      ;; [3] Jump to continue with next pixel line
+
+;; Character To Pixels Definition conversion table.
+;; This table is set up with the 16 combinations for pixel values using the current 
+;; PEN/PAPER selected configuration. This is used to convert the character definition
+;; to actual pixel values and then render them to screen
+cpct_char2pxM1:: .ds 16
+char2px = cpct_char2pxM1   ;; Alias for brevity
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM2.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM2.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM2.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM2.asm	2025-03-03 16:52:12
@@ -82,7 +82,8 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM2_inner_asm
-
+ .include "../../CPCteleraHW.src"   
+     .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status)  ;; [4] A = mode_rom_status (present value)
@@ -102,4 +103,19 @@
    out   (c), a                      ;; [3] GA Command: Set Video Mode and ROM status (100)
    ei                                ;; [1] Enable interrupts
 
-   ret                               ;; [3] Return to caller
\ No newline at end of file
+   ret                               ;; [3] Return to caller
+    .else
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a
+        
+        ld     a, e                       ;; [1] A = ASCII Value of the character
+        call   cpct_drawCharM2_inner_asm  ;; [828/837] Does the actual drawing to screen
+        
+endDraw:
+        pop     af
+        ei
+        out     (#0xb0),a
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM2_inner.s cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM2_inner.s
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawCharM2_inner.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawCharM2_inner.s	2025-03-03 16:52:38
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawCharM2_inner_asm
@@ -81,7 +81,7 @@
 ;; (end code)  
 ;;    FG: Foreground, BG: Background
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+     .if HARDWARE_CPC 
 ;; Global address of cpct drawCharM2 inner modifiable code. Will be used by 
 ;; cpct_setdrawCharM2 to modify the code for drawing with different colours
 cpct_charm2imc == nextrow
@@ -136,3 +136,59 @@
    adc    h          ;; [1] |
    ld     h, a       ;; [1] \
    jr    nextrow     ;; [3] Jump to continue with next pixel line
+    .else
+
+;; Global address of cpct drawCharM2 inner modifiable code. Will be used by 
+;; cpct_setdrawCharM2 to modify the code for drawing with different colours
+cpct_charm2imc == nextrow
+
+cpct_drawCharM2_inner_asm::
+   ;; Calculate the memory address where the 8 bytes defining the character appearance 
+   ;; ... start (DE = 0x3800 + 8*ASCII value). char0_ROM_address = 0x3800. 
+   ;; ASCII value is in A=|hgfedcba|
+        ld      de,(#0x0016)
+        or      e
+        ld      e, a       ;; [1] C = A, so that DE points to the start of the character definition in ROM memory
+   ;; Now DE = |edcba|000||00111hgf| = 0x3800 + 8*ASCII
+
+   ld     bc, #0x0808   ;; [3] B = Counter for the 8 lines of the character to be copied
+                        ;;     C = Used later on to increment H by adding 8 after each pixel line
+nextrow:
+   ;; Next code gets modified by cpct_setDrawCharM2. When drawing video-inverted a CPL (0x2F) is inserted
+   ;; between the two LDs that move the byte from DE to HL. When drawing all background or all foreground, 
+   ;; a direct #00 or #FF insertion is performed
+   ;; --------- Start of self-modifyiable code block
+   ld    a, (de)  ;; [2] Copy 1 Character Line to Screen (DE -> HL)
+   nop            ;; [1]  -- When painting in Foreground Colour, we do nothing
+                  ;;      -- When painting Background Colour (inverted mode) this gets modified to a CPL (0x2F)
+   ld (hl), a     ;; [2]
+   ;; --------- End of self-modifyiable code block
+
+   ld       a,e
+   add      a,#0x80
+   ld       e,a
+   adc      a,d
+   sub      e
+   ld       d,a
+   dec   b        ;; [1] --B (One less line of the character to be drawn)
+   ret   z        ;; [2/4] IF B=0, end up printing, and return (all lines have been copied)
+
+nextpixelline:
+   ;; Prepare to copy next line 
+   ;;  -- Move HL pointer to the next pixel line on the video memory
+   ld     a, h       ;; [1] /
+   add    c          ;; [1] | HL += 0x800 (Adding 8 to H as 00 is to be added to L)
+   ld     h, a       ;; [1] \
+   ;; Check if new address has crossed character boundaries (every 8 pixel lines)
+   and   #0x38       ;; [2] We check if we have crossed memory boundary (every 8 pixel lines)
+   jr    nz, nextrow ;; [2/3]  by checking the 4 bits that identify present memory line. 
+                     ;; .... If 0, we have crossed boundaries
+boundary_crossed:
+   ld     a, #0x50   ;; [2] / 
+   add    l          ;; [1] | HL = HL + 0xC050 
+   ld     l, a       ;; [1] |  Relocate HL pointer to the start of the next pixel line in video memory
+   ld     a, #0xC0   ;; [2] |
+   adc    h          ;; [1] |
+   ld     h, a       ;; [1] \
+   jr    nextrow     ;; [3] Jump to continue with next pixel line
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM0.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM0.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM0.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM0.asm	2025-03-03 16:53:02
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawStringM0
@@ -117,7 +117,7 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM0_inner_asm
-
+    .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status) ;; [4] A = mode_rom_status (present value)
@@ -152,3 +152,39 @@
    ei                                ;; [1] Enable interrupts
 
 ;; IX/IY Restore and Return provided by bindings
+    .else
+   ;; Enable Lower ROM during char copy operation, with interrupts disabled 
+   ;; to prevent firmware messing things up
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a 
+   jr    firstChar                  ;; [3] Jump to first char (Saves 1 jr back every iteration)
+
+nextChar:
+   ;; Draw next character
+        push    iy
+        push    hl                         ;; [4] Save HL
+        call    cpct_drawCharM0_inner_asm  ;; [5 + 824/832] Draws the next character
+        pop     hl                         ;; [3] Recover HL 
+        pop     iy
+
+   ;; Increment Pointers
+   ld    de, #4                     ;; [3] /
+   add   hl, de                     ;; [3] | HL += 4 (point to next position in video memory, 8 pixels to the right)
+   inc   iy                         ;; [3] IX += 1 (point to next character in the string)
+
+firstChar:
+   ld     a, (iy)                   ;; [5] A = next character from the string
+   or     a                         ;; [1] Check if A = 0
+   jr    nz, nextChar               ;; [2/3] if A != 0, A is next character, draw it, else end
+
+endstring:
+   ;; After finishing character drawing, restore previous ROM and Interrupts status
+        pop     af
+        ei
+        out     (#0xb0),a 
+
+;; IX/IY Restore and Return provided by bindings
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM1.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM1.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM1.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM1.asm	2025-03-03 16:53:25
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawStringM1
@@ -122,7 +122,7 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM1_inner_asm
-
+    .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status) ;; [4] A = mode_rom_status (present value)
@@ -157,3 +157,38 @@
    ei                                ;; [1] Enable interrupts
 
 ;; IY Restore and Return provided by bindings
+    .else
+   ;; Enable Lower ROM during char copy operation, with interrupts disabled 
+   ;; to prevent firmware messing things up
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a 
+
+   jr    firstChar                  ;; [3] Jump to first char (Saves 1 jr back every iteration)
+
+nextChar:
+   ;; Draw next character
+        push    iy
+        push    hl                         ;; [4] Save HL
+        call    cpct_drawCharM1_inner_asm  ;; [5 + 458/466] Draws the next character
+        pop     hl                         ;; [3] Recover HL 
+        pop     iy
+   ;; Increment Pointers
+        inc     hl                         ;; [2] /
+        inc     hl                         ;; [2] | HL += 2 (point to next position in video memory, 8 pixels to the right)
+        inc     iy                         ;; [3] IX += 1 (point to next character in the string)
+
+firstChar:
+        ld      a, (iy)                   ;; [5] A = next character from the string
+        or      a                         ;; [1] Check if A = 0
+        jr      nz, nextChar               ;; [2/3] if A != 0, A is next character, draw it, else end
+
+endstring:
+   ;; After finishing character drawing, restore previous ROM and Interrupts status
+        pop     af
+        ei
+        out     (#0xb0),a 
+;; IY Restore and Return provided by bindings
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM2.asm cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM2.asm
--- cpctelera-linux-cpc/cpctelera/src/strings/cpct_drawStringM2.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/strings/cpct_drawStringM2.asm	2025-03-03 16:53:49
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_strings
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_drawStringM2
@@ -122,7 +122,7 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 .globl cpct_drawCharM2_inner_asm
-
+    .if HARDWARE_CPC
    ;; Enable Lower ROM during char copy operation, with interrupts disabled 
    ;; to prevent firmware messing things up
    ld     a,(_cpct_mode_rom_status) ;; [4] A = mode_rom_status (present value)
@@ -156,3 +156,37 @@
    ei                                ;; [1] Enable interrupts
 
 ;; IY Restore and Return provided by bindings
+        .else
+   ;; Enable Lower ROM during char copy operation, with interrupts disabled 
+   ;; to prevent firmware messing things up
+        in      a,(#0xb0)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb0),a 
+
+   jr    firstChar                  ;; [3] Jump to first char (Saves 1 jr back every iteration)
+
+nextChar:
+   ;; Draw next character
+   push  hl                         ;; [4] Save HL
+   call  cpct_drawCharM2_inner_asm  ;; [5 + 137/155] Draws the next character
+   pop   hl                         ;; [3] Recover HL 
+
+   ;; Increment Pointers
+   inc   hl                         ;; [2] ++HL (point to next position in video memory, 8 pixels to the right)
+   inc   iy                         ;; [3] IY += 1 (point to next character in the string)
+
+firstChar:
+   ld     a, (iy)                   ;; [5] A = next character from the string
+   or     a                         ;; [1] Check if A = 0
+   jr    nz, nextChar               ;; [2/3] if A != 0, A is next character, draw it, else end
+
+endstring:
+   ;; After finishing character drawing, restore previous ROM and Interrupts status
+        pop     af
+        ei
+        out     (#0xb0),a 
+
+;; IY Restore and Return provided by bindings
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_count2VSYNC.s cpctelera-linux-enterprise/cpctelera/src/video/cpct_count2VSYNC.s
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_count2VSYNC.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_count2VSYNC.s	2025-03-03 16:55:18
@@ -18,7 +18,7 @@
 .module cpct_video
    
 .include /videomode.s/
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_count2VSYNC
 ;;
@@ -82,7 +82,7 @@
 ;;  needed to process. It will vary depending on how much time has passed since 
 ;;  the last VSYNC.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC
 _cpct_count2VSYNC::
 cpct_count2VSYNC_asm::	
    ld    b, #PPI_PORT_B ;; [2] B = F5h ==> B has the address of PPI Port B, where we get information from VSYNC
@@ -94,4 +94,18 @@
    rra                  ;; [1] Move bit 0 of A to Carry (bit 0 contains VSYNC status)
    jr   nc, wvs_wait    ;; [2/3] No Carry means No VSYNC, so loop While No Carry
 
-   ret                  ;; [3] Carry Set, VSYNC Active, Return
\ No newline at end of file
+   ret                  ;; [3] Carry Set, VSYNC Active, Return
+    .else
+
+_cpct_count2VSYNC::
+cpct_count2VSYNC_asm::	
+   ld   hl, #0          ;; [3] HL=0 HL will be the loop iterations counter, as it is directly used as return value in C
+
+wvs_wait:
+   inc  hl              ;; [2] HL++ counting new iteration of the waiting loop
+   in    a,(#0xb4)        ;; [4] A = Status register got from PPI port B
+   and  #0x10             ;; [1] Move bit 0 of A to Carry (bit 0 contains VSYNC status)
+   jr   z, wvs_wait     ;; [2/3] No Carry means No VSYNC, so loop While No Carry
+
+   ret                  ;; [3] Carry Set, VSYNC Active, Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setCRTCReg.asm cpctelera-linux-enterprise/cpctelera/src/video/cpct_setCRTCReg.asm
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setCRTCReg.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setCRTCReg.asm	2025-03-03 16:55:42
@@ -22,7 +22,7 @@
 ;#####################################################################
 ;
 .module cpct_video
-
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_setCRTCReg
 ;;
@@ -81,7 +81,7 @@
 ;; (end code)
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
+    .if HARDWARE_CPC
    ;; Select CRTC the register to be modified
    ld     a, b                ;; [1] A = Value to be set (Save for later use)
    ld     b, #CRTC_SELECTREG  ;; [2] B = 0xBC CRTC Select Register, C = register number to be selected
@@ -91,4 +91,103 @@
    ld     b, #CRTC_SETVAL     ;; [2] B = 0xBD CRTC Set Register Value
    out  (c), c                ;; [4] Set the value
 
-   ret                        ;; [3] Return to caller
\ No newline at end of file
+   ret                        ;; [3] Return to caller
+    .else
+        ld      e,c
+        ld      d,#0x00
+        ld      hl,#crtregs
+        add     hl,de
+        ld      a,(hl)
+        ld      (regsel+1),a
+regsel: jr      #0x00
+crtreg1:
+        call    pagein
+        ld      a,b
+        ld      (#0xc006),a     ;screen x
+        srl     a
+        ld      b,a
+        ld      a,#0x1f
+        sub     b
+        ld      c,a             ;left margin
+        add     a,b
+        add     a,b
+        ld      h,a             ;right margin
+        ld      a,(#0xc006)     ;screen y
+        ld      b,a
+        ld      a,h
+        call    set_margins
+        ld      a,(pageout+1)
+        push    af
+        ld      de,(#0xc004)
+        jp      setaddr
+
+crtreg6:
+        call    pagein
+        ld      a,b
+        cp      #0x1a
+        jr      c,height_ok
+        ld      a,#0x19
+height_ok:
+        add     a,a
+        add     a,a
+        ld      (#0xc007),a     ;screen y
+        add     a,a
+        ld      b,a
+        ld      a,#0xc8
+        sub     b
+        push    af
+        ld      hl,(#0xc002)    ;rght,left margin
+        ld      c,l
+        ld      a,h
+        call    set_margins
+        ld      c,a
+        pop     af
+        jr      z,pageout
+        ld      b,a
+        ld      a,c
+        ld      c,#0x3f
+        call    set_margins
+pageout:
+        ld      a,#0x00
+        ei
+        out     (#0xb3),a
+crtcret:
+        ret
+
+
+pagein: in      a,(#0xb3)
+        ld      (pageout+1),a
+        ld      a,#0xff
+        di
+        out     (#0xb3),a
+        ret
+
+crtregc:
+        ld      l,b
+        jp      _cpct_setVideoMemoryPage
+crtregd:
+        ld      l,b
+        jp      _cpct_setVideoMemoryOffset
+
+set_margins:
+        ld      hl,#0xc002      ;left margin
+        ld      de,#0x000f
+setmarg:
+        ld      (hl),c
+        inc     l
+        ld      (hl),a
+        add     hl,de
+        ld      (hl),c
+        inc     l
+        ld      (hl),a
+        add     hl,de
+        djnz    setmarg
+        ret
+
+        .include "video/cpct_setVideoMemoryPage.s"
+        .include "video/cpct_setVideoMemoryOffset.s"
+
+crtregs:
+        .db     crtcret-crtreg1,crtreg1-crtreg1,crtcret-crtreg1,crtcret-crtreg1,crtcret-crtreg1,crtcret-crtreg1,crtreg6-crtreg1,crtcret-crtreg1
+        .db     crtcret-crtreg1,crtcret-crtreg1,crtcret-crtreg1,crtcret-crtreg1,crtregc-crtreg1,crtregd-crtreg1,crtcret-crtreg1,crtcret-crtreg1
+   .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setPALColour.asm cpctelera-linux-enterprise/cpctelera/src/video/cpct_setPALColour.asm
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setPALColour.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setPALColour.asm	2025-03-03 16:57:10
@@ -22,7 +22,7 @@
 ;#####################################################################
 ;
 .module cpct_video
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_setPALColour
 ;;
@@ -87,6 +87,7 @@
 ;; http://www.grimware.org/doku.php/documentations/devices/gatearray
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
   ;or  #PAL_PENR           ;; [2] (CCCnnnnn) Mix 3 bits for PENR command (C) and 5 for PEN number (n). 
                            ;; .... As PENR command is 000, nothing to be done here.
    ld     b, #GA_port_byte ;; [2] B = Gate Array Port (0x7F). L has the command that GA will execute.
@@ -96,4 +97,40 @@
    or     h                ;; [1] \
    out  (c), a             ;; [4] GA command: Set INKR. A = Command + Parameter 
                            ;; .... (INKR + INK to be set for selected PEN number)
-   ret                     ;; [3] Return
\ No newline at end of file
+   ret                     ;; [3] Return
+    .else
+
+  ;or  #PAL_PENR           ;; [2] (CCCnnnnn) Mix 3 bits for PENR command (C) and 5 for PEN number (n). 
+                           ;; .... As PENR command is 000, nothing to be done here.
+        di
+        bit     3,l
+        ret     nz
+        bit     4,l
+        jr      nz,border
+        in      a,(#0xb3)
+        push    af
+        ld      a,#0xff
+        out     (#0xb3),a
+        push    de
+        ld      a,(#0xc007)   ;screen y
+        ld      b,a
+        ld      a,h
+        set     3,l
+        ld      h,#0xc0
+        ld      de,#0x0010
+fillcol1:
+        ld      (hl),a
+        add     hl,de
+        ld      (hl),a
+        add     hl,de
+        djnz    fillcol1
+        pop     de
+        pop     af
+        out     (#0xb3),a                           ;; .... (INKR + INK to be set for selected PEN number)
+        ei
+        ret                     ;; [3] Return
+border: ld      a,h
+        out     (#0x81),a
+        ei
+        ret
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setPalette.asm cpctelera-linux-enterprise/cpctelera/src/video/cpct_setPalette.asm
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setPalette.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setPalette.asm	2025-03-03 16:57:44
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_video
-
+ .include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_setPalette
 ;;
@@ -131,6 +131,7 @@
 ;;
 ;; http://www.grimware.org/doku.php/documentations/devices/gatearray
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+    .if HARDWARE_CPC
 
    dec   e                  ;; [1] E = number of colours - 1 = Palette index of the last colour to be set 
    add  hl, de              ;; [3] HL += DE (HL Points to the end of the palette array)
@@ -151,4 +152,53 @@
    dec   e                  ;; [1] E -= 1, Next Palette index to be set (counting backwards)
    jp    p, svp_setPens_loop;; [3] If more than 0 PENs to be set, continue
 
-   ret                      ;; [3] Return
+   ret                      ;; [3] Return 
+    .else
+
+        ld    a,e
+        cp    #0x0a
+        jr    c,palvalok
+        ld    a,#0x09
+palvalok:
+        ld    c,a
+        di
+        in    a,(#0xb3)
+        push  af
+        ld    a,#0xff
+        out   (#0xb3),a
+        ex    de,hl
+        ld    hl,#0xc008
+fillpal:
+        ld      a,(#0xc007)   ;screen y
+        ld      b,a
+        ld    a,(de)
+        push  de
+        push  hl
+;        ld    b,#0x64
+        ld    de,#0x0010
+fillcol1:
+        ld    (hl),a
+        add   hl,de
+        ld    (hl),a
+        add   hl,de
+        djnz  fillcol1
+        pop   hl
+        pop   de
+        inc   l
+        inc   de
+        bit   4,l
+        jr    nz,bias
+        dec   c
+        jr    nz,fillpal
+        jr    nobias
+bias:
+        dec   c
+        jr    z,nobias
+        ld    a,(de)
+        out   (#0x80),a
+nobias:
+        pop   af
+        out   (#0xb3),a
+        ei
+        ret                      ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMemoryOffset.s cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMemoryOffset.s
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMemoryOffset.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMemoryOffset.s	2025-03-03 16:58:08
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_video
-
+ .include "../../CPCteleraHW.src" 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_setVideoMemoryOffset
@@ -105,6 +105,7 @@
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC 
 _cpct_setVideoMemoryOffset::
 cpct_setVideoMemoryOffset_asm::     ;; Assembly entry point
    ;; Select R13 Register from the CRTC and Write there the selected Video Memory Offset
@@ -114,3 +115,90 @@
    out (c), l        ;; [4] Write Selected Video Memory Offset to R13 (A to port 0xBD)
 
    ret               ;; [3] Return 
+    .else
+
+_cpct_setVideoMemoryOffset::
+cpct_setVideoMemoryOffset_asm::     ;; Assembly entry point
+        push    de
+        in      a,(#0xb3)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb3),a
+        ld      a,(#0xc005)
+        and     #0xc0
+        ld      h,#0x00
+        add     hl,hl
+        add     a,h
+        ld      h,a
+        ex      de,hl
+        ld      hl,(#0xc006)   ;screen y, screen x
+        ld      a,l
+        add     a,a
+        ld      (scraddv+1),a
+        ld      a,h
+        rrca
+        rrca
+        and     #0x1f
+        ld      c,a
+        ld      hl,#0xc004
+        ld      b,#0x00
+setadr: push    bc
+        ld      a,d
+        ld      d,#0x08
+        ld      c,#0x0f
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        and     #0xc7
+        ld      d,a
+        ex      de,hl
+scraddv:
+        ld      c,#0x50
+        add     hl,bc
+        ex      de,hl
+        pop     bc
+        dec     c
+        jp      nz,setadr
+        pop     af
+        ei
+        out     (#0xb3),a
+        pop     de
+        ret
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMemoryPage.s cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMemoryPage.s
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMemoryPage.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMemoryPage.s	2025-03-03 16:58:29
@@ -16,7 +16,7 @@
 ;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ;;-------------------------------------------------------------------------------
 .module cpct_video
-
+ .include "../../CPCteleraHW.src" 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; Function: cpct_setVideoMemoryPage
@@ -105,6 +105,7 @@
 ;; (end code)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC 
 _cpct_setVideoMemoryPage::
 cpct_setVideoMemoryPage_asm::  ;; Assembly entry point
    ;; Select R12 Register from the CRTC and Write there the selected Video Memory Page
@@ -114,3 +115,112 @@
    out (c), l        ;; [4] Write Selected Video Memory Page to R12 (A to port 0xBD)
 
    ret               ;; [3] Return
+    .else
+   
+_cpct_setVideoMemoryPage::
+cpct_setVideoMemoryPage_asm::  ;; Assembly entry point
+        push    de
+        ld      a,l
+        rrca
+        rrca
+        rrca
+        rrca
+        and     #0x03
+        ld      c,a
+        ld      b,#0x00
+        ld      a,(bc)
+        cp      #0xfc
+        jp      c,#0x00a0
+        and     #0x03
+        rrca
+        rrca
+        ld      h,a
+        ld      a,l
+        and     #0x03
+        add     a,a
+        add     a,h
+        ld      h,a
+        ld      l,b
+        in      a,(#0xb3)
+        push    af
+        ld      a,#0xff
+        di
+        out     (#0xb3),a
+        ex      de,hl
+        ld      hl,(#0xc004)
+        ld      a,h
+        and     #0x01
+        ld      h,a
+        add     hl,de
+        ex      de,hl
+setaddr:
+        ld      hl,(#0xc006)   ;screen y, screen x
+        ld      a,l
+        add     a,a
+        ld      (scraddv1+1),a
+        ld      a,h
+        rrca
+        rrca
+        and     #0x1f
+        ld      c,a
+        ld      hl,#0xc004
+        ld      b,#0x00
+setadd: push    bc
+        ld      a,d
+        ld      d,#0x08
+        ld      c,#0x0f
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        add     a,d
+        ld      (hl),e
+        inc     l
+        ld      (hl),a
+        add     hl,bc
+        and     #0xc7
+        ld      d,a
+        ex      de,hl
+scraddv1:
+        ld      c,#0x50
+        add     hl,bc
+        ex      de,hl
+        pop     bc
+        dec     c
+        jp      nz,setadd
+        pop     af
+        ei
+        out     (#0xb3),a
+        pop     de
+        ret
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMode.asm cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMode.asm
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_setVideoMode.asm	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_setVideoMode.asm	2025-03-03 16:58:55
@@ -22,7 +22,7 @@
 ;#####################################################################
 ;
 .module cpct_video
-   
+ .include "../../CPCteleraHW.src"   
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_setVideoMode
 ;;
@@ -83,6 +83,7 @@
 ;; cpcrslib by Raul Simarro.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+    .if HARDWARE_CPC
    ld   hl, #_cpct_mode_rom_status ;; [3] HL points to present MODE, INT.GEN and ROM selection byte.
    ld    a, (hl)                   ;; [2] A = Present values for MODE, INT.GEN and ROM selection. (See mode_rom_status)
    and #0xFC                       ;; [2] A = (xxxxxx00) set bits 1,0 to 0, to prepare them for inserting the mode parameter
@@ -92,4 +93,42 @@
 
    ld (hl), a                      ;; [2] Save new Mode and ROM status for later use if required
 
-   ret                             ;; [3] Return
+   ret                             ;; [3] Return 
+    .else
+
+        di
+        in      a,(#0xb3)
+        push    af
+        ld      a,#0xff
+        out     (#0xb3),a
+        ld      a,#0x02
+        sub     l
+        rrca
+        rrca
+        rrca
+        add     a,#0x12
+        push    de
+        ld      hl,#0xc001
+        xor     (hl)
+        and     #0x7f
+        ld      c,a
+        ld      a,(#0xc007)   ;screen y
+        ld      b,a
+        ;ld      b,#0x64
+        ld      de,#0x0010
+fillcol1:
+        ld      a,(hl)
+        xor     c
+        ld      (hl),a
+        add     hl,de
+        ld      a,(hl)
+        xor     c
+        ld      (hl),a
+        add     hl,de
+        djnz    fillcol1
+        pop     de
+        pop     af
+        out     (#0xb3),a                           ;; .... (INKR + INK to be set for selected PEN number)
+        ei
+        ret                     ;; [3] Return
+    .endif
\ No newline at end of file
diff -ruN cpctelera-linux-cpc/cpctelera/src/video/cpct_waitVSYNC.s cpctelera-linux-enterprise/cpctelera/src/video/cpct_waitVSYNC.s
--- cpctelera-linux-cpc/cpctelera/src/video/cpct_waitVSYNC.s	2025-03-03 16:23:19
+++ cpctelera-linux-enterprise/cpctelera/src/video/cpct_waitVSYNC.s	2025-03-03 16:59:17
@@ -18,7 +18,7 @@
 .module cpct_video
    
 .include /videomode.s/
-
+.include "../../CPCteleraHW.src"
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Function: cpct_waitVSYNC
 ;;
@@ -80,6 +80,7 @@
 ;;  on how much time has passed since the last VSYNC.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+.if HARDWARE_CPC
 _cpct_waitVSYNC::
 cpct_waitVSYNC_asm::	;; Assembly entry point
    ld  b, #PPI_PORT_B;; [2] B = F5h ==> B has the address of PPI Port B, where we get information from VSYNC
@@ -90,3 +91,14 @@
    jr  nc, wvs_wait  ;; [2/3] No Carry means No VSYNC, so loop While No Carry
 
    ret               ;; [3] Carry Set, VSYNC Active, Return
+.else
+
+_cpct_waitVSYNC::
+cpct_waitVSYNC_asm::	;; Assembly entry point
+
+wvs_wait:
+   in    a,(#0xb4)        ;; [4] A = Status register got from PPI port B
+   and  #0x10             ;; [1] Move bit 0 of A to Carry (bit 0 contains VSYNC status)
+   jr   z, wvs_wait     ;; [2/3] No Carry means No VSYNC, so loop While No Carry 
+   ret               ;; [3] Carry Set, VSYNC Active, Return
+.endif
diff -ruN cpctelera-linux-cpc/setup1.sh cpctelera-linux-enterprise/setup1.sh
--- cpctelera-linux-cpc/setup1.sh	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/setup1.sh	2025-01-11 16:57:40
@@ -0,0 +1,406 @@
+#!/bin/bash
+##-----------------------------LICENSE NOTICE------------------------------------
+##  This file is part of CPCtelera: An Amstrad CPC Game Engine 
+##  Copyright (C) 2015 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
+##
+##  This program is free software: you can redistribute it and/or modify
+##  it under the terms of the GNU Lesser General Public License as published by
+##  the Free Software Foundation, either version 3 of the License, or
+##  (at your option) any later version.
+##
+##  This program is distributed in the hope that it will be useful,
+##  but WITHOUT ANY WARRANTY; without even the implied warranty of
+##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##  GNU Lesser General Public License for more details.
+##
+##  You should have received a copy of the GNU Lesser General Public License
+##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+##------------------------------------------------------------------------------
+
+###########################################################################
+##                        CPCTELERA ENGINE                               ##
+##                        Main  Setup File                               ##
+##-----------------------------------------------------------------------##
+## This file is a script intended for setting up the environment for the ##
+## first time, before using it.                                          ##
+###########################################################################
+
+## Main Paths
+SETUP_PATH="${PWD}"
+CPCT_MAIN_DIR="${SETUP_PATH}/cpctelera"
+CPCT_TOOLS_DIR="${CPCT_MAIN_DIR}/tools"
+CPCT_SCRIPTS_DIR="${CPCT_TOOLS_DIR}/scripts"
+
+## Bash Include files
+source "${CPCT_SCRIPTS_DIR}/lib/bash_library.sh"
+
+## Describe the use of the setup script and exit
+##
+function usage {
+   echo "${COLOR_LIGHT_YELLOW}USAGE"
+   echo "  ${COLOR_LIGHT_BLUE}$(basename $0) ${COLOR_LIGHT_CYAN}[options]"
+   echo
+   echo "${COLOR_CYAN}  Setups all the environment and installs CPCtelera. It first compiles \
+all the tools included with CPCtelera, its Z80 library and code examples. Finally, it modifies \
+your .bashrc or .bash_profile to include CPCT_PATH environment variable, which is used by \
+CPCtelera projects to use the tools and link with the library."
+   echo
+   echo "${COLOR_LIGHT_YELLOW}OPTIONS"
+   echo 
+   echo "${COLOR_LIGHT_BLUE}  -eme | --enable-machine-echo"
+   echo "${COLOR_LIGHT_BLUE}  -dme | --disable-machine-echo"
+   echo "${COLOR_CYAN}       Enables or disables pauses between character writes that emulate \
+classical machine echo to screen or printer. Enabled by default, except under Cygwin."
+   echo 
+   echo "${COLOR_LIGHT_BLUE}  -cri | --clean-reinstall"
+   echo "${COLOR_CYAN}       Cleans all previous builds of CPCtelera before compiling and \
+setting up tools, library and examples."
+   echo
+   echo "${COLOR_LIGHT_BLUE}  -h | --help"
+   echo "${COLOR_CYAN}       Shows this help information"
+   echo ${COLOR_NORMAL}
+   exit 1
+}
+
+## More paths defined
+CPCT_EXAMPLES_DIR=${SETUP_PATH}/examples
+CPCT_SRC_DIR=${CPCT_MAIN_DIR}/src
+CPCT_CFG_DIR=${CPCT_MAIN_DIR}/cfg
+CPCT_BIN_DIR=${CPCT_MAIN_DIR}/bin
+CPCT_DOCS_DIR=${CPCT_MAIN_DIR}/docs
+CPCT_LOGS_DIR=${CPCT_MAIN_DIR}/logs
+CPCT_TOOLS_2CDT_DIR=${CPCT_TOOLS_DIR}/2cdt
+CPCT_TOOLS_CPC2CDT_DIR=${CPCT_TOOLS_DIR}/cpc2cdt
+CPCT_TOOLS_HEX2BIN_DIR=${CPCT_TOOLS_DIR}/hex2bin-2.0
+CPCT_TOOLS_DSKGEN_DIR=${CPCT_TOOLS_DIR}/dskgen 
+CPCT_TOOLS_IDSK_DIR=${CPCT_TOOLS_DIR}/iDSK-0.13
+CPCT_TOOLS_SDCC_DIR=${CPCT_TOOLS_DIR}/sdcc-3.6.8-r9946
+CPCT_TOOLS_IMG2CPC_DIR=${CPCT_TOOLS_DIR}/img2cpc
+CPCT_TOOLS_RGAS_DIR=${CPCT_TOOLS_DIR}/rgas-1.2.2
+CPCT_TOOLS_ARKOS_DIR=${CPCT_TOOLS_DIR}/arkosTracker-1.0
+CPCT_TOOLS_ZX7B_DIR=${CPCT_TOOLS_DIR}/zx7b
+CPCT_TOOLS_ANDROID_DIR=${CPCT_TOOLS_DIR}/android
+CPCT_TOOLS_ANDROID_BIN_DIR=${CPCT_TOOLS_ANDROID_DIR}/bin
+CPCT_TOOLS_ANDROID_CERTS_DIR=${CPCT_TOOLS_ANDROID_DIR}/certs
+CPCT_TOOLS_ANDROID_RVMENG_DIR=${CPCT_TOOLS_ANDROID_DIR}/rvmengine
+CPCT_TEMPLATES_DIR=${CPCT_SCRIPTS_DIR}/templates
+CPCT_TEMPLATES_NEWPRJ_DIR=${CPCT_SCRIPTS_DIR}/templates/newprj
+CPCT_TEMPLATES_NEWPRJ_SRC_DIR=${CPCT_SCRIPTS_DIR}/templates/newprj/src
+CPCT_TEMPLATES_NEWPRJ_CFG_DIR=${CPCT_SCRIPTS_DIR}/templates/newprj/cfg
+CPCT_TEMPLATES_NEWPRJ_VCD_DIR=${CPCT_SCRIPTS_DIR}/templates/newprj/vscode
+CPCT_TEMPLATES_NEWPRJ_EXP_DIR=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/export
+
+## Main Makefiles and other files
+CPCT_TOOLS_MAKEFILE=${CPCT_TOOLS_DIR}/Makefile
+CPCT_LIB_MAKEFILE=${CPCT_MAIN_DIR}/Makefile
+CPCT_EXAMPLES_MAKEFILE=${CPCT_EXAMPLES_DIR}/Makefile
+CPCT_TEMPLATES_MAKEFILE=${CPCT_TEMPLATES_NEWPRJ_DIR}/Makefile
+CPCT_TEMPLATES_CFG=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/build_config.mk
+CPCT_TEMPLATES_CDT=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/cdt_manager.mk
+CPCT_TEMPLATES_PCK=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/compression.mk
+CPCT_TEMPLATES_MUS=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/music_conversion.mk
+CPCT_TEMPLATES_TIL=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/tilemap_conversion.mk
+CPCT_TEMPLATES_IMG=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/image_conversion.mk
+CPCT_TEMPLATES_EXP_ANDROID=${CPCT_TEMPLATES_NEWPRJ_EXP_DIR}/android.mk
+CPCT_TEMPLATES_CFG_TMPL=${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}/build_config.tmpl.mk
+CPCT_TEMPLATES_MAIN=${CPCT_TEMPLATES_NEWPRJ_SRC_DIR}/main.c
+CPCT_TEMPLATES_BASHRC=${CPCT_TEMPLATES_DIR}/bashrc.tmpl
+
+## Executable files
+CPCT_ARKOS_AKS2BIN=${CPCT_TOOLS_ARKOS_DIR}/tools/AKSToBIN.exe
+CPCT_ARKOS_STK2AKS=${CPCT_TOOLS_ARKOS_DIR}/tools/STKToAKS.exe
+CPCT_ZIPALIGN_LINUX32=${CPCT_TOOLS_ANDROID_BIN_DIR}/zipalign/linux/zipalign32
+CPCT_ZIPALIGN_WIN32=${CPCT_TOOLS_ANDROID_BIN_DIR}/zipalign/win/32/zipalign.exe
+CPCT_ZIPALIGN_WIN32_DLL=${CPCT_TOOLS_ANDROID_BIN_DIR}/zipalign/win/32/libwinpthread-1.dll
+CPCT_JARSIGNER=${CPCT_TOOLS_ANDROID_BIN_DIR}/sun/jarsigner.jar
+CPCT_KEYTOOL=${CPCT_TOOLS_ANDROID_BIN_DIR}/sun/keytool.jar
+CPCT_APKTOOL=${CPCT_TOOLS_ANDROID_BIN_DIR}/apktool/apktool_2.4.0.jar
+CPCT_RVMENG_APK=${CPCT_TOOLS_ANDROID_RVMENG_DIR}/defaultRVMapp.apk
+
+## All directories and files
+CPCT_DIRS=("${CPCT_MAIN_DIR}" "${CPCT_LOGS_DIR}" "${CPCT_EXAMPLES_DIR}" "${CPCT_TOOLS_DIR}"
+           "${CPCT_SRC_DIR}" "${CPCT_CFG_DIR}" "${CPCT_TOOLS_2CDT_DIR}" "${CPCT_TOOLS_HEX2BIN_DIR}" 
+           "${CPCT_TOOLS_IDSK_DIR}" "${CPCT_TOOLS_SDCC_DIR}" "${CPCT_TEMPLATES_DIR}"
+           "${CPCT_TEMPLATES_NEWPRJ_DIR}" "${CPCT_TOOLS_IMG2CPC_DIR}" "${CPCT_TOOLS_RGAS_DIR}" 
+           "${CPCT_TOOLS_ARKOS_DIR}" "${CPCT_TEMPLATES_NEWPRJ_SRC_DIR}" "${CPCT_BIN_DIR}"
+           "${CPCT_TEMPLATES_NEWPRJ_CFG_DIR}" "${CPCT_TEMPLATES_NEWPRJ_VCD_DIR}" "${CPCT_TEMPLATES_NEWPRJ_EXP_DIR}"
+           "${CPCT_DOCS_DIR}" "${CPCT_TOOLS_CPC2CDT_DIR}" "${CPCT_TOOLS_ANDROID_DIR}" "${CPCT_TOOLS_ANDROID_BIN_DIR}"
+           "${CPCT_TOOLS_ANDROID_CERTS_DIR}" "${CPCT_TOOLS_ANDROID_RVMENG_DIR}" "${CPCT_TOOLS_DSKGEN_DIR}"
+           "${CPCT_TOOLS_ZX7B_DIR}")
+CPCT_FILES=("${CPCT_TOOLS_MAKEFILE}" "${CPCT_LIB_MAKEFILE}" "${CPCT_EXAMPLES_MAKEFILE}" 
+            "${CPCT_TEMPLATES_CFG_TMPL}" "${CPCT_TEMPLATES_MAKEFILE}" "${CPCT_TEMPLATES_MAIN}"
+            "${CPCT_TEMPLATES_CDT}" "${CPCT_TEMPLATES_PCK}" "${CPCT_TEMPLATES_MUS}" 
+            "${CPCT_TEMPLATES_TIL}" "${CPCT_TEMPLATES_IMG}" "${CPCT_TEMPLATES_BASHRC}"
+            "${CPCT_TEMPLATES_EXP_ANDROID}" )
+CPCT_EXECUTABLE_FILES=("${CPCT_ARKOS_AKS2BIN}" "${CPCT_ARKOS_STK2AKS}" "${CPCT_ZIPALIGN_LINUX32}"
+            "${CPCT_ZIPALIGN_WIN32}" "${CPCT_ZIPALIGN_WIN32_DLL}" "${CPCT_JARSIGNER}" "${CPCT_KEYTOOL}"
+            "${CPCT_APKTOOL}" "${CPCT_RVMENG_APK}")
+
+## Generated files
+CPCT_EXAMPLES_BUILD_LOG=${CPCT_LOGS_DIR}/examples_building.log
+CPCT_TOOLS_BUILD_LOG=${CPCT_LOGS_DIR}/tool_building.log
+CPCT_LIB_BUILD_LOG=${CPCT_LOGS_DIR}/library_building.log
+CPCT_EXAMPLES_BUILD_LOG_TOTAL_BYTES_CLEAN=28969
+CPCT_EXAMPLES_BUILD_LOG_TOTAL_BYTES=168536
+CPCT_TOOLS_BUILD_LOG_TOTAL_BYTES_CLEAN=25948
+CPCT_TOOLS_BUILD_LOG_TOTAL_BYTES=627034
+CPCT_LIB_BUILD_LOG_TOTAL_BYTES_CLEAN=319
+CPCT_LIB_BUILD_LOG_TOTAL_BYTES=63048
+
+## Substitution tags
+CPCT_TAG_MAINPATH="%%%CPCTELERA_PATH%%%"
+CPCT_TAG_SCRIPTSPATH="%%%CPCTELERA_SCRIPTS_PATH%%%"
+
+## Required stuff for running CPCtelera
+REQUIRED_COMMANDS=(gcc g++ make bison flex)
+COMM_NUM=0
+COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} compiler is required to compile tools. Please \
+install it or build-essentials and run setup again."
+COMM_NUM=$((COMM_NUM + 1))
+COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} compiler is required to compile tools. Please \
+install it or build-essentials and run setup again."
+COMM_NUM=$((COMM_NUM + 1))
+COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} is required for all CPCtelera's build systems. \
+Please, install it and run setup again."
+COMM_NUM=$((COMM_NUM + 1))
+COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} is required to compile SDCC. Please, install it \
+and run setup again."
+COMM_NUM=$((COMM_NUM + 1))
+COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} is required to compile SDCC. Please, install it \
+and run setup again."
+COMM_NUM=$((COMM_NUM + 1))
+GCC_MINIMUM_VERSION="5.1"
+
+REQUIRED_LIBRARIES=("boost/graph/adjacency_list.hpp")
+LIBRARIES_EXPLANATION[0]="${REQUIRED_LIBRARIES[0]} is part of libboost, which is required for building SDCC. Please, install boost / libboost-dev / libboost-devel or similar in your system and run setup again."
+
+## libintl.h is not required in Mac OSX
+if ! checkSystem "osx"; then
+   REQUIRED_LIBRARIES+=( "libintl.h" )
+   LIBRARIES_EXPLANATION+=( "Libintl (development) is required to build SDCC, which makes use of internationalization. Please, install intltool / libintl-dev / libint-devel or similar in your system and run setup again." )
+fi
+## Freeimage is not required in Cygwin (binaries already included)
+if ! checkSystem "cygwin"; then
+   REQUIRED_LIBRARIES+=( "FreeImage.h" )
+   LIBRARIES_EXPLANATION+=( "Freeimage (development) is required to build Img2CPC. Please, install freeimage / libfreeimage-dev / freeimage-devel or similar in your system and run setup again." )
+   REQUIRED_COMMANDS+=( mono )
+   COMMAND_EXPLANATION[$COMM_NUM]="${REQUIRED_COMMANDS[$COMM_NUM]} is required to convert arkos audio files to code automatically. Please, install it \
+and run setup again." 
+   COMM_NUM=$((COMM_NUM + 1))
+fi
+
+## On cygwin, machine echo is disabled by default as it is too slow
+if checkSystem "cygwin"; then
+   disableMachineEchoSleep
+fi
+
+##
+## Setup Control Variables and 
+## Process Command line parameters
+##
+CLEANREINSTALL=false
+while (( $# >= 1 )); do
+   case $1 in
+      ## Disable Machine Echo
+      "-eme" | "--enable-machine-echo")
+         enableMachineEchoSleep
+      ;;
+      ## Disable Machine Echo
+      "-dme" | "--disable-machine-echo")
+         disableMachineEchoSleep
+      ;;
+      ## Get number of bytes
+      "-cri" | "--clean-reinstall")
+         CLEANREINSTALL=true
+      ;;
+      ## Show Help
+      "-h" | "--help")
+         usage
+      ;;
+      ## Unrecognized parameter / command line option
+      *)
+         paramError "Unrecognized parameter / command line option '$1'" 7
+      ;;
+   esac
+   shift
+done
+
+###############################################################
+###############################################################
+## Perform CPCtelera requirements tests
+##   - Check directory structure
+##   - Check required commands installed
+##   - Check required libraries installed
+##
+clearScreen
+welcomeMessage
+stageMessage "1" "CPCtelera initial tests"
+
+# Check directory structure
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Checking directory structure..."
+
+## Checking main path has no spaces in its name
+EnsureFilenameHasNoSpaces "$CPCT_MAIN_DIR" "CPCtelera installation path cannot have spaces in between. Please ensure CPCtelera is in a path without spaces before relaunching setup.sh. "
+
+## Checking that directories exist
+for (( i = 0; i < ${#CPCT_DIRS[@]}; i++ )); do
+   EnsureExists directory "${CPCT_DIRS[$i]}"
+done
+drawOK
+
+# Check file structure
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Checking important files......."
+for (( i = 0; i < ${#CPCT_FILES[@]}; i++ )); do
+   EnsureExists file "${CPCT_FILES[$i]}"
+done
+for (( i = 0; i < ${#CPCT_EXECUTABLE_FILES[@]}; i++ )); do
+   ensureExistsAndIsExecutable file "${CPCT_EXECUTABLE_FILES[$i]}"
+done
+drawOK
+
+# Check installed commands
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Checking required commands..."$'\n'
+for (( i = 0; i < ${#REQUIRED_COMMANDS[@]}; i++ )); do
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Looking for '${REQUIRED_COMMANDS[$i]}'..."
+   EnsureCommandAvailable ${REQUIRED_COMMANDS[$i]} "Command '${REQUIRED_COMMANDS[$i]}' not found installed in the system. ${COMMAND_EXPLANATION[$i]}"
+   drawOK
+done
+
+# Check Command versions
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Checking command versions..."$'\n'
+
+## Different check depending if the main compiler is CLang or GCC
+if isClangDefaultCompiler; then
+   ## Checks for CLang Compiler
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Clang has C++11 support..."
+   ensureClangHasRequiredFeatures
+   drawOK
+else
+   ## Checks for GCC Compiler
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> GNU GCC/G++ Version >= $GCC_MINIMUM_VERSION..."
+   checkMinimumGCCVersion "$GCC_MINIMUM_VERSION"
+   case "$?" in
+      1) Error "CPCtelera requires GCC $GCC_MINIMUM_VERSION or greater. Please, update \
+   your GCC version and run setup again." 1
+      ;;
+      -1) Error "It was impossible to determine your GCC version. Either your GCC version \
+   is too old (previous to 1999) or something is wrong with your GCC installation. Please \
+   check your GCC installation and update your version to $GCC_MINIMUM_VERSION or greater \
+   and run setup again." 2
+      ;;
+      *) drawOK 
+      ;;
+   esac
+fi
+
+# Check installed libraries
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Checking required libraries..."$'\n'
+for (( i = 0; i < ${#REQUIRED_LIBRARIES[@]}; i++ )); do
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Looking for '${REQUIRED_LIBRARIES[$i]}'..."
+   EnsureCPPHeaderAvailable ${REQUIRED_LIBRARIES[$i]} "Header file '${REQUIRED_LIBRARIES[$i]}' not found in the system. ${LIBRARIES_EXPLANATION[$i]}"
+   drawOK
+done
+coloredMachineEcho ${COLOR_LIGHT_GREEN} 0.002 "Everything seems to be OK."$'\n'
+
+###############################################################
+###############################################################
+## Build CPCtelera tools, library and examples
+##
+stageMessage "2" "Building CPCtelera tools, z80 library and examples"
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Proceeding to build required tools to build and manage CPCtelera and other software for Amstrad CPC (This might take a while, depending on your system)."$'\n'
+
+###------
+# Clean previous installations, if the user requested it
+###------
+if $CLEANREINSTALL; then
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">> Cleaning previous installation to perform a clean reinstall..."$'\n'
+
+   ## Cleaning library
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Cleaning previosly built z80 lib:  "
+   makeWithProgressSupervision "$CPCT_MAIN_DIR" "$CPCT_LIB_BUILD_LOG" cleanall \
+                             "$CPCT_LIB_BUILD_LOG_TOTAL_BYTES_CLEAN"  35  0.05  \
+               "There was an error cleaning previous build of CPCtelera's Z80 Library" 
+
+   ## Cleaning examples
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Cleaning previosly built examples: "
+   makeWithProgressSupervision "$CPCT_EXAMPLES_DIR" "$CPCT_EXAMPLES_BUILD_LOG" cleanall \
+                                 "$CPCT_EXAMPLES_BUILD_LOG_TOTAL_BYTES_CLEAN"  35  0.1  \
+               "There was an error cleaning previous build of CPCtelera's examples" 
+
+   coloredMachineEcho "${COLOR_CYAN}" 0.005 ">> Previous install is clean. Proceeding to rebuild..."$'\n'
+fi
+
+# Build library in subshell process, then go monitoring until it finishes
+coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Building cpctelera z80 lib:        "
+make -C "${CPCT_MAIN_DIR}" cleanall &> "${CPCT_LIB_BUILD_LOG}"
+makeWithProgressSupervision "$CPCT_MAIN_DIR" "$CPCT_LIB_BUILD_LOG" "" \
+                          "$CPCT_LIB_BUILD_LOG_TOTAL_BYTES"  35  0.1  \
+                     "There was an error building CPCtelera z80 library"
+
+coloredMachineEcho ${COLOR_LIGHT_GREEN} 0.002 "> Bulding procedure finished. "$'\n'
+coloredMachineEcho ${COLOR_LIGHT_GREEN} 0.002 "> CPCtelera's tools and library are now ready to be used on your system."$'\n'
+
+# Build examples in subshell process, then go monitoring until it finishes
+coloredMachineEcho $'\n'"${COLOR_CYAN}" 0.005 ">>> Building cpctelera examples:       "
+export PATH=$PATH:$CPCT_SCRIPTS_DIR
+export CPCT_PATH=$CPCT_MAIN_DIR
+makeWithProgressSupervision "$CPCT_EXAMPLES_DIR" "$CPCT_EXAMPLES_BUILD_LOG" "" \
+                              "$CPCT_EXAMPLES_BUILD_LOG_TOTAL_BYTES"  35  0.1  \
+                               "There was an error building CPCtelera examples."
+
+###############################################################
+###############################################################
+## Configuring environment and project templates
+##
+stageMessage "3" "Configuring CPCtelera environment"
+coloredMachineEcho "${COLOR_CYAN}" 0.005 "> Setting up present CPCtelera folder as install directory and configuring routes and templates..."$'\n'
+
+## Select System-dependent profile script
+PROFILE=$(bashProfileFilename)
+
+# Configuring CPCTelera global path in templates
+coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> CPCTelera full path: ${COLOR_WHITE}${CPCT_MAIN_DIR}"$'\n'
+coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Inserting full path into build config template..."
+cp "${CPCT_TEMPLATES_CFG_TMPL}" "${CPCT_TEMPLATES_CFG}"
+replaceTaggedLine "${CPCT_TAG_MAINPATH}" "CPCT_PATH := ${CPCT_MAIN_DIR}\#${CPCT_TAG_MAINPATH}" "${CPCT_TEMPLATES_CFG}" '#'
+drawOK
+
+# Configuring PATH to use CPCTelera scripts in the system
+coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> CPCTelera scripts path: ${COLOR_WHITE}${CPCT_SCRIPTS_DIR}"$'\n'
+coloredMachineEcho "${COLOR_CYAN}" 0.005 ">>> Adding scripts path to ${COLOR_WHITE}\$PATH${COLOR_CYAN} variable in ${COLOR_WHITE}${PROFILE}${COLOR_CYAN}..."
+
+# First, eliminate previous instances of CPCTelera into PROFILE, then add new
+touch "$PROFILE"
+removeLinesBetween "###CPCTELERA_START" "###CPCTELERA_END" "$PROFILE"
+removeTrailingBlankLines "$PROFILE"
+cat "$CPCT_TEMPLATES_BASHRC" >> "$PROFILE"
+replaceTag "$CPCT_TAG_MAINPATH" "$CPCT_MAIN_DIR" "$PROFILE" '#'
+replaceTag "$CPCT_TAG_SCRIPTSPATH" "$CPCT_SCRIPTS_DIR" "$PROFILE" '#'
+drawOK
+
+###############################################################
+###############################################################
+## Final message to the user
+##
+echo
+coloredMachineEcho ${COLOR_LIGHT_WHITE} 0.002 "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"$'\n'"%%%"
+coloredMachineEcho ${COLOR_LIGHT_GREEN} 0.002 " CPCtelera is now ready to be used on your system. "
+coloredMachineEcho ${COLOR_LIGHT_WHITE} 0.002 "%%%"$'\n'"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"$'\n'
+echo
+
+coloredMachineEcho ${COLOR_CYAN} 0.001 "You may now go to the examples folder and play around with the included \
+example projects. Inside any project's folder, just type make to create CDT and DSK files for Amstrad CPC. In the \
+${COLOR_WHITE}src/${COLOR_CYAN} folder you will find C source code for each example. The ${COLOR_WHITE}cfg/\
+${COLOR_CYAN} folder contains the building configuration for your project. Change everything as you like."$'\n'
+echo
+coloredMachineEcho ${COLOR_CYAN} 0.001 "If you wanted to create a new project, you may use \
+${COLOR_WHITE}cpct_mkproject <project_folder>${COLOR_CYAN}. This is a script that automates the creation \
+of new projects. For convenience, it has been included in your ${COLOR_WHITE}\$PATH${COLOR_CYAN} environment \
+variable (you need to open a new shell for this to take effect). You may create projects anywhere, provided \
+you do not change CPCtelera's main folder location. "$'\n'
+echo
+coloredMachineEcho ${COLOR_CYAN} 0.001 "If you have any comments, please go to \
+${COLOR_WHITE}https://github.com/lronaldo/cpctelera${COLOR_CYAN} or send an email \
+${COLOR_WHITE}cpctelera@cheesetea.com${COLOR_CYAN}. We hope you enjoy the library and expect to see your \
+games comming out soon :)."$'\n'
+echo ${COLOR_NORMAL}
diff -ruN cpctelera-linux-cpc/start.src cpctelera-linux-enterprise/start.src
--- cpctelera-linux-cpc/start.src	1970-01-01 01:00:00
+++ cpctelera-linux-enterprise/start.src	2025-01-11 16:57:32
@@ -0,0 +1,358 @@
+;vidpage     equ     80h           ;1 video page on 00000h
+;vidpage     equ     81h           ;1 video page on 04000h
+;vidpage     equ     82h           ;1 video page on 08000h
+vidpage     equ     83h           ;1 video page on 0c000h
+;vidpage     equ     01h           ;2 video pages on 00000h and 04000h
+;vidpage     equ     02h           ;2 video pages on 00000h and 08000h
+;vidpage     equ     03h           ;2 video pages on 00000h and 0c000h
+;vidpage     equ     12h           ;2 video pages on 04000h and 08000h
+;vidpage     equ     13h           ;2 video pages on 04000h and 0c000h
+;vidpage     equ     23h           ;2 video pages on 08000h and 0c000h
+bias        equ     31
+border      equ     0
+screen_y    equ     25*8
+;scrload     equ     0c000h          ;load address of screen file , if it is 0 then screen is not loaded
+scrload     equ     00000h          ;load address of screen file , if it is 0 then screen is not loaded
+scrlength   equ     4000h           ;load length of screen file , name of file has to be set at filescr:
+file1load   equ     4000h           ;load address of file1 , if it is 0 then file1 is not loaded        (ex intro)
+file1length equ     2200h           ;load length of file1 , name of file has to be set at file1:
+file1start  equ     48B8h           ;start address of 1st file, after end it will return to loader
+file2load   equ     0100h           ;load address of file2                                              (main program)
+file2length equ     4000h           ;load length of file2 , name of file has to be set at file2:
+file2start  equ     0100h           ;start address of 2nd file, it will not return to loader
+
+reset	equ		00a0h
+lptstrt equ		8000h
+		macro   exos n
+		rst		30h
+		db		n
+		endm
+		
+		org		00f0h
+		db		00h,05h
+		dw		fillen
+		defs	0ch
+startpr	di
+		ld		sp,0100h
+		ld      hl,reset1
+        ld      de,reset
+        ld      bc,resetln
+        push    de
+        ldir
+        pop     hl
+        ld      (0bff8h),hl
+
+        ld      bc,100h+28      ;set bias d
+        ld      d,bias*8
+        exos    16
+
+        ld      bc,100h+27      ;set border d
+        ld      d,border
+        exos    16
+
+        ld      hl,0000h
+delvar  ld      (hl),h
+        inc     l
+        bit     3,l
+        jr      z,delvar
+vid     ld      hl,tmp_mem
+reqpage exos    24
+        ld      (hl),c
+        inc     hl
+        jr      z,reqpage
+        inc     c
+        jp      nz,reset        ;if shared segment is not FF
+        dec     l
+        ld      a,l
+        cp      03h             ;if EP64, it is 2, and reset computer
+        jp      c,reset
+        ld      d,00h
+        ld      (hl),d
+    if vidpage < 80h            ;get 1st video segment, if 2 was specified
+        dec     l
+        ld      a,(hl)
+        ld      (hl),d
+        ld      e,vidpage / 10h
+        ld      (de),a
+    endif
+        dec     l               ;get a video segment, and store it's place in memora
+        ld      a,(hl)
+        ld      (hl),d
+        cp      0fch
+        jp      c,reset
+        push    af              ;store video page
+        ld      e,vidpage and 03h
+        ld      (de),a
+        ld      hl,tmp_mem      ;allocate other RAM's, max 8x16KB is allocated
+        in      a,(0b0h)
+        ld      c,a
+        ld      e,d
+chknxtp ld      a,(de)          ;if video memory is not specified for page0, then page0 will contain pos0 in RAM config
+        or      a
+        jr      z,storpg0
+        inc     e               ;if video memory is specified for page0 or 1, then active page0 goes to pos1 or 2 in RAM config
+        bit     3,e
+        jr      nz,endramc
+        jr      chknxtp
+storpg0 ld      a,c
+        ld      (de),a
+        inc     e
+        ld      c,(hl)
+        inc     l
+        bit     3,e
+        jr      z,chknxtp
+endramc 
+givebck dec     hl
+        ld      c,(hl)
+        exos    25
+        jr      z,givebck
+
+        ld      de,0ce0h        ;setEXOSboundary
+        exos    23
+        jp      nz,reset
+
+        pop     af              ;restore video page into AF
+        rrca
+        rrca
+        and     0c0h
+        ld      (vlpb+5),a		;video address into LPT source
+		ld		c,a
+		ld		a,0c0h
+		sub     c
+		ld		(difc000+2),a
+
+        ld      a,0ffh
+        out     (0b2h),a
+        ld      hl,0000h
+        in      a,(0b0h)
+        cp      (hl)
+        jr      z,page0ok
+        di
+        ld      a,(hl)
+        ld      (0bffch),a      ;store new page0 at page0 system variable
+        out     (0b1h),a
+        ld      hl,0000h
+        ld      de,4000h
+        ld      b,d
+        ld      c,e
+        ldir
+        out     (0b0h),a        ;activate new page0
+        ei
+page0ok
+        ld      hl,vlpb
+        ld      de,lptstrt
+        ld      bc,0010h
+        push    de
+        ldir					;copy 1 LPB (line parameter block) into LPT
+        pop     hl
+        ld      bc,0c70h		
+        ldir					;create next 199 LPB (CPC screen is 200 line)
+        ld      hl,vsync	
+        ld      bc,vsyncln
+        ldir					;copy VSYNC LPB's
+        ld      hl,lptstrt+0c00h+1
+        ld      b,08h
+        ld      de,0010h
+setvint set     7,(hl)          ;set video int place
+        add     hl,de
+        djnz    setvint
+
+        ld      a,25*8-screen_y ;number of lines to be deactivated on bottom of the screen
+        call    disable_scr_bottom
+        
+        ld      bc,0c850h		;200 (0c8h) row 40 (50h/2) ( line/character )
+
+vidaddr	ld      iy,lptstrt		;address of LPT , it is paged now to page2, 8000h-800fh-n status line
+vlpb4   ld      hl,(vlpb+4)
+vidcikl	push    bc				;calculate memory address of LPB's
+        ld      (iy+4),l		;Store low Nick address of screen line into LPB
+        ld      (iy+5),h		;Store high Nick address of screen line into LPB
+difc000 ld      de,4000h		;difference between CPC screen address, and Nick address
+        add     hl,de			;get CPC address
+        call    vidadd			;calculate the address
+        xor     a
+        sbc     hl,de			;get Nick address
+        ld      de,0010h
+        add     iy,de			;next LPB line
+        pop     bc
+        djnz    vidcikl
+
+        ld      a,(0001h)
+        out     (0b1h),a
+        ld      a,(0002h)
+        out     (0b2h),a
+        ld      a,(0003h)
+        out     (0b3h),a
+        ld      hl,4000h
+        ld      de,4001h
+        ld      (hl),l
+        ld      bc,0bfffh
+        ldir
+
+        ld      sp,0c000h
+
+    if scrload > 0
+        ld      de,filescr      ;file name
+        ld      hl,scrload      ;file target
+        ld      bc,scrlength    ;file length
+        call    loadfile
+    endif
+		xor		a
+		out		(82h),a
+		ld		a,0cch
+		out		(83h),a
+
+;        call    load_map        ;load map
+    if file1load > 0
+		ld		de,file1
+		ld		bc,file1length  ;file length (this has to be updated or checked after each compile)
+		ld		hl,file1load    ;load address (this has to be updated)
+		call    loadfile
+        call    file1start      ;intro start
+    endif
+
+        di
+xxx     inc     a
+        out     (81h),a
+        jr      xxx
+
+		xor     a
+		ld      de,file2
+		exos    1
+		jp      nz,reset
+		ld      hl, loading
+		ld      de, 0bf00h
+		ld      bc, loading_end - loading
+        push    de
+		ldir
+		ret
+loading
+		ld      bc,file2length  ;file length (this has to be updated or checked after each compile)
+		ld      de,file2load    ;load address (this has to be updated)
+		exos    6
+		xor     a
+		exos    3
+		jp      file2start      ;start address (this has to be updated or checked after each compile)
+loading_end
+
+    if scrload > 0
+filescr:
+        db      8,"test.scr"    ;file name to be loaded
+    endif
+    if file1load > 0
+;file1: db       8,"test.pr1"    ;file name to be loaded
+file1:  db      9,"intro.bin"    ;file name to be loaded
+    endif
+file2:  db      8,"test.pr2"    ;file name to be loaded
+
+loadfile
+		xor		a
+        push    bc
+        push    hl
+		exos	1
+        jp      nz,reset
+        pop     de
+        pop     bc
+        exos    6
+        xor     a
+        exos    3
+        ret
+
+vidadd	ld      a,h				;Create CPC screen addressing into LPT
+        add     a,8				; 1. char row: 0c000h, 0c800h, 0d000h, 0d800h, 0e000h, 0e8000h, 0f000h, 0f8000h 
+        ld      h,a				; 2. char row: 0c050h, 0c850h, 0d050h, 0d850h, 0e050h, 0e8050h, 0f050h, 0f8050h 
+        ret     nc				; 3. char row: 0c0a0h, 0c8a0h, 0d0a0h, 0d8a0h, 0e0a0h, 0e80a0h, 0f0a0h, 0f80a0h 
+        sub     40h				;etc
+        ld      h,a
+        ld      a,l
+        add     a,c
+        ld      l,a
+        ret     nc
+        inc     h
+        ret
+
+disable_scr_bottom
+        or      a
+        ret     z
+        ret     m
+        ld      b,a
+        ld      a,0c8h
+        sub     b
+        ld      l,a
+        ld      h,00h
+        add     hl,hl
+        add     hl,hl
+        add     hl,hl
+        add     hl,hl
+        ld      de,lptstrt+02h  ;left margin
+        add     hl,de           ;LPT address of first line to be excluded
+        ld      de,0010h
+setlineoff
+        ld      (hl),03fh       ;set left margin to the maximum value
+        add     hl,de
+        djnz    setlineoff
+        ret
+
+;load_map
+;        xor     a               ;channel 0
+;        ld      de,filemap      ;file name
+;        exos    1               ;open file to channel 0
+;        ld      de,0c5a0h       ;load address 50592 (decimal values also can be used in the code, i do not like them :) )
+;        ld      hl,0230h        ;load length 560 bytes
+;        ld      b,05h           ;5x560 bytes are going to be loaded
+;        call    load_parts
+;        ld      de,0ed50h       ;load address 60752
+;        ld      hl,0280h        ;load length 640 bytes
+;        ld      b,03h           ;3x640 bytes are going to be loaded
+;        call    load_parts
+;        xor     a
+;        exos    3               ;close file (close channel 0)
+;        ret
+
+;load_parts
+;        ld      (loadlng+1),hl
+;load_part
+;        push    bc
+;        push    de
+;        xor     a               ;channel 0
+;loadlng ld      bc,0000h        ;load length
+;        exos    6               ;load 230h bytes to 0c5a0h on channel 0
+;        pop     de
+;        pop     bc
+;        ld      a,d
+;        add     a,08h
+;        ld      d,a             ;next load address calculated
+;        djnz    load_part
+;        ret
+;filemap db      9,"teopl.map"   ;file name and it's lenght to be updated
+
+reset1  ld      sp,0100h
+        ld      a,0ffh
+        out     (0b2h),a
+        ld      hl,reset
+        ld      (0bff8h),hl
+        ld      c,40h
+        exos    0
+        ld      a,01h
+        out     (0b3h), a
+        ld      a,06h
+        jp      0c00dh
+resetln equ     $-reset1
+
+vlpb    db 0ffh,052h,0bh,33h,000h,00h,0,0       ;video lpb			200
+        db 00h,00h,00h,00h,00h,00h,00h,00h
+vsync   db 0d4h,2,3fh,0,0,0,0,0                 ;sync               44
+        db 00,00,00,00,00,00,00,00
+        db 0fdh,0,3fh,0,0,0,0,0                 ;                   3
+        db 00,00,00,00,00,00,00,00
+        db 0feh,0,6,3fh,0,0,0,0                 ;                   2
+        db 00,00,00,00,00,00,00,00
+        db 0ffh,0,3fh,20h,0,0,0,0               ;                   1
+        db 00,00,00,00,00,00,00,00
+        db 0f0h,2,6,3fh,6,0,0,0                 ;c3-->f3            18
+        db 00,00,00,00,00,00,00,00
+        db 0d4h,3,3fh,0,0,0,0,0                 ;f7-->c7            44
+        db 00,00,00,00,00,00,00,00
+vsyncln equ		$-vsync
+tmp_mem equ     ((high $) + 1) * 100h
+fillen  equ     $-startpr
